<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Setting up a custom domain with github pages site]]></title>
      <url>https://jarsonfang.github.io/tools/github/setting-up-a-custom-domain-with-github-pages-site/</url>
      <content type="html"><![CDATA[<p><a href="https://help.github.com/articles/quick-start-setting-up-a-custom-domain/" target="_blank" rel="external">Quick start: Setting up a custom domain</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 部署]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hexo-deploy/</url>
      <content type="html"><![CDATA[<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div></pre></td></tr></table></figure></p>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo:</div><div class="line">- type: heroku</div><div class="line">  repo:</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>安装 hexo-deployer-git。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>repo</td>
<td>库(Repository)地址</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称。如果您使用的是GitHub或GitCafe的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息（默认为Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} ）</td>
</tr>
</tbody>
</table>
<h2 id="Rsync"><a href="#Rsync" class="headerlink" title="Rsync"></a>Rsync</h2><p>安装 hexo-deployer-rsync。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-rsync --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: rsync</div><div class="line">  host: &lt;host&gt;</div><div class="line">  user: &lt;user&gt;</div><div class="line">  root: &lt;root&gt;</div><div class="line">  port: [port]</div><div class="line">  delete: [true|false]</div><div class="line">  verbose: [true|false]</div><div class="line">  ignore_errors: [true|false]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>远程主机的地址</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>使用者名称</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>远程主机的根目录</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
<td>22</td>
</tr>
<tr>
<td>delete</td>
<td>删除远程主机上的旧文件</td>
<td>true</td>
</tr>
<tr>
<td>verbose</td>
<td>显示调试信息</td>
<td>true</td>
</tr>
<tr>
<td>ignore_errors</td>
<td>忽略错误</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="FTPSync"><a href="#FTPSync" class="headerlink" title="FTPSync"></a>FTPSync</h2><p>安装 hexo-deployer-ftpsync。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-ftpsync --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: ftpsync</div><div class="line">  host: &lt;host&gt;</div><div class="line">  user: &lt;user&gt;</div><div class="line">  pass: &lt;password&gt;</div><div class="line">  remote: [remote]</div><div class="line">  port: [port]</div><div class="line">  ignore: [ignore]</div><div class="line">  connections: [connections]</div><div class="line">  verbose: [true|false]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>远程主机的地址</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>使用者名称</td>
<td></td>
</tr>
<tr>
<td>pass</td>
<td>密码</td>
<td></td>
</tr>
<tr>
<td>remote</td>
<td>远程主机的根目录</td>
<td>/</td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
<td>21</td>
</tr>
<tr>
<td>ignore</td>
<td>忽略的文件或根目录</td>
<td></td>
</tr>
<tr>
<td>connections</td>
<td>使用的连接数</td>
<td>1</td>
</tr>
<tr>
<td>verbose</td>
<td>显示调试信息</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 资源文件夹]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hexo-asset-folders/</url>
      <content type="html"><![CDATA[<p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>
<a id="more"></a>
<p><strong>文章资源文件夹</strong></p>
<p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure></p>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<p><strong>相对路径引用的标签插件</strong></p>
<p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>
<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img example.jpg This is an example image %&#125;</div></pre></td></tr></table></figure></p>
<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<p>Q: 如果有的文章需要资源文件夹，有的文章不需要资源文件夹怎么弄？<br>A: 直接用markdown，把图片放到指定的文件夹（而不是跟文章同名的那个文件夹）？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 标签插件]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hexo-tag-plugins/</url>
      <content type="html"><![CDATA[<p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p>
<h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><p>在文章中插入引言，可包含作者、来源和标题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</div><div class="line">content</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>没有提供参数，则只输出普通的blockquote</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote %&#125;</div><div class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>
<p><strong>引用书上的句子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</div><div class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<p><strong>引用Twitter</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</div><div class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="external">http://devdocs.io</a></p>
<footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="external">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote>
<p><strong>引用网络上的文章</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</div><div class="line">Every interaction is both precious and an opportunity to delight.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>在文章中插入代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</div><div class="line">code snippet</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>普通的代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock %&#125;</div><div class="line">alert(&apos;Hello World!&apos;);</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(&apos;Hello World!&apos;);</div></pre></td></tr></table></figure>
<p><strong>指定语言</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock lang:objc %&#125;</div><div class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</div></pre></td></tr></table></figure>
<p><strong>附加说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock Array.map %&#125;</div><div class="line">array.map(callback[, thisArg])</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<p><strong>附加说明和网址</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock \_.compact http://underscorejs.org/#compact Underscore.js %&#125;</div><div class="line">\_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>\_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div></pre></td></tr></table></figure>
<h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><h3 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h3><p>引用其他文章的链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% post_path slug %&#125;</div><div class="line">&#123;% post_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% post_path hexo-commands %&#125;</div></pre></td></tr></table></figure></p>
/tools/Hexo/hexo-commands/
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% post_link hexo-commands %&#125;</div></pre></td></tr></table></figure>
<a href="/tools/Hexo/hexo-commands/" title="Hexo 命令">Hexo 命令</a>
<h3 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h3><p>引用文章的资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% raw %&#125;</div><div class="line">content</div><div class="line">&#123;% endraw %&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 基本操作]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hexo-operations/</url>
      <content type="html"><![CDATA[<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>您可以执行下列命令来创建一篇新文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>您可以在命令中指定文章的布局(layout)，默认为<code>post</code>，可以通过修改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局。</p>
<p><strong>布局(layout)</strong></p>
<p>Hexo有三种默认布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和<code>post</code>相同，都将存储到<code>source/_posts</code>文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>不要处理我的文章</strong><br>如果你不想你的文章被处理，你可以将Front-Matter中的<code>layout:</code>设为<code>false</code>。</p>
</blockquote>
<a id="more"></a>
<p><strong>文件名称</strong></p>
<p>Hexo默认以标题作为文件名称，但您可编辑<code>new_post_name</code>参数来改变默认的文件名称，举例来说，设为<code>:year-:month-:day-:title.md</code>可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:title</code></td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td><code>:year</code></td>
<td>建立的年份，比如，<code>2015</code></td>
</tr>
<tr>
<td><code>:month</code></td>
<td>建立的月份（有前导零），比如，<code>04</code></td>
</tr>
<tr>
<td><code>:i_month</code></td>
<td>建立的月份（无前导零），比如，<code>4</code></td>
</tr>
<tr>
<td><code>:day</code></td>
<td>建立的日期（有前导零），比如，<code>07</code></td>
</tr>
<tr>
<td><code>:i_day</code></td>
<td>建立的日期（无前导零），比如，<code>7</code></td>
</tr>
</tbody>
</table>
<p><strong>草稿</strong></p>
<p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>
<p><strong>模板(Scaffold)</strong></p>
<p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new photo <span class="string">"My Gallery"</span></div></pre></td></tr></table></figure></p>
<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找<code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>layout</code></td>
<td>布局</td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
</tr>
<tr>
<td><code>date</code></td>
<td>文件建立日期</td>
</tr>
</tbody>
</table>
<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以<code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hello World</div><div class="line">date: 2013/7/13 20:46:25</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于页面(pages)）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于页面(pages)）</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章默认的永久链接</td>
</tr>
</tbody>
</table>
<p><strong>分类和标签</strong></p>
<p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">categories:</div><div class="line">- Sports</div><div class="line">- Baseball</div><div class="line">tags:</div><div class="line">- Injury</div><div class="line">- Fight</div><div class="line">- Shocking</div></pre></td></tr></table></figure></p>
<p><strong>JSON Front-matter</strong></p>
<p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;title&quot;: &quot;Hello World&quot;,</div><div class="line">&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;</div><div class="line">;;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 命令]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hexo-commands/</url>
      <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong>init</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init [folder]</div></pre></td></tr></table></figure></p>
<p>新建一个网站。如果没有设置<code>folder</code>，Hexo默认在目前的文件夹建立网站。</p>
<p><strong>new</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。<br><a id="more"></a></p>
<p><strong>generate</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure></p>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code>, <code>--deploy</code></td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td><code>-w</code>, <code>--watch</code></td>
<td>监视文件变动</td>
</tr>
</tbody>
</table>
<p><strong>publish</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;filename&gt;</div></pre></td></tr></table></figure></p>
<p>发表草稿。</p>
<p><strong>server</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-p</code>, <code>--port</code></td>
<td>重设端口</td>
</tr>
<tr>
<td><code>-s</code>, <code>--static</code></td>
<td>只使用静态文件</td>
</tr>
<tr>
<td><code>-l</code>, <code>--log</code></td>
<td>启动日志记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<p><strong>deploy</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-g</code>, <code>--generate</code></td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<p><strong>render</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo render &lt;file1&gt; [file2] ...</div></pre></td></tr></table></figure></p>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o</code>, <code>--output</code></td>
<td>设置输出路径</td>
</tr>
</tbody>
</table>
<p><strong>migrate</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure></p>
<p>从其他博客系统迁移内容。<br>例如，迁移 WordPress:<br>首先，安装 <code>hexo-migrator-wordpress</code> 插件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-migrator-wordpress --save</div></pre></td></tr></table></figure></p>
<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)<br>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo migrate wordpress &lt;<span class="built_in">source</span>&gt;</div></pre></td></tr></table></figure></p>
<p><strong>clean</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure></p>
<p>清除缓存文件(<code>db.json</code>)和已生成的静态文件(<code>public</code>)。</p>
<p><strong>list</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure></p>
<p>列出网站资料。</p>
<p><strong>version</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo version</div></pre></td></tr></table></figure></p>
<p>显示Hexo版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><strong>安全模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --safe</div></pre></td></tr></table></figure></p>
<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<p><strong>调试模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --debug</div></pre></td></tr></table></figure></p>
<p>在终端中显示调试信息并记录到<code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并<a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="external">提交调试信息到GitHub</a></p>
<p><strong>简洁模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --silent</div></pre></td></tr></table></figure></p>
<p>隐藏终端信息。</p>
<p><strong>自定义配置文件的路径</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --config custom.yml</div></pre></td></tr></table></figure></p>
<p>自定义配置文件的路径，执行后将不再使用<code>_config.yml</code>。</p>
<p><strong>显示草稿</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --draft</div></pre></td></tr></table></figure></p>
<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>
<p><strong>自定义CWD</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --cwd /path/to/cwd</div></pre></td></tr></table></figure></p>
<p>自定义当前工作目录(Current working directory)的路径。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[awk 手册]]></title>
      <url>https://jarsonfang.github.io/tools/sed-awk/awk/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简体中文版由bones7456 (<a href="http://li2z.cn)整理" target="_blank" rel="external">http://li2z.cn)整理</a>.<br>原文:应该是 <a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank" rel="external">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a> 但是原文很乱.<br>说明:之前也是对awk几乎一无所知,无意中看到这篇文章,网上一搜,居然没有像样的简体中文版.有的也是不怎么完整,或者错误一大堆的.于是就顺手整理了下这篇文章.通过整理这篇文章,自己也渐渐掌握了awk的种种用法.<br>原文可能比较老,有些目前已经不适用的命令有所改动,文中所有命令均在ubuntu7.04下调试通过,用的awk是mawk.<br>由于本人能力有限,错误和不妥之处在所难免,欢迎多多指正.  </p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="有关本手册"><a href="#有关本手册" class="headerlink" title="有关本手册"></a>有关本手册</h3><p>这是一本awk学习指引, 其重点着重于:</p>
<ol>
<li>awk 适于解决哪些问题?</li>
<li>awk 常见的解题模式为何?</li>
</ol>
<p>为使读者快速掌握awk解题的模式及特性, 本手册系由一些较具代表性的范例及其题解所构成; 各范例由浅入深, 彼此间相互连贯, 范例中并对所使用的awk语法及指令辅以必要的说明. 有关awk的指令, 函数, … 等条列式的说明则收录于附录中, 以利读者往后撰写程序时查阅. 如此编排, 可让读者在短时间内顺畅地学会使用awk来解决问题. 建议读者循着范例上机实习, 以加深学习效果.<br>读者宜先具备下列背景:<br>[a.] UNIX 环境下的简单操作及基本概念.<br>例如: 文件编辑, 文件复制及管道, 输入/输出重定向等概念<br>[b.] C 语言的基本语法及流程控制指令.<br>(awk 指令并不多, 且其中之大部分与C语言中之用法一致, 本手册中对该类指令之语法及特性不再加以繁冗的说明, 读者若欲深究,可自行翻阅相关的 C 语言书籍)</p>
<h2 id="awk概述"><a href="#awk概述" class="headerlink" title="awk概述"></a>awk概述</h2><h3 id="为什么使用awk"><a href="#为什么使用awk" class="headerlink" title="为什么使用awk"></a>为什么使用awk</h3><p>awk 是一种程序语言. 它具有一般程序语言常见的功能.<br>因awk语言具有某些特点, 如: 使用直译器(Interpreter)不需先行编译; 变量无类型之分(Typeless), 可使用文字当数组的下标(Associative Array)…等特色. 因此, 使用awk撰写程序比起使用其它语言更简洁便利且节省时间. awk还具有一些内建功能, 使得awk擅于处理具数据行(Record), 字段(Field)型态的资料; 此外, awk内建有pipe的功能, 可将处理中的数据传送给外部的Shell命令加以处理, 再将Shell命令处理后的数据传回awk程序, 这个特点也使得awk程序很容易使用系统资源.<br>由于awk具有上述特色, 在问题处理的过程中, 可轻易使用awk来撰写一些小工具; 这些小工具并非用来解决整个大问题,它们只扮演解决个别问题过程的某些角色, 可藉由Shell所提供的pipe将数据按需要传送给不同的小工具进行处理, 以解决整个大问题. 这种解题方式, 使得这些小工具可因不同需求而被重复组合及重用(reuse); 也可藉此方式来先行测试大程序原型的可行性与正确性, 将来若需要较高的执行速度时再用C语言来改写.这是awk最常被应用之处. 若能常常如此处理问题, 读者可以以更高的角度来思考抽象的问题, 而不会被拘泥于细节的部份.<br>本手册为awk入门的学习指引, 其内容将先强调如何撰写awk程序,未列入进一步解题方式的应用实例, 这部分将留待UNIX进阶手册中再行讨论.</p>
<h3 id="如何取得awk"><a href="#如何取得awk" class="headerlink" title="如何取得awk"></a>如何取得awk</h3><p>一般的UNIX操作系统, 本身即附有awk. 不同的UNIX操作系统所附的awk其版本亦不尽相同. 若读者所使用的系统上未附有awk,可透过 anonymous ftp 到下列地方取得:<br>phi.sinica.edu.tw:/pub/gnu<br>ftp.edu.tw:/UNIX/gnu<br>prep.ai.mit.edu:/pub/gnu</p>
<h3 id="awk如何工作"><a href="#awk如何工作" class="headerlink" title="awk如何工作"></a>awk如何工作</h3><p>为便于解释awk程序架构, 及有关术语(terminology), 先以一个员工薪资档(emp.dat ), 来加以介绍.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125 Jenny 100 210</div><div class="line">A341 Dan 110 215</div><div class="line">P158 Max 130 209</div><div class="line">P148 John 125 220</div><div class="line">A123 Linda 95 210</div></pre></td></tr></table></figure></p>
<p>文件中各字段依次为员工ID, 姓名, 薪资率, 及实际工时. ID中的第一码为部门识别码. “A”,”P” 分别表示”组装”及”包装”部门.<br>本小节着重于说明awk程序的主要架构及工作原理, 并对一些重要的名词辅以必要的解释. 由这部分内容, 读者可体会出awk语言的主要精神及awk与其它语程序言的差异处. 为便于说明, 以条列方式说明于后.</p>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p><strong>数据行</strong>: awk从数据文件上读取数据的基本单位.以上列文件emp.dat为例, awk读入的<br>第一笔数据行是 “A125 Jenny 100 210”<br>第二笔数据行是 “A341 Dan 110 215”<br>一般而言, 一个数据行就相当于数据文件上的一行资料. (参考 : 附录 B 内建变量”RS”)</p>
<p><strong>字段(Field)</strong>: 为数据行上被分隔开的子字符串.<br>以数据行”A125 Jenny 100 210”为例,<br>第一栏 第二栏 第三栏 第四栏 “A125” “Jenny” 100 210<br>一般是以空格符来分隔相邻的字段. (参考 : 附录 D 内建变量”FS”)</p>
<h2 id="如何执行awk"><a href="#如何执行awk" class="headerlink" title="如何执行awk"></a>如何执行awk</h2><p>于UNIX的命令行上键入诸如下列格式的指令: ( “<code>$</code>“ 表Shell命令行上的提示符号)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>则awk会先编译该程序, 然后执行该程序来处理所指定的数据文件.<br>(上列方式系直接把程序写在UNIX的命令行上)</p>
<h3 id="awk-程序的主要结构"><a href="#awk-程序的主要结构" class="headerlink" title="awk 程序的主要结构:"></a>awk 程序的主要结构:</h3><p>awk程序中主要语法是<code>Pattern { Actions }</code>, 故常见之awk程序其型态如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pattern1 &#123; Actions1 &#125;</div><div class="line">Pattern2 &#123; Actions2 &#125;</div><div class="line">......</div><div class="line">Pattern3 &#123; Actions3 &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Pattern-是什么"><a href="#Pattern-是什么" class="headerlink" title="Pattern 是什么 ?"></a>Pattern 是什么 ?</h3><p>awk可接受许多不同型态的Pattern. 一般常使用”关系表达式”(Relational expression)来当成Pattern.<br>例如:<br><code>x &gt; 34</code> 是一个Pattern, 判断变量 <code>x</code> 与 <code>34</code> 是否存在大于的关系.<br><code>x == y</code> 是一个Pattern, 判断变量 <code>x</code> 与变量 <code>y</code> 是否存在等于的关系.<br>上式中<code>x &gt;34</code>,<code>x == y</code>便是典型的Pattern.</p>
<p>awk 提供 C 语言中常见的关系运算符(Relational Operators) 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &lt;, &gt;=, &lt;=, ==, !=</div></pre></td></tr></table></figure></p>
<p>此外, awk 还提供 <code>~</code> (match) 及 <code>!~</code> (not match) 二个关系运算符(注一).<br>其用法与涵义如下:<br>若 A 为一字符串, B 为一正则表达式(Regular Expression)<br><code>A ~ B</code> 判断字符串 A 中是否 <em>包含</em> 能匹配(match) B 表达式的子字符串.<br><code>A !~ B</code> 判断字符串 A 中是否 <em>不包含</em> 能匹配(match) B 表达式的子字符串.<br>例如 :<br><code>&quot;banana&quot; ~ /an/</code> 整个是一个Pattern.<br>因为”<code>banana</code>“中含有可以匹配 <code>/an/</code> 的子字符串, 故此关系式成立(true),整个Pattern的值也是true.</p>
<p>相关细节请参考 附录 A Patterns, 附录 E Regular Expression</p>
<p>(注一:) 有少数awk论著, 把 <code>~,</code> <code>!~</code> 当成另一类的 Operator, 并不视为一种 Relational Operator. 本手册中将这两个运算符当成一种 Relational Operator.</p>
<h3 id="Actions-是什么"><a href="#Actions-是什么" class="headerlink" title="Actions 是什么?"></a>Actions 是什么?</h3><p>Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.<br>例如:<br>awk的I/O指令: <code>print, printf( ), getline...</code><br>awk的流程控制指令: <code>if(...){..} else{..}, while(...){...}...</code></p>
<p>(请参考 附录 B — “Actions” )</p>
<h3 id="awk-如何处理-Pattern-Actions"><a href="#awk-如何处理-Pattern-Actions" class="headerlink" title="awk 如何处理 Pattern { Actions } ?"></a>awk 如何处理 Pattern { Actions } ?</h3><p>awk 会先判断(Evaluate) 该 Pattern 的值, 若 Pattern 判断后的值为 true (或不为0的数字,或不是空的字符串), 则 awk 将执行该 Pattern 所对应的 Actions. 反之, 若 Pattern 之值不为 true, 则awk将不执行该 Pattern 所对应的 Actions.</p>
<p>例如 : 若awk程序中有下列两指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">50 &gt; 23 &#123;<span class="built_in">print</span> <span class="string">"Hello! The word!!"</span> &#125;</div><div class="line"><span class="string">"banana"</span> ~ /123/ &#123; <span class="built_in">print</span> <span class="string">"Good morning !"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>awk会先判断<code>50 &gt;23</code>是否成立. 因为该式成立, 所以awk将印出”<code>Hello! The word!!</code>“. 而另一 Pattern 为<code>&quot;banana&quot; ~/123/</code>, 因为<code>&quot;banana&quot;</code>内未含有任何子字符串可<code>match /123/</code>, 该 Pattern 之值为false, 故awk将不会印出 “<code>Good morning !</code>“</p>
<h3 id="awk-如何处理-Actions-的语法-缺少Pattern部分"><a href="#awk-如何处理-Actions-的语法-缺少Pattern部分" class="headerlink" title="awk 如何处理{ Actions } 的语法? (缺少Pattern部分)"></a>awk 如何处理{ Actions } 的语法? (缺少Pattern部分)</h3><p>有时语法<code>Pattern { Actions }</code>中, <code>Pattern</code> 部分被省略, 只剩 <code>{Actions}</code>. 这种情形表示 “无条件执行这个Actions”.</p>
<h3 id="awk-的字段变量"><a href="#awk-的字段变量" class="headerlink" title="awk 的字段变量"></a>awk 的字段变量</h3><p>awk 所内建的字段变量及其涵意如下 :</p>
<table>
<thead>
<tr>
<th>字段变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>一字符串, 其内容为目前 awk 所读入的数据行.</td>
</tr>
<tr>
<td><code>$1</code></td>
<td><code>$0</code> 上第一个字段的数据.</td>
</tr>
<tr>
<td><code>$2</code></td>
<td><code>$0</code> 上第二个字段的数据.</td>
</tr>
<tr>
<td>…</td>
<td>其余类推</td>
</tr>
</tbody>
</table>
<h3 id="读入数据行时-awk如何更新-update-这些内建的字段变量"><a href="#读入数据行时-awk如何更新-update-这些内建的字段变量" class="headerlink" title="读入数据行时, awk如何更新(update)这些内建的字段变量?"></a>读入数据行时, awk如何更新(update)这些内建的字段变量?</h3><p>当 awk 从数据文件中读取一个数据行时, awk 会使用内建变量<code>$0</code>予以记录.每当<code>$0</code>被改动时 (例如 : 读入新的数据行或自行变更<code>$0</code>, …) awk 会立刻重新分析 <code>$0</code> 的字段情况, 并将 <code>$0</code> 上各字段的数据用 <code>$1</code>, <code>$2</code>, … 予以记录.</p>
<h3 id="awk的内建变量-Built-in-Variables"><a href="#awk的内建变量-Built-in-Variables" class="headerlink" title="awk的内建变量(Built-in Variables)"></a>awk的内建变量(Built-in Variables)</h3><p>awk 提供了许多内建变量, 使用者于程序中可使用这些变量来取得相关信息. 常见的内建变量有:</p>
<table>
<thead>
<tr>
<th>内建变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NF (Number of Fields)</td>
<td>为一整数, 其值表<code>$0</code>上所存在的字段数目.</td>
</tr>
<tr>
<td>NR (Number of Records)</td>
<td>为一整数, 其值表awk已读入的数据行数目.</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk 正在处理的数据文件文件名.</td>
</tr>
</tbody>
</table>
<p>例如: awk 从资料文件 emp.dat 中读入第一笔数据行<br>“<code>A125 Jenny 100 210</code>“ 之后, 程序中:<br><code>$0</code> 之值将是 “A125 Jenny 100 210”<br><code>$1</code> 之值为 “A125”<br><code>$2</code> 之值为 “Jenny”<br><code>$3</code> 之值为 100<br><code>$4</code> 之值为 210<br><code>$NF</code> 之值为 4<br><code>$NR</code> 之值为 1<br><code>$FILENAME</code> 之值为 “emp.dat”</p>
<h3 id="awk的工作流程"><a href="#awk的工作流程" class="headerlink" title="awk的工作流程"></a>awk的工作流程</h3><p>执行awk时, 它会反复进行下列四步骤.</p>
<ul>
<li>自动从指定的数据文件中读取一个数据行.</li>
<li>自动更新(Update)相关的内建变量之值. 如:<code>NF</code>,<code>NR</code>, <code>$0</code> …</li>
<li>依次执行程序中所有的<code>Pattern { Actions }</code>指令.</li>
<li>当执行完程序中所有<code>Pattern { Actions }</code>时, 若数据文件中还有未读取的数据, 则反复执行步骤1到步骤4.</li>
</ul>
<p>awk会自动重复进行上述4个步骤, 使用者不须于程序中编写这个循环 (Loop).</p>
<h3 id="打印文件中指定的字段数据并加以计算"><a href="#打印文件中指定的字段数据并加以计算" class="headerlink" title="打印文件中指定的字段数据并加以计算"></a>打印文件中指定的字段数据并加以计算</h3><p>awk 处理数据时, 它会自动从数据文件中一次读取一笔记录, 并会将该数据切分成一个个的字段; 程序中可使用<code>$1</code>, <code>$2</code>, … 直接取得各个字段的内容. 这个特色让使用者易于用 awk 编写 reformatter 来改变量据格式.</p>
<p>范例: 以文件 emp.dat 为例, 计算每人应发工资并打印报表.<br>分析: awk 会自行一次读入一列数据, 故程序中仅需告诉 awk 如何处理所读入的数据行.<br>执行如下命令: (<code>$</code>表UNIX命令行上的提示符)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下:<br>屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny 21000</div><div class="line">Dan 23650</div><div class="line">Max 27170</div><div class="line">John 27500</div><div class="line">Linda 19950</div></pre></td></tr></table></figure></p>
<p>说明:<br>UNIX命令行上, 执行awk的语法为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 欲处理的资料文件文件名</div></pre></td></tr></table></figure></p>
<p>本范例中的程序部分为<code>{print $2, $3 * $4}</code>. 把程序置于命令行时, 程序之前后须以<code>&#39;</code>括住. <code>emp.dat</code>为指定给该程序处理的数据文件文件名.</p>
<p>本程序中使用:<code>Pattern { Actions }</code>语法.<br>Pattern 部分被省略, 表无任何限制条件. 故 awk 读入每笔数据行后都将无条件执行这个 Actions.<br><code>print</code>为awk所提供的输出指令, 会将数据输出到stdout(屏幕).<br><code>print</code>的参数间彼此以”<code>,</code>“ (逗号) 隔开, 印出数据时彼此间会以空白隔开. (参考 附录 D 内建变量OFS)</p>
<p>将上述的程序部分储存于文件 <code>pay1.awk</code> 中. 执行命令时再指定awk程序文件之文件名. 这是执行awk的另一种方式, 特别适用于程序较大的情况, 其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>故执行下列两命令,将产生同样的结果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay1.awk emp.dat</div><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>读者可使用”<code>-f</code>“参数, 让awk主程序使用“其它仅含 awk 函数的文件中的函数”<br>其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk主程序文件名 <span class="_">-f</span> awk函数文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>(有关 awk 中函数的声明与使用于 7.4 中说明)</p>
<p>awk中也提供与 C 语言中类似用法的 <code>printf()</code> 函数. 使用该函数可进一步控制数据的输出格式.</p>
<p>编辑另一个awk程序如下, 并取名为 <code>pay2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%6s Work hours: %3d Pay: %5d\n"</span>, <span class="variable">$2</span>,<span class="variable">$3</span>, <span class="variable">$3</span>* <span class="variable">$4</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay2.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny Work hours: 100 Pay: 21000</div><div class="line">   Dan Work hours: 110 Pay: 23650</div><div class="line">   Max Work hours: 130 Pay: 27170</div><div class="line">  John Work hours: 125 Pay: 27500</div><div class="line"> Linda Work hours:  95 Pay: 19950</div></pre></td></tr></table></figure></p>
<h2 id="选择符合指定条件的记录"><a href="#选择符合指定条件的记录" class="headerlink" title="选择符合指定条件的记录"></a>选择符合指定条件的记录</h2><p><code>Pattern { Action }</code>为awk中最主要的语法. 若某Pattern之值为真则执行它后方的 Action. awk中常使用 “关系表达式”(Relational Expression) 来当成 Pattern.</p>
<p>awk 中除了<code>&gt;, &lt;, ==, !=</code>, … 等关系运算符( Relational Operators )外, 另外提供<code>~</code>(match),<code>!~</code>(Not Match)二个关系运算符. 利用这两个运算符, 可判断某字符串是否包含能匹配所指定正则表达式的子字符串. 由于这些特性, 很容易使用awk来编写需要字符串比对, 判断的程序.</p>
<p>范例: 承上例,<br>组装部门员工调薪5%,(组装部门员工之ID以”A”开头)<br>所有员工最后之薪资率若仍低于100, 则以100计.<br>编写awk程序打印新的员工薪资率报表.</p>
<p>分析: 这个程序须先判断所读入的数据行是否合于指定条件, 再进行某些动作. awk 中<code>Pattern { Actions }</code>的语法已涵盖这种”<code>if ( 条件) { 动作}</code>“的架构. 编写如下之程序, 并取名<code>adjust1.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125; <span class="variable">$3</span>&lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> adjust1.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>结果如下 : 屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125    Jenny 105</div><div class="line">A341      Dan 115</div><div class="line">P158      Max 130</div><div class="line">P148     John 125</div><div class="line">A123    Linda 100</div></pre></td></tr></table></figure></p>
<p>说明:<br>awk的工作程序是: 从数据文件中每次读入一个数据行, 依序执行完程序中所有的<code>Pattern{ Action }</code>指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span>~/^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div><div class="line"><span class="variable">$3</span> &lt; 100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>再从数据文件中读进下一笔记录继续进行处理.<br>第一个<code>Pattern { Action }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div></pre></td></tr></table></figure></p>
<p><code>$1 ~ /^A.*/</code> 是一个Pattern, 用来判断该笔数据行的第一栏是否包含以”A”开头的子字符串. 其中 <code>/^A.*/</code> 是一个Regular Expression, 用以表示任何以”A”开头的字符串. (有关 Regular Expression 之用法 参考 附录 E).<br>Actions 部分为 <code>$3 *= 1.05</code><br><code>$3 *= 1.05</code>与<code>$3 = $3 * 1.05</code> 意义相同. 运算子”<code>*=</code>“之用法则与 C 语言中一样. 此后与 C 语言中用法相同的运算子或语法将不予赘述.</p>
<p>第二个 <code>Pattern { Actions }</code> 是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$3</span> &lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div></pre></td></tr></table></figure></p>
<p>若第三栏的数据内容(表薪资率)小于100, 则调整为100.</p>
<p>第三个<code>Pattern { Actions }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span> )&#125;</div></pre></td></tr></table></figure></p>
<p>省略了Pattern(无条件执行Actions), 故所有数据行调整后的数据都将被印出.</p>
<h2 id="awk-中数组"><a href="#awk-中数组" class="headerlink" title="awk 中数组"></a>awk 中数组</h2><p>awk程序中允许使用字符串当做数组的下标(index). 利用这个特色十分有助于资料统计工作.(使用字符串当下标的数组称为Associative Array)</p>
<p>首先建立一个数据文件, 并取名为 <code>reg.dat</code>. 此为一学生注册的资料文件; 第一栏为学生姓名, 其后为该生所修课程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mary O.S. Arch. Discrete</div><div class="line">Steve D.S. Algorithm Arch.</div><div class="line">Wang Discrete Graphics O.S.</div><div class="line">Lisa Graphics A.I.</div><div class="line">Lily Discrete Algorithm</div></pre></td></tr></table></figure></p>
<h3 id="awk中数组的特性"><a href="#awk中数组的特性" class="headerlink" title="awk中数组的特性"></a>awk中数组的特性</h3><p>使用字符串当数组的下标(index)，使用数组前不须宣告数组名及其大小.</p>
<p>例如: 希望用数组来记录 <code>reg.dat</code> 中各门课程的修课人数. 这情况,有二项信息必须储存:<br>(a) 课程名称, 如: “O.S.”, “Arch.” … ,共有哪些课程事先并不明确.<br>(b)各课程的修课人数. 如: 有几个人修”O.S.”<br>在awk中只要用一个数组就可同时记录上列信息. 其方法如下:</p>
<h4 id="使用一个数组Number"><a href="#使用一个数组Number" class="headerlink" title="使用一个数组Number[]"></a>使用一个数组Number[]</h4><p>以课程名称当<code>Number[]</code>的下标，以<code>Number[]</code>中不同下标所对映的元素代表修课人数.<br>例如:<br>有2个学生修”O.S.”, 则以<code>Number[&quot;O.S.&quot;] = 2</code>表之.<br>若修”O.S.”的人数增加一人, 则<code>Number[&quot;O.S.&quot;] = Number[&quot;O.S.&quot;] + 1</code> 或 <code>Number[&quot;O.S.&quot;]++</code> .</p>
<h4 id="如何取出数组中储存的信息"><a href="#如何取出数组中储存的信息" class="headerlink" title="如何取出数组中储存的信息"></a>如何取出数组中储存的信息</h4><p>以 C 语言为例, 声明 <code>int Arr[100];</code> 之后, 若想得知 <code>Arr[]</code> 中所储存的数据, 只须用一个循环, 如 :<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Arr[i]);</div></pre></td></tr></table></figure></p>
<p>即可. 上式中:<br>数组 <code>Arr[]</code> 的下标: <code>0, 1, 2,..., 99</code><br>数组 <code>Arr[]</code> 中各下标所对应的值: <code>Arr[0], Arr[1],...Arr[99]</code><br>但 awk 中使用数组并不须事先宣告. 以刚才使用的 <code>Number[]</code> 而言, 程序执行前, 并不知将来有哪些课程名称可能被当成 <code>Number[]</code> 的下标.</p>
<p>awk 提供了一个指令, 藉由该指令awk会自动找寻数组中使用过的所有下标. 以 <code>Number[]</code> 为例, awk将会找到”O.S.”, “Arch.”, …<br>使用该指令时, 须指定所要找寻的数组, 及一个变量. awk会使用该的变量来记录从数组中找到的每一个下标. 例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(course <span class="keyword">in</span> Number)&#123;....&#125;</div></pre></td></tr></table></figure></p>
<p>指定用 <code>course</code> 来记录 awk 从<code>Number[]</code> 中所找到的下标. awk每找到一个下标时, 就用<code>course</code>记录该下标之值且执行<code>{....}</code>中之指令. 藉由这个方式便可取出数组中储存的信息. (详见下例)<br>范例: 统计各科修课人数,并印出结果.<br>建立如下程序,并取名为<code>course.awk</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> course.awk reg.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Graphics 2</div><div class="line">      O.S. 2</div><div class="line">  Discrete 3</div><div class="line">      A.I. 1</div><div class="line">      D.S. 1</div><div class="line">     Arch. 2</div><div class="line"> Algorithm 2</div></pre></td></tr></table></figure></p>
<p>说明:<br>这程序包含二个<code>Pattern { Actions }</code>指令.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>第一个<code>Pattern { Actions }</code>指令中省略了Pattern 部分. 故随着每笔数据行的读入其<code>Actions</code>部分将逐次无条件被执行.<br>以awk读入第一笔资料”Mary O.S. Arch. Discrete”为例, 因为该笔数据<code>NF = 4</code>(有4个字段), 故该 Action 的<code>for Loop</code>中<code>i = 2,3,4</code>.<br><code>i $i</code> 最初 <code>Number[$i] Number[$i]++</code> 之后<br><code>i=2</code>时 <code>$i=&quot;O.S.&quot; Number[&quot;O.S.&quot;]</code> 的值从默认的0,变成了1;<br><code>i=3</code>时 <code>$i=&quot;Arch.&quot; Number[&quot;Arch.&quot;]</code> 的值从默认的0,变成了1;<br>同理,<code>i=4</code>时 <code>$i=&quot;Discrete&quot; Number[&quot;Discrete&quot;]</code> 的值从默认的0,变成了1;</p>
<p>第二个<code>Pattern { Actions }</code>指令中 <code>END</code> 为awk之保留字, 为 Pattern 的一种.<br><code>END</code> 成立(其值为true)的条件是: “awk处理完所有数据, 即将离开程序时.”<br>平常读入数据行时,<code>END</code>并不成立, 故其后的Actions并不被执行;<br>唯有当awk读完所有数据时, 该Actions才会被执行(注意, 不管数据行有多少笔,<code>END</code>仅在最后才成立, 故该Actions仅被执行一次.)</p>
<p><code>BEGIN</code> 与 <code>END</code> 有点类似, 是awk中另一个保留的Pattern.<br>唯一不同的是: “以<code>BEGIN</code>为<code>Pattern</code>的<code>Actions</code>于程序一开始执行时, 被执行一次.”</p>
<p><code>NF</code>为awk的内建变量, 用以表示awk正处理的数据行中, 所包含的字段个数.</p>
<p>awk程序中若含有以<code>$</code>开头的自定变量, 都将以如下方式解释:<br>以<code>i= 2</code>为例, <code>$i = $2</code> 表第二个字段数据. (实际上,<code>$</code> 在 awk 中为一运算符(Operator), 用以取得字段数据.)</p>
<h2 id="awk-程序中使用-Shell-命令"><a href="#awk-程序中使用-Shell-命令" class="headerlink" title="awk 程序中使用 Shell 命令"></a>awk 程序中使用 Shell 命令</h2><p>awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.</p>
<p>范例: 写一个awk程序来打印出线上人数.<br>将下列程序建文件, 命名为 <code>count.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    <span class="keyword">while</span> ( <span class="string">"who"</span> | getline ) n++</div><div class="line">    <span class="built_in">print</span> n</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> count.awk</div></pre></td></tr></table></figure></p>
<p>执行结果将会印出目前在线人数</p>
<p>说明:<br>awk 程序并不一定要处理数据文件. 以本例而言, 仅输入程序文件<code>count.awk</code>, 未输入任何数据文件.</p>
<p><code>BEGIN</code> 和 <code>END</code> 同为awk中的一种 Pattern. 以 <code>BEGIN</code>为 Pattern 的 Actions, 只有在awk开始执行程序,尚未开启任何输入文件前, 被执行一次.(注意: 只被执行一次)</p>
<p><code>|</code> 为 awk 中表示管道的符号. awk 把<code>|</code>之前的字符串<code>&quot;who&quot;</code>当成Shell上的命令, 并将该命令送往Shell执行, 执行的结果(原先应于屏幕印出者)则藉由pipe送进awk程序中.</p>
<p><code>getline</code>为awk所提供的输入指令. 其语法如下:</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的file</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td><code>pipe</code> 变量</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p>注一: 当 Pattern 为 <code>BEGIN</code> 或 <code>END</code>时, <code>getline</code> 将从<code>stdin</code> 读取数据, 否则从awk正处理的数据文件上读取数据.</p>
<p><code>getline</code> 一次读取一行数据, 若读取成功则<code>return 1</code>, 若读取失败则<code>return -1</code>, 若遇到文件结束(<code>EOF</code>), 则<code>return 0</code>;</p>
<p>本程序使用 <code>getline</code> 所 <code>return</code> 的数据来做为 <code>while</code> 判断循环停止的条件, 某些awk版本较旧,并不容许使用者改变 <code>$0</code> 之值. 这种版的 awk 执行本程序时会产生<code>Error</code>, 读者可于 <code>getline</code> 之后置上一个变量 (如此, <code>getline</code> 读进来的数据便不会被置于 <code>$0</code> ), 或直接改用gawk便可解决.</p>
<h2 id="awk-程序的应用实例"><a href="#awk-程序的应用实例" class="headerlink" title="awk 程序的应用实例"></a>awk 程序的应用实例</h2><p>本节将示范一个统计上班到达时间及迟到次数的程序.</p>
<p>这程序每日被执行时将读入二个文件:</p>
<ol>
<li>员工当日到班时间的数据文件 (如下列之<code>arr.dat</code>)</li>
<li>存放员工当月迟到累计次数的文件.</li>
</ol>
<p>当程序执行执完毕后将更新第二个文件的数据(迟到次数), 并打印当日的报表.这程序将分成下列数小节逐步完成, 其大纲如下:</p>
<p>[1] 在到班资料文件 arr.dat 之前增加一行抬头<br>“<code>ID Number Arrvial Time</code>“, 并产生报表输出到文件<code>today_rpt1</code>中.</p>
<p><strong>思考: 在awk中如何将数据输出到文件</strong></p>
<p>[2] 将 <code>today_rpt1</code> 上的数据按员工代号排序, 并加注执行当日日期; 产生文件 <code>today_rpt2</code></p>
<p><strong>思考 awk中如何运用系统资源及awk中Pipe之特性</strong></p>
<p>[3] 将awk程序包含在一个shell script文件中</p>
<p>[4] 于 <code>today_rpt2</code> 每日报表上, 迟到者之前加上”*”, 并加注当日平均到班时间;产生文件 <code>today_rpt3</code></p>
<p>[5] 从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.</p>
<p><strong>思考 使用者在awk中如何读取文件数据</strong></p>
<p>某公司其员工到勤时间档如下, 取名为 <code>arr.dat</code>. 文件中第一栏为员工代号, 第二栏为到达时间. 本范例中, 将使用该文件为数据文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<h3 id="重定向输出到文件"><a href="#重定向输出到文件" class="headerlink" title="重定向输出到文件"></a>重定向输出到文件</h3><p>awk中并未提供如 C 语言中之 <code>fopen()</code> 指令, 也未有 <code>fprintf()</code> 文件输出这样的指令. 但awk中任何输出函数之后皆可借助使用与UNIX中类似的 I/O 重定向符, 将输出的数据重定向到指定的文件; 其符号仍为 <code>&gt;</code> (输出到一个新产生的文件) 或 <code>&gt;&gt;</code> (添加输出的数据到文件末尾).</p>
<p>[例:] 在到班数据文件 <code>arr.dat</code> 之前增加一行抬头如下:<br><code>&quot;ID Number Arrival Time&quot;</code>, 并产生报表输出到文件 <code>today_rpt1</code> 中</p>
<p>建立如下文件并取名为reformat1.awk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"==========================="</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">&#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">" %s %s\n"</span>, <span class="variable">$1</span>,<span class="variable">$2</span> ) &gt; <span class="string">"today_rpt1"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> reformat1.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后将产生文件 today_rpt1, 其内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ID Number Arrival Time</div><div class="line">============================</div><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序中, 文件名称 <code>today_rpt1</code> 的前后须以<code>&quot;</code>(双引号)括住, 表示 <code>today_rpt1</code> 为一字符串常量. 若未以<code>&quot;</code>括住, 则 <code>today_rpt1</code> 将被awk解释为一个变量名称.</p>
<p>在awk中任何变量使用之前, 并不须事先声明. 其初始值为空字符串(Null string) 或 0.因此程序中若未以<code>&quot;</code>将 <code>today_rpt1</code> 括住, 则 <code>today_rpt1</code> 将是一变量, 其值将是空字符串, 这会在执行时造成错误(Unix 无法帮您开启一个以空字符串为文件名的文件).</p>
<p>因此在编辑awk程序时, 须格外留心. 因为若敲错变量名称, awk在编译程序时会认为是一新的变量, 并不会察觉. 因此往往会造成运行时错误.</p>
<p><code>BEGIN</code> 为awk的保留字, 是 Pattern 的一种.<br>以 <code>BEGIN</code> 为 Pattern 的 Actions 于awk程序刚被执行尚未读取数据文件时被执行一次, 此后便不再被执行.</p>
<p>读者或许觉得本程序中的I/O重定向符号应使用”<code>&gt;&gt;</code>“(append)而非”<code>&gt;</code>“.</p>
<p>本程序中若使用”<code>&gt;</code>“ 将数据重导到<code>today_rpt1</code>, awk 第一次执行该指令时会产生一个新档<code>today_rpt1</code>, 其后再执行该指令时则把数据追加到<code>today_rpt1</code>文件末, 并非每执行一次就重开一个新文件.</p>
<p>若采用”<code>&gt;&gt;</code>“其差异仅在第一次执行该指令时, 若已存在<code>today_rpt1</code>则 awk 将直接把数据append在原文件之末尾. 这一点, 与UNIX中的用法不同.</p>
<h3 id="awk-中如何利用系统资源"><a href="#awk-中如何利用系统资源" class="headerlink" title="awk 中如何利用系统资源"></a>awk 中如何利用系统资源</h3><p>awk程序中很容易使用系统资源. 这包括在程序中途调用 Shell 命令来处理程序中的部分数据; 或在调用 Shell 命令后将其产生的结果交回 awk 程序(不需将结果暂存于某个文件). 这一过程是借助 awk 所提供的管道 (虽然有些类似 Unix 中的管道, 但特性有些不同),及一个从 awk 中呼叫 Unix 的 Shell 命令的语法来达成的.</p>
<p>[例:] 承上题, 将数据按员工ID排序后再输出到文件 today_rpt2 , 并于表头附加执行时的日期.</p>
<p>[分析:]<br>awk 提供与 UNIX 用法近似的 pipe, 其记号亦为”<code>|</code>“. 其用法及含意如下:<br>awk程序中可接受下列两种语法:<br>[a.语法] awk output 指令 | “Shell 接受的命令”<br>(如: <code>print $1,$2 | &quot;sort -k 1&quot;</code>)<br>[b.语法] “Shell 接受的命令” | awk input 指令<br>(如: <code>&quot;ls&quot; | getline</code>)<br>注: awk input 指令只有 <code>getline</code> 一个.<br>awk output 指令有<code>print</code>, <code>printf()</code> 二个.</p>
<p>在 a 语法中, awk所输出的数据将转送往 Shell , 由 Shell 的命令进行处理.以上例而言, <code>print</code> 所输出的数据将经由 Shell 命令<code>&quot;sort -k 1&quot;</code>排序后再送往屏幕(stdout).</p>
<p>上列awk程序中, “<code>print$1, $2</code>“ 可能反复执行很多次, 其输出的结果将先暂存于 pipe 中,等到该程序结束时, 才会一并进行<code>&quot;sort -k 1&quot;</code>.</p>
<p>须注意二点: 不论<code>print $1, $2</code>被执行几次,<code>&quot;sort -k 1&quot;</code>的执行时间是”awk程序结束时”,<code>&quot;sort -k 1&quot;</code>的执行次数是”一次”.</p>
<p>在 b 语法中, awk将先调用 Shell 命令. 其执行结果将通过 pipe 送入awk程序,以上例而言, awk 先让 Shell 执行 <code>&quot;ls&quot;</code>, Shell 执行后将结果存于 pipe, awk指令<code>getline</code>再从 pipe 中读取数据.</p>
<p>使用本语法时应留心: 以上例而言,awk “立刻”调用 Shell 来执行<code>&quot;ls&quot;</code>, 执行次数是一次.</p>
<p><code>getline</code> 则可能执行多次 (若pipe中存在多行数据).</p>
<p>除上列 a, b 二中语法外, awk程序中其它地方如出现像<code>&quot;date&quot;</code>, <code>&quot;cls&quot;</code>, <code>&quot;ls&quot;</code>… 这样的字符串, awk只把它当成一般字符串处理.</p>
<p>建立如下文件并取名为 <code>reformat2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 程序 reformat2.awk</span></div><div class="line"><span class="comment"># 这程序用以练习awk中的pipe</span></div><div class="line">BEGIN &#123;</div><div class="line">    <span class="string">"date"</span> | getline <span class="comment"># Shell 执行 "date". getline 取得结果并以$0记录</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" Today is "</span> , <span class="variable">$2</span>, <span class="variable">$3</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"========================="</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    close( <span class="string">"today_rpt2"</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;<span class="built_in">printf</span>( <span class="string">"%s %s\n"</span>, <span class="variable">$1</span> ,<span class="variable">$2</span> ) | <span class="string">"sort -k 1 &gt;&gt;today_rpt2"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> reformat2.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后, 系统会自动将 sort 后的数据追加(Append; 因为使用 “<code>&gt;&gt;</code>“) 到文件<code>today_rpt2</code>末端. <code>today_rpt2</code> 内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005 8:12</div><div class="line">1006 7:45</div><div class="line">1008 8:01</div><div class="line">1012 7:46</div><div class="line">1025 7:27</div><div class="line">1028 7:49</div><div class="line">1029 7:57</div><div class="line">1034 7:26</div><div class="line">1042 7:59</div><div class="line">1051 7:51</div><div class="line">1052 8:05</div><div class="line">1101 7:32</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序由三个主要部分构成:<br>[i.] <code>Pattern { Action}</code>指令<br>[ii.] 函数主体. 例如:<code>function double( x ){ return 2*x }</code> (参考第11节 Recursive Program )<br>[iii.] Comment (以<code>#</code>开头识别之)</p>
<p>awk 的输入指令<code>getline</code>, 每次读取一列数据. 若<code>getline</code>之后未接任何变量, 则所读入之资料将以<code>$0</code>记录, 否则以所指定的变量储存之.</p>
<p>[以本例而言]:<br>执行 <code>&quot;date&quot; | getline</code> 后, <code>$0</code> 之值为 “2007年 09月 21日 星期五 14:28:02 CST”,当 <code>$0</code> 之值被更新时, awk将自动更新相关的内建变量, 如: <code>$1</code>,<code>$2</code>,..,<code>NF</code>.故 <code>$2</code> 之值将为”09月”, <code>$3</code>之值将为”21日”.</p>
<p>(有少数旧版的awk不允许即使用者自行更新(update)<code>$0</code>的值,或者更新<code>$0</code>时,它不会自动更新 <code>$1</code>,<code>$2</code>,..<code>NF</code>. 这情况下, 可改用<code>gawk</code>或<code>nawk</code>. 否则使用者也可自行以awk字符串函数<code>split()</code>来分隔<code>$0</code>上的数据)</p>
<p>本程序中 <code>printf()</code> 指令会被执行12次( 因为有<code>arr.dat</code>中有12行数据), 但读者不用担心数据被重复<code>sort</code>了12次. 当awk结束该程序时才会 <code>close</code> 这个 pipe , 此时才将这12行数据一次送往系统,并呼叫<code>&quot;sort -k 1 &gt;&gt; today_rpt2&quot;</code>处理之.</p>
<p>awk提供另一个调用Shell命令的方法, 即使用awk函数<code>system(&quot;shell command&quot;)</code><br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;</div><div class="line">BEGIN&#123;</div><div class="line">system(&quot;date &gt; date.dat&quot;)</div><div class="line">getline &lt; &quot;date.dat&quot;</div><div class="line">print &quot;Today is &quot;, $2, $3</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>但使用<code>system(&quot;shell command&quot;)</code>时, awk无法直接将执行中的部分数据输出给Shell 命令. 且 Shell 命令执行的结果也无法直接输入到awk中.</p>
<h3 id="执行-awk-程序的几种方式"><a href="#执行-awk-程序的几种方式" class="headerlink" title="执行 awk 程序的几种方式"></a>执行 awk 程序的几种方式</h3><p>本小节中描述如何将awk程序直接写在 shell script 之中. 此后使用者执行 awk 程序时, 就不需要每次都键入”<code>awk -f program datafile</code>“.</p>
<p>script 中还可包含其它 Shell 命令, 如此更可增加执行过程的自动化.</p>
<p>建立一个简单的 awk程序 mydump.awk, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个程序执行时会把数据文件的内容 <code>print</code> 到屏幕上( 与cat功用类似 ).</p>
<p><code>print</code> 之后未接任何参数时, 表示 “<code>print $0</code>“.</p>
<p>若欲执行该awk程序, 来印出文件 <code>today_rpt1</code> 及 <code>today_rpt2</code> 的内容时, 必须于 UNIX 的命令行上执行下列命令:<br>方式一 <code>awk -f mydump.awk today_rpt1 today_rpt2</code><br>方式二 <code>awk &#39;{ print }&#39; today_rpt1 today_rpt2</code><br>第二种方式系将awk 程序直接写在 Shell 的命令行上, 这种方式仅适合较短的awk程序.<br>方式三 建立如下之 shell script, 并取名为<code>mydisplay</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line"><span class="comment"># 注意以下的 awk 与 ' 之间须有空白隔开</span></div><div class="line">awk <span class="string">'</span></div><div class="line">&#123;print&#125;</div><div class="line">' $*</div><div class="line"><span class="comment"># 注意以上的 ' 与 $* 之间须有空白隔开</span></div></pre></td></tr></table></figure></p>
<p>执行 <code>mydisplay</code> 之前, 须先将它改成可执行的文件(此步骤往后不再赘述). 请执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x mydisplay</div></pre></td></tr></table></figure></p>
<p>往后使用者就可直接把 <code>mydisplay</code> 当成指令, 来display任何文件.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>在script文件 <code>mydisplay</code> 中, 指令”<code>awk</code>“与第一个<code>&#39;</code> 之间须有空格(Shell中并无” <code>awk&#39;</code> “指令).<br>第一个 <code>&#39;</code> 用以通知 Shell 其后为awk程序.<br>第二个<code>&#39;</code> 则表示 awk 程序结束.<br>故awk程序中一律以<code>&quot;</code>括住字符串或字符, 而不使用<code>&#39;</code>, 以免Shell混淆.<br><code>$*</code> 为 shell script中的用法, 它可用来代表命令行上”<code>mydisplay</code>之后的所有参数”.<br>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>事实上 Shell 已先把该指令转换成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; print&#125;</div><div class="line">' today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>本例中, <code>$*</code> 用以代表 <code>&quot;today_rpt1 today_rpt2&quot;</code>. 在Shell的语法中, 可用<code>$1</code> 代表第一个参数, <code>$2</code>代表第二个参数. 当不确定命令行上的参数个数时, 可使用 <code>$*</code> 表之.</p>
<p>awk命令行上可同时指定多个数据文件.<br>以<code>awk -f dump.awk today_rpt1 today_rpt2hf</code>为例, awk会先处理<code>today_rpt1</code>, 再处理 <code>today_rpt2</code>. 此时若文件无法打开, 将造成错误.<br>例如: 不存在文件”<code>file_no_exist</code>“, 则执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> dump.awk file_no_exit</div></pre></td></tr></table></figure></p>
<p>将产生运行时错误(无法打开文件).</p>
<p>但某些awk程序 “仅” 包含以 <code>BEGIN</code> 为Pattern的指令. 执行这种awk程序时, awk并不须开启任何数据文件.此时命令行上若指定一个不存在的数据文件,并不会产生 “无法打开文件”的错误.(事实上awk并未打开该文件)<br>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123;print "Hello,World!!"&#125; '</span> file_no_exist</div></pre></td></tr></table></figure></p>
<p>该程序中仅包含以 <code>BEGIN</code> 为 Pattern 的 <code>Pattern {actions}</code>, awk 执行时并不会开启任何数据文件; 所以不会因不存在文件<code>file_no_exit</code>而产生 “无法打开文件”的错误.</p>
<p>awk会将 Shell 命令行上awk程序(或 -f 程序文件名)之后的所有字符串, 视为将输入awk进行处理的数据文件文件名.</p>
<p>若执行awk的命令行上 “未指定任何数据文件文件名”, 则将<code>stdin</code>视为输入之数据来源, 直到输入<code>end of file( Ctrl-D )</code>为止.</p>
<p>读者可以用下列程序自行测试, 执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> mydump.awk  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>将会发现: 此后键入的任何数据将逐行复印一份于屏幕上. 这情况不是机器当机 ! 是因为awk程序正处于执行中. 它正按程序指示, 将读取数据并重新dump一次; 只因执行时未指定数据文件文件名, 故awk 便以stdin(键盘上的输入)为数据来源. 读者可利用这个特点, 设计可与awk即时聊天的程序.</p>
<h3 id="改变-awk-切割字段的方式-amp-自定义函数"><a href="#改变-awk-切割字段的方式-amp-自定义函数" class="headerlink" title="改变 awk 切割字段的方式 &amp; 自定义函数"></a>改变 awk 切割字段的方式 &amp; 自定义函数</h3><p>awk不仅能自动分割字段, 也允许使用者改变其字段切割方式以适应各种格式之需要. 使用者也可自定义函数, 若有需要可将该函数单独写成一个文件,以供其它awk程序调用.</p>
<p>[范例:] 承接 6.2 的例子, 若八点为上班时间, 请加注”<code>*</code>“于迟到记录之前, 并计算平均上班时间.<br>[分析:]<br>因八点整到达者,不为迟到, 故仅以到达的小时数做判断是不够的; 仍应参考到达时的分钟数. 若 “将到达时间转换成以分钟为单位”, 不仅易于判断是否迟到, 同时也易于计算到达平均时间.<br>到达时间(<code>$2</code>)的格式为<code>dd:dd</code>或<code>d:dd</code>; 数字当中含有一个”<code>:</code>“. 但文本数字交杂的数据awk无法直接做数学运算. (注: awk中字符串”<code>26</code>“与数字<code>26</code>, 并无差异, 可直接做字符串或数学运算, 这是awk重要特色之一. 但awk对文本数字交杂的字符串无法正确进行数学运算).</p>
<p>解决之方法:<br>[方法一]<br>对到达时间(<code>$2</code>)<code>d:dd</code>或<code>dd:dd</code>进行字符串运算,分别取出到达的小时数及分钟数.<br>首先判断到达小时数为一位或两位字符,再调用函数分别截取分钟数及小时数.<br>此解法需使用下列awk字符串函数:<br><code>length( 字符串 )</code>:返回该字符串的长度.<br><code>substr( 字符串,起始位置,长度)</code>:返回从起始位置起, 指定长度之子字符串. 若未指定长度, 则返回从起始位置到字符串末尾的子字符串.<br>所以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">小时数 = substr( $2, 1, length($2) - 3 )</div><div class="line">分钟数 = substr( $2, length($2) - 2 )</div></pre></td></tr></table></figure></p>
<p>[方法二]<br>改变输入列字段的切割方式, 使awk切割字段后分别将小时数及分钟数隔开于二个不同的字段.<br>字段分隔字符<code>FS</code> (field seperator) 是awk的内建变量,其默认值是<code>空白</code>及<code>tab</code>. awk每次切割字段时都会先参考<code>FS</code>的内容. 若把”<code>:</code>“也当成分隔字符, 则awk 便能自动把小时数及分钟数分隔成不同的字段.故令<code>FS = &quot;[ \t:]+&quot;</code> (注: <code>[ \t:]+</code> 为一Regular Expression )<br>Regular Expression 中使用中括号<code>[ ... ]</code>表示一个字符集合,用以表示任意一个位于两中括号间的字符.故可用”<code>[ \t:]</code>“表示 一个<code>空白</code>, <code>tab</code> 或 “<code>:</code>“。<br>Regular Expression中使用”<code>+</code>“形容其前方的字符可出现一次或一次以上.<br>故”<code>[ \t:]+</code>“表示由一个或多个 <code>空白</code>, <code>tab</code> 或 <code>:</code> 所组成的字符串.<br>设定<code>FS =&quot;[ \t:]+&quot;</code>后, 数据行如:<code>&quot;1034 7:26&quot;</code>将被分割成3个字段</p>
<p>第一栏 第二栏 第三栏<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></div><div class="line">1034 7 26</div></pre></td></tr></table></figure></p>
<p>明显地, awk程序中使用方法二比方法一更简洁方便. 本例子中采用方法二,也借此示范改变字段切割方式的用途.</p>
<p>编写awk程序<code>reformat3</code>, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS= "[ \t:]+" #改变字段切割的方式</div><div class="line">    "date" | getline # Shell 执行 "date". getline 取得结果以$0记录</div><div class="line">    print " Today is " ,$2, $3 &gt; "today_rpt3"</div><div class="line">    print "========================="&gt;"today_rpt3"</div><div class="line">    print " ID Number Arrival Time" &gt; "today_rpt3"</div><div class="line">    close( "today_rpt3" )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    #已更改字段切割方式, $2表到达小时数, $3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    printf(" %s %s:%s %s\n", $1, $2, $3, arrival &gt; 480 ? "*": " " ) | "sort -k 1 &gt;&gt; today_rpt3"</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close("today_rpt3")</div><div class="line">    close("sort -k 1 &gt;&gt; today_rpt3")</div><div class="line">    printf(" Average arrival time : %d:%d\n",total/NR/60, (total/NR)%60 ) &gt;&gt; "today_rpt3"</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>并执行如下指令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./reformat3 arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后,文件 today_rpt3 的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line"> 1005 8:12 *</div><div class="line"> 1006 7:45</div><div class="line"> 1008 8:01 *</div><div class="line"> 1012 7:46</div><div class="line"> 1025 7:27</div><div class="line"> 1028 7:49</div><div class="line"> 1029 7:57</div><div class="line"> 1034 7:26</div><div class="line"> 1042 7:59</div><div class="line"> 1051 7:51</div><div class="line"> 1052 8:05 *</div><div class="line"> 1101 7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk 中亦允许使用者自定函数. 函数定义方式请参考本程序, <code>function</code> 为 awk 的保留字.<br><code>HM_to_M()</code>这函数负责将所传入之小时及分钟数转换成以分钟为单位. 使用者自定函数时, 还有许多细节须留心, 如data scope,.. ( 请参考 第十节 Recursive Program)<br>awk中亦提供与 C 语言中相同的 Conditional Operator. 上式<code>printf()</code>中使用<code>arrival &gt;480 ? &quot;*&quot; : &quot; &quot;</code>即为一例若 <code>arrival</code> 大于 <code>480</code> 则<code>return &quot;*&quot;</code>, 否则<code>return &quot; &quot;</code>.<br><code>%</code>为awk的运算符(operator), 其作用与 C 语言中之<code>%</code>相同(取余数).<br><code>NR</code>(Number of Record) 为awk的内建变量. 表示awk执行该程序后所读入的记录笔数.</p>
<p>awk 中提供的<code>close()</code>指令, 语法如下(有二种) :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close( filename )</div><div class="line">close( 置于pipe之前的<span class="built_in">command</span> )</div></pre></td></tr></table></figure></p>
<p>为何本程序使用了两个<code>close()</code>指令:<br>指令 <code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>, 其意思为 close 程序中置于<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>之前的 Pipe, 并立刻调用 Shell 来执行<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>. (若未执行这指令, awk必须于结束该程序时才会进行上述动作; 则这12笔sort后的数据将被 append 到文件 <code>today_rpt3</code> 中 “<code>Average arrival time : ...</code>“ 的后方)<br>因为 Shell 排序后的数据也要写到 <code>today_rpt3</code>, 所以awk必须先关闭使用中的<code>today_rpt3</code> 以使 Shell 正确将排序后的数据追加到<code>today_rpt3</code>否则2个不同的 process 同时打开一个文件进行输出将会产生不可预期的结果.<br>读者应留心上述两点,才可正确控制数据输出到文件中的顺序.<br>指令<code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>中字符串<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code> 必须与 pipe <code>|</code> 后方的 Shell Command 名称一字不差, 否则awk将视为二个不同的 pipe.<br>读者可于<code>BEGIN{}</code>中先令变量 <code>Sys_call = &quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>,<br>程序中再一律以 <code>Sys_call</code> 代替该字符串.</p>
<h3 id="使用-getline-来读取数据"><a href="#使用-getline-来读取数据" class="headerlink" title="使用 getline 来读取数据"></a>使用 getline 来读取数据</h3><p>[范例:] 承上题,从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.(按不同的月份累计于不同的文件)<br>[分析:]<br>程序中自动抓取系统日期的月份名称, 连接上”<code>late.dat</code>“, 形成累计迟到次数的文件名称(如: 09月late.dat,…), 并以变量<code>late_file</code>记录该文件名.<br>累计迟到次数的文件中的数据格式为: 员工代号(ID) 迟到次数<br>例如, 执行本程序前文件 09月late.dat 的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1052 2</div><div class="line">1034 0</div><div class="line">1005 0</div><div class="line">1029 2</div><div class="line">1042 0</div><div class="line">1051 0</div><div class="line">1008 0</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1028 0</div></pre></td></tr></table></figure></p>
<p>编写程序 reformat4 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Sys_Sort = "sort -k 1 &gt;&gt; today_rpt4"</div><div class="line">    Result = "today_rpt4"</div><div class="line">    # 改变字段切割的方式</div><div class="line">    FS = "[ \t:]+"</div><div class="line">    # 令 Shell执行"date"; getline 读取结果,并以$0记录</div><div class="line">    "date" | getline</div><div class="line">    print " Today is " , $2, $3 &gt;Result</div><div class="line">    print "=========================" &gt; Result</div><div class="line">    print " ID Number Arrival Time" &gt; Result</div><div class="line">    close( Result )</div><div class="line">    # 从文件按中读取迟到数据, 并用数组cnt[ ]记录. 数组cnt[ ]中以</div><div class="line">    # 员工代号为下标, 所对应的值为该员工之迟到次数.</div><div class="line">    late_file = $2"late.dat"</div><div class="line">    while( getline &lt; late_file &gt;0 ) cnt[$1] = $2</div><div class="line">    close( late_file )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    # 已更改字段切割方式, $2表小时数,$3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    if( arrival &gt; 480 )&#123;</div><div class="line">    mark = "*" # 若当天迟到,应再增加其迟到次数, 且令mark 为"*".</div><div class="line">    cnt[$1]++ &#125;</div><div class="line">    else mark = " "</div><div class="line"></div><div class="line">    # message 用以显示该员工的迟到累计数, 若未曾迟到message为空字符串</div><div class="line">    message = cnt[$1] ? cnt[$1] " times" : ""</div><div class="line">    printf("%s %2d:%2d %5s %s\n", $1, $2, $3, mark, message ) | Sys_Sort</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close( Result )</div><div class="line">    close( Sys_Sort )</div><div class="line">    printf(" Average arrival time : %d:%d\n", total/NR/60, (total/NR)%60 ) &gt;&gt; Result</div><div class="line">    #将数组cnt[ ]中新的迟到数据写回文件中</div><div class="line">    for( any in cnt )</div><div class="line">    print any, cnt[any] &gt; late_file</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行后, today_rpt4 之内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005  8:12     * 1 times</div><div class="line">1006  7:45       1 times</div><div class="line">1008  8: 1     * 1 times</div><div class="line">1012  7:46</div><div class="line">1025  7:27       1 times</div><div class="line">1028  7:49</div><div class="line">1029  7:57       2 times</div><div class="line">1034  7:26</div><div class="line">1042  7:59</div><div class="line">1051  7:51</div><div class="line">1052  8: 5     * 3 times</div><div class="line">1101  7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>09月late.dat 文件被修改为如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1005 1</div><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1008 1</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1034 0</div><div class="line">1042 0</div><div class="line">1028 0</div><div class="line">1029 2</div><div class="line">1051 0</div><div class="line">1052 3</div></pre></td></tr></table></figure></p>
<p>说明:<br><code>late_file</code>是一变量, 用以记录迟到次数的文件的文件名.<br><code>late_file</code>之值由两部分构成, 前半部是当月月份名称(由调用”date”取得)后半部固定为”late.dat” 如: 09月late.dat.<br>指令<code>getline &lt; late_file</code>表示从<code>late_file</code>所代表的文件中读取一笔记录, 并存放于<code>$0</code>.<br>若使用者可自行把数据放入<code>$0</code>, awk会自动对这新置入 <code>$0</code> 的数据进行字段分割. 之后程序中可用<code>$1</code>, <code>$2</code>,..来表示该笔资料的第一栏,第二栏,..,<br>(注: 有少数awk版本不容许使用者自行将数据置于<code>$0</code>, 遇此情况可改用gawk或nawk)<br>执行<code>getline</code>指令时, 若成功读取记录,它会返回<code>1</code>. 若遇到文件结束, 它返回<code>0</code>; 无法打开文件则返回<code>-1</code>.<br>利用<code>while( getline &lt; filename &gt;0 ) {....}</code>可读入文件中的每一笔数据并予处理. 这是awk中用户自行读取数据文件的一个重要模式.<br>数组 <code>cnt[]</code> 以员工ID. 当下标(index), 其对应值表示其迟到的次数.<br>执行结束后, 利用<code>for(Variable in array ){...}</code>的语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> cnt ) <span class="built_in">print</span> any, cnt[any] &gt; late_file</div></pre></td></tr></table></figure></p>
<p>将更新过的迟到数据重新写回记录迟到次数的文件. 该语法在前面曾有说明.</p>
<h2 id="处理多行的数据"><a href="#处理多行的数据" class="headerlink" title="处理多行的数据"></a>处理多行的数据</h2><p>awk 每次从数据文件中只读取一数据进行处理.<br>awk是依照其内建变量 <code>RS</code> (Record Separator) 的定义将文件中的数据分隔成一行一行的Record. <code>RS</code> 的默认值是”<code>\n</code>“ (换行符号), 故平常awk中一行数据就是一笔 Record. 但有些文件中一笔Record涵盖了多行数据, 这种情况下不能再以”<code>\n</code>“来分隔Records. 最常使用的方法是相邻的Records之间改以一个<code>空白行</code>来隔开. 在awk程序中, 令<code>RS = &quot;&quot;</code>(空字符串)后, awk把会空白行当成来文件中Record的分隔符. 显然awk对<code>RS = &quot;&quot;</code>另有解释方式,简略描述如下, 当<code>RS = &quot;&quot;</code> 时:数个并邻的空白行, awk仅视成一个单一的Record Saparator. (awk不会于两个紧并的空白行之间读取一笔空的Record)<br>awk会略过(skip)文件头或文件尾的空白行. 故不会因为这样的空白行,造成awk多读入了二笔空的数据.</p>
<p>请观察下例,首先建立一个数据文件<code>week.rpt</code>如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">吴国强</div><div class="line">Latex 简介</div><div class="line">VAST-2 使用手册</div><div class="line">mathematic 入门</div><div class="line"></div><div class="line">李小华</div><div class="line">awk Tutorial Guide</div><div class="line">Regular Expression</div></pre></td></tr></table></figure></p>
<p>该文件的开头有数行空白行, 各笔Record之间使用一个或数个空白行隔开. 读者请细心观察,当<code>RS = &quot;&quot;</code> 时, awk读取该数据文件之方式.</p>
<p>编辑一个awk程序文件 make_report如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS = "\n"</div><div class="line">    RS = ""</div><div class="line">    split( "一. 二. 三. 四. 五. 六. 七. 八. 九.", C_Number, " " )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    printf("\n%s 报告人 : %s \n",C_Number[NR],$1)</div><div class="line">    for( i=2; i &lt;= NF; i++) printf(" %d. %s\n", i-1, $i)</div><div class="line">&#125; ' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make_report week.rpt</div></pre></td></tr></table></figure></p>
<p>屏幕产生结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">一. 报告人 : 张长弓</div><div class="line"> 1. GNUPLOT 入门</div><div class="line"></div><div class="line">二. 报告人 : 吴国强</div><div class="line"> 1. Latex 简介</div><div class="line"> 2. VAST-2 使用手册</div><div class="line"> 3. mathematic 入门</div><div class="line"></div><div class="line">三. 报告人 : 李小华</div><div class="line"> 1. awk Tutorial Guide</div><div class="line"> 2. Regular Expression</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>本程序同时也改变字段分隔字符(<code>FS = &quot;\n&quot;</code>), 如此一笔数据中的每一行都是一个<code>field</code>. 例如: awk读入的第一笔 Record 为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div></pre></td></tr></table></figure></p>
<p>其中<code>$1</code>指的是”<code>张长弓</code>“, <code>$2</code>指的是”<code>GNUPLOT 入门</code>“<br>上式中的<code>C_Number[]</code>是一个数组(array), 用以记录中文数字. 例如: <code>C_Number[1] = &quot;一.&quot;</code>,<code>C_Number[2] = &quot;二.&quot;</code>这过程使用awk字符串函数 <code>split()</code> 来把中文数字放进数组<code>C_Number[]</code>中.<br>函数<code>split( )</code>用法如下:<br><code>split( 原字符串, 数组名, 分隔字符(field separator) )</code> : awk将依所指定的分隔字符(field separator)分隔原字符串成一个个的字段(field), 并以指定的数组记录各个被分隔的字段</p>
<h2 id="如何读取命令行上的参数"><a href="#如何读取命令行上的参数" class="headerlink" title="如何读取命令行上的参数"></a>如何读取命令行上的参数</h2><p>大部分的应用程序都允许使用者在命令之后增加一些选择性的参数.执行awk时这些参数大部分用于指定数据文件文件名, 有时希望在程序中能从命令行上得到一些其它用途的数据. 本小节中将叙述如何在awk程序中取用这些参数.</p>
<p>建立文件如下, 命名为<code>see_arg</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    for( i=0; i&lt;ARGC ; i++)</div><div class="line">        print ARGV[i] # 依次印出awk所记录的参数</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./see_arg first-arg second-arg</div></pre></td></tr></table></figure></p>
<p>结果屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk</div><div class="line">first-arg</div><div class="line">second-arg</div></pre></td></tr></table></figure></p>
<p>[说明:]<br><code>ARGC</code>,<code>ARGV[]</code> 为awk所提供的内建变量.<br><code>ARGC</code>: 为一整数. 代表命令行上, 除了选项<code>-v</code>,<code>-f</code> 及其对应的参数之外所有参数的数目.<br><code>ARGV[]</code>: 为一字符串数组.<code>ARGV[0]</code>,<code>ARGV[1]</code>,…<code>ARGV[ARGC-1]</code>.<br>分别代表命令行上相对应的参数.<br>例如, 当命令行为 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -vx=36 <span class="_">-f</span> program1 data1 data2</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $1 ,$2 &#125;'</span> data1 data2</div></pre></td></tr></table></figure></p>
<p>其<code>ARGC</code> 之值为 3<br><code>ARGV[0]</code> 之值为 “awk”<br><code>ARGV[1]</code>之值为 “data1”<br><code>ARGV[2]</code> 之值为 “data2”  </p>
<p>命令行上的”<code>-f program1</code>“, “<code>-vx=36</code>“, 或程序部分<code>&#39;{ print $1, $2}&#39;</code>都不会列入 <code>ARGC</code> 及 <code>ARGV[]</code>中.<br>awk 利用<code>ARGC</code> 来判断应开启的数据文件个数.<br>但使用者可强行改变<code>ARGC</code>; 当 <code>ARGC</code> 之值被使用者设为 <code>1</code> 时; awk将被蒙骗,误以为命令行上并无数据文件文件名, 故不会以 <code>ARGV[1]</code>,<code>ARGV[2]</code>,..为文件名来打开文件读取数据; 但在程序中仍可通过<code>ARGV[1]</code>,<code>ARGV[2]</code>,..来取得命令行上的数据.</p>
<p>某一程序 test1.awk 如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN&#123;</div><div class="line">    number = ARGC <span class="comment">#先用number 记住实际的参数个数.</span></div><div class="line">    ARGC = 2 <span class="comment"># 自行更改 ARGC=2, awk将以为只有一个资料文件</span></div><div class="line">    <span class="comment"># 仍可藉由ARGV[ ]取得命令行上的资料.</span></div><div class="line">    <span class="keyword">for</span>( i=2; i&lt;number; i++) data[i] = ARGV[i]</div><div class="line">&#125;</div><div class="line">........</div></pre></td></tr></table></figure></p>
<p>于命令行上键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f test1.awk data_file apple orange</div></pre></td></tr></table></figure></p>
<p>执行时 awk 会打开数据文件 <code>data_file</code> 以进行处理. 但不会打开以<code>apple</code>,<code>orange</code>为档名的文件(因为<code>ARGC</code>被改成<code>2</code>). 但仍可通过<code>ARGV[2]</code>,<code>ARGV[3]</code>取得命令行上的参数 <code>apple</code>,<code>orange</code></p>
<p>也可以用下列命令来达成上例的效果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> <span class="built_in">test</span>2.awk -v data[2]=<span class="string">"apple"</span> -v data[3]=<span class="string">"orange"</span> data_file</div></pre></td></tr></table></figure></p>
<h2 id="编写可与用户交互的-awk-程序"><a href="#编写可与用户交互的-awk-程序" class="headerlink" title="编写可与用户交互的 awk 程序"></a>编写可与用户交互的 awk 程序</h2><p>执行awk程序时, awk会自动从文件中读取数据来进行处理, 直到文件结束.只要将awk读取数据的来源改成键盘输入,便可设计与awk 交互的程序了.</p>
<p>本节将提供一个该类程序的范例.<br>[范例:] 本节将编写一个英语生字测验的程序, 它将印出中文字意,再由使用者回答其英语生字.</p>
<p>首先编辑一个数据挡 test.dat (内容不限,格式如下)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apple 苹果</div><div class="line">orange 柳橙</div><div class="line">banana 香蕉</div><div class="line">pear 梨子</div><div class="line">starfruit 杨桃</div><div class="line">bellfruit 莲雾</div><div class="line">kiwi 奇异果</div><div class="line">pineapple 菠萝</div><div class="line">watermelon 西瓜</div></pre></td></tr></table></figure></p>
<p>编辑awk程序”c2e”如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    while( getline &lt; ARGV[1] ) &#123; #由指定的文件中读取测验数据</div><div class="line">        English[++n] = $1 # 最后, n 将表示题目之题数</div><div class="line">        Chinese[n] = $2</div><div class="line">    &#125;</div><div class="line">    ARGV[1] = "-" # "-"表示由stdin(键盘输入)</div><div class="line">    srand() # 以系统时间为随机数启始的种子</div><div class="line">    question() #产生考题</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;# awk自动读入由键盘上输入的数据(使用者回答的答案)</div><div class="line">    if($1 != English[ind] )</div><div class="line">        print "Try again!"</div><div class="line">    else&#123;</div><div class="line">        print "\nYou are right !! Press Enter to Continue --- "</div><div class="line">        getline</div><div class="line">        question()#产生考题</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function question()&#123;</div><div class="line">    ind = int(rand()* n) + 1 #以随机数选取考题</div><div class="line">    system("clear")</div><div class="line">    print " Press \"ctrl-d\" to exit"</div><div class="line">    printf("\n%s ", Chinese[ind] " 的英文生字是: ")</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行时键入如下指令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./c2e test.dat</div></pre></td></tr></table></figure></p>
<p>屏幕将产生如下的画面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Press &quot;ctrl-d &quot; to exit</div><div class="line">莲雾 的英文生字是:</div></pre></td></tr></table></figure></p>
<p>若输入 <code>bellfruit</code><br>程序将产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You are right !! Press Enter to Continue ---</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>参数 <code>test.dat</code> (<code>ARGV[1]</code>) 表示储存考题的数据文件文件名. awk 由该文件上取得考题资料后, 将 <code>ARGV[1]</code> 改成”<code>-</code>“.<br>“<code>-</code>“表示由<code>stdin</code>(键盘输入) 数据. 键盘输入数据的结束符号<code>(End of file)</code>是<code>ctrl-d</code>. 当 awk 读到 <code>ctrl-d</code> 时就停止由<code>stdin</code>读取数据.</p>
<p>awk的数学函数中提供两个与随机数有关的函数.<br><code>srand()</code>: 以当前的系统时间作为随机数的种子<br><code>rand()</code>: 返回介于 0与1之间的(近似)随机数值.</p>
<h2 id="使用-awk-编写递归程序"><a href="#使用-awk-编写递归程序" class="headerlink" title="使用 awk 编写递归程序"></a>使用 awk 编写递归程序</h2><p>awk 中除了函数的参数列(Argument List)上的参数(Arguments)外,所有变量不管于何处出现,全被视为全局变量. 其生命持续至程序结束 — 该变量不论在function外或 function内皆可使用,只要变量名称相同所使用的就是同一个变量,直到程序结束.</p>
<p>因递归函数内部的变量, 会因它调用子函数(本身)而重复使用,故编写该类函数时, 应特别留心.</p>
<p>[例如:] 执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    x = 35</div><div class="line">    y = 45</div><div class="line">    test_variable( x )</div><div class="line">    printf("Return to main : arg1= %d, x= %d, y= %d, z= %d\n", arg1, x, y, z)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function test_variable( arg1 )</div><div class="line">&#123;</div><div class="line">    arg1++ # arg1 为参数列上的参数, 是local variable. 离开此函数后将消失.</div><div class="line">    y ++ # 会改变主式中的变量 y</div><div class="line">    z = 55 # z 为该函数中新使用的变量, 主程序中变量 z 仍可被使用.</div><div class="line">    printf("Inside the function: arg1=%d,x=%d, y=%d, z=%d\n", arg1, x, y, z)</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果屏幕印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Inside the function: arg1=36,x=35, y=46, z=55</div><div class="line">Return to main : arg1= 0, x= 35, y= 46, z= 55</div></pre></td></tr></table></figure></p>
<p>由上可知:<br>函数内可任意使用主程序中的任何变量.函数内所启用的任何变量(除参数外), 于该函数之外依然可以使用.此特性优劣参半, 最大的坏处是式中的变量不易被保护, 特别是递归调用本身, 执行子函数时会破坏父函数内的变量.</p>
<p>一个变通的方法是: 在函数的参数列中虚列一些参数. 函数执行中使用这些虚列的参数来记录不想被破坏的数据,如此执行子函数时就不会破坏到这些数据. 此外 awk 并不会检查调用函数时所传递的参数个数是否一致.</p>
<p>例如，定义递归函数如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1 ) &#123; <span class="comment"># 最常见的错误例子</span></div><div class="line">    ........</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20 ; i++)&#123;</div><div class="line">        demo(x)</div><div class="line">        <span class="comment"># 又呼叫本身. 因为 i 是 global variable, 故执行完该子函数后</span></div><div class="line">        <span class="comment"># 原函数中的 i 已经被坏, 故本函数无法正确执行.</span></div><div class="line">        .......</div><div class="line">    &#125;</div><div class="line">    ..........</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可将上列函数中的<code>i</code>虚列在该函数的参数列上, 如此<code>i</code>便是一个局部变量, 不会因执行子函数而被破坏.</p>
<p>将上列函数修改如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1, i )</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20; i++)</div><div class="line">    &#123;</div><div class="line">        demo(x)<span class="comment">#awk不会检查呼叫函数时, 所传递的参数个数是否一致</span></div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>$0</code>, <code>$1</code>,.., <code>NF</code>, <code>NR</code>,..也都是 global variable, 读者于递归函数中若有使用这些内建变量, 也应另外设立一些局部变量来保存,以免被破坏.</p>
<p>[范例:]以下是一个常见的递归调用范例. 它要求使用者输入一串元素(各元素间用空白隔开) 然后印出这些元素所有可能的排列.</p>
<p>编辑如下的awk式, 取名为 <code>permu</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    print "请输入排列的元素,各元素间请用空白隔开"</div><div class="line">    getline</div><div class="line">    permutation($0, "")</div><div class="line">    printf("\n共 %d 种排列方式\n", counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function permutation( main_lst, buffer,     new_main_lst, nf, i, j )</div><div class="line">&#123;</div><div class="line">    $0 = main_lst # 把main_lst指定给$0之后awk将自动进行字段分割.</div><div class="line">    nf = NF # 故可用 NF 表示 main_lst 上存在的元素个数.</div><div class="line">    # BASE CASE : 当main_lst只有一个元素时.</div><div class="line">    if( nf == 1)&#123;</div><div class="line">        print buffer main_lst #buffer的内容再加上main_lst就是完成一次排列的结果</div><div class="line">        counter++</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    # General Case : 每次从 main_lst 中取出一个元素放到buffer中</div><div class="line">    # 再用 main_lst 中剩下的元素 (new_main_lst) 往下进行排列</div><div class="line">    else for( i=1; i&lt;=nf ;i++)</div><div class="line">    &#123;</div><div class="line">        $0 = main_lst # $0为全局变量已被破坏, 故重新把main_lst赋给$0,令awk再做一次字段分割</div><div class="line">        new_main_lst = ""</div><div class="line">        for(j=1; j&lt;=nf; j++) # 连接 new_main_lst</div><div class="line">            if( j != i ) new_main_lst = new_main_lst " " $j</div><div class="line">        permutation( new_main_lst, buffer " " $i )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./permu</div></pre></td></tr></table></figure></p>
<p>屏幕上出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请输入排列的元素,各元素间请用空白隔开</div></pre></td></tr></table></figure></p>
<p>若输入 <code>1 2 3</code> 回车,结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> 1 2 3</div><div class="line"> 1 3 2</div><div class="line"> 2 1 3</div><div class="line"> 2 3 1</div><div class="line"> 3 1 2</div><div class="line"> 3 2 1</div><div class="line"></div><div class="line">共 6 种排列方式</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>有些较旧版的awk,并不容许使用者指定<code>$0</code>之值. 此时可改用gawk, 或 nawk.否则也可自行使用<code>split()</code>函数来分割<code>main_lst</code>.<br>为避免执行子函数时破坏<code>new_main_lst, nf, i, j</code>故把这些变量也列于参数列上. 如此,<code>new_main_lst, nf, i, j</code> 将被当成局部变量,而不会受到子函数中同名的变量影响. 读者声明函数时,参数列上不妨将这些 “虚列的参数” 与真正用于传递信息的参数间以较长的空白隔开, 以便于区别.<br>awk 中欲将字符串<code>concatenation</code>(连接)时, 直接将两字符串并置即可(Implicit Operator).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    A = "This "</div><div class="line">    B = "is a "</div><div class="line">    C = A B "key." # 变量A与B之间应留空白,否则"AB"将代表另一新变量.</div><div class="line">    print C</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>结果将印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This is a key.</div></pre></td></tr></table></figure></p>
<p>awk使用者所编写的函数可再重用, 并不需要每个awk式中都重新编写.<br>将函数部分单独编写于一文件中, 当需要用到该函数时再以下列方式include进来.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> 函数文件名 <span class="_">-f</span> awk主程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<h2 id="附录-A-──-Pattern"><a href="#附录-A-──-Pattern" class="headerlink" title="附录 A ── Pattern"></a>附录 A ── Pattern</h2><p>awk 通过判断 Pattern 之值来决定是否执行其后所对应的Actions.这里列出几种常见的Pattern:</p>
<h3 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h3><p><code>BEGIN</code> 为 awk 的保留字, 是一种特殊的 Pattern.<br><code>BEGIN</code> 成立(其值为true)的时机是: “awk 程序一开始执行, 尚未读取任何数据之前.” 所以在<code>BEGIN { Actions }</code>语法中, 其 Actions 部份仅于程序一开始执行时被执行一次. 当 awk 从数据文件读入数据行后, BEGIN 便不再成立, 故不论有多少数据行, 该 Actions 部份仅被执行一次.</p>
<p>一般常把 “与数据文件内容无关” 与 “只需执行ㄧ次” 的部分置于该Actions(以 <code>BEGIN</code> 为 Pattern)中.</p>
<p>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    FS = <span class="string">"[ \t:]"</span> <span class="comment"># 于程序一开始时, 改变awk切割字段的方式</span></div><div class="line">    RS = <span class="string">""</span> <span class="comment"># 于程序一开始时, 改变awk分隔数据行的方式</span></div><div class="line">    count = 100 <span class="comment"># 设定变量 count 的起始值</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" This is a title line "</span> <span class="comment"># 印出一行 title</span></div><div class="line">&#125;</div><div class="line">....... <span class="comment"># 其它 Pattern &#123; Actions &#125; .....</span></div></pre></td></tr></table></figure></p>
<p>有些awk程序甚至”不需要读入任何数据行”. 遇到这情况可把整个程序置于以 <code>BEGIN</code> 为 Pattern 的 Actions 中.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" Hello ! the Word ! "</span> &#125;</div></pre></td></tr></table></figure></p>
<p>注意: 执行该类仅含<code>BEGIN { Actions }</code>的程序时, awk 并不会开启任何数据文件进行处理.</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><code>END</code> 为 awk 的保留字, 是另一种特殊的 Pattern.<br><code>END</code> 成立(其值为true)的时机与 <code>BEGIN</code> 恰好相反, 为:”awk 处理完所有数据, 即将离开程序时”平常读入数据行时, END并不成立, 故其对应的 Actions 并不被执行; 唯有当awk读完所有数据时, 该 Actions 才会被执行</p>
<p>注意 : 不管数据行有多少笔, 该 Actions 仅被执行一次.</p>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>使用像 “A 关系运算符 B” 的表达式当成 Pattern.<br>当 A 与 B 存在所指定的关系(Relation)时, 该 Pattern 就算成立(true).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length(<span class="variable">$0</span>) &lt;= 80 &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式中<code>length($0)&lt;= 80</code>是一个 Pattern, 当<code>$0</code>(数据行)之长度小于等于80时该 Pattern 之值为true, 将执行其后的 Action (打印该数据行).</p>
<p>awk 中提供下列 关系运算符(Relation Operator)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含意</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>~</td>
<td>match</td>
</tr>
<tr>
<td>!~</td>
<td>not match</td>
</tr>
</tbody>
</table>
<p>上列关系运算符除<code>~</code>(match)与<code>!~</code>(not match)外与 C 语言中之含意一致.</p>
<p><code>~</code>(match) 与<code>!~</code>(match) 在 awk 之含意简述如下:<br>若 A 为一字符串, B 为一正则表达式.<br><code>A ~B</code> 判断 字符串A 中是否 包含 能匹配(match)B式样的子字符串.<br><code>A !~B</code> 判断 字符串A 中是否 未包含 能匹配(match)B式样的子字符串.  </p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`<span class="variable">$0</span> ~ /program[0-9]+\.c/ &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;`</div></pre></td></tr></table></figure></p>
<p><code>$0 ~ /program[0-9]+\.c/</code> 整个是一个 Pattern, 用来判断<code>$0</code>(数据行)中是否含有可 match <code>/program[0-9]+\.c/</code> 的子字符串, 若<code>$0</code>中含有该类字符串, 则执行 <code>print</code> (打印该行数据).</p>
<p>Pattern 中被用来比对的字符串为 <code>$0</code> 时(如本例), 可仅以正则表达式部分表示整个Pattern.</p>
<p>故本例的 Pattern 部分<code>$0 ~/program[0-9]+\.c/</code>可仅用<code>/program[0-9]+\.c/</code>表之(有关匹配及正则表达式请参考 附录 E )</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>直接使用正则表达式当成 Pattern; 此为 <code>$0 ~ 正则表达式</code> 的简写.<br>该 Pattern 用以判断<code>$0</code>(数据行) 中是否含有匹配该正则表达式的子字符串; 若含有该成立(true) 则执行其对应的 Actions.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`/^[0-9]*$/ &#123; <span class="built_in">print</span> <span class="string">"This line is a integer !"</span> &#125;`</div></pre></td></tr></table></figure></p>
<p>与<code>$0 ~/^[0-9]*$/ { print &quot;This line is a integer !&quot; }</code> 相同</p>
<h3 id="混合-Pattern"><a href="#混合-Pattern" class="headerlink" title="混合 Pattern"></a>混合 Pattern</h3><p>之前所介绍的各种 Patterns, 其计算后结果为一逻辑值(True or False).awk 中逻辑值彼此间可通过<code>&amp;&amp;</code>(and), <code>||</code>(or),  <code>!</code>(not) 结合成一个新的逻辑值.故不同 Patterns 彼此可通过上述结合符号来结合成一个新的 Pattern. 如此可进行复杂的条件判断.</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式利用<code>&amp;&amp;</code>(and) 将两个 Pattern 求值的结果合并成一个逻辑值.<br>该式将数据文件中 第23行 到 28行 向右移5格(先输出5个空白字符)后输出.<br>(<code>FNR</code>为awk的内建变量, 请参考 附录 D )</p>
<h3 id="Pattern1-Pattern2"><a href="#Pattern1-Pattern2" class="headerlink" title="Pattern1, Pattern2"></a>Pattern1, Pattern2</h3><p>遇到这种 Pattern, awk 会帮您设立一个 switch(或flag).<br>当awk读入的数据行使得 Pattern1 成立时, awk 会打开(turn on)这 switch.<br>当awk读入的数据行使得 Pattern2 成立时, awk 会关上(turn off)这个 switch.  </p>
<p>该 Pattern 成立的条件是:<br>当这个 switch 被打开(turn on)时 (包括 Pattern1, 或 Pattern2 成立的情况)</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>可改写为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR == 23 , FNR == 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>当 <code>FNR &gt;= 23</code> 时, awk 就 turn on 这个 switch; 因为随着数据行的读入, awk不停的累加<code>FNR</code>. 当<code>FNR = 28</code>时,<code>Pattern2 (FNR == 28)</code> 便成立, 这时 awk 会关上这个 switch.<br>当 switch 打开的期间, awk 会执行 <code>print &quot;     &quot; $0</code><br>( FNR 为awk的内建变量, 请参考 附录 D )</p>
<h2 id="附录-B-──-Actions"><a href="#附录-B-──-Actions" class="headerlink" title="附录 B ── Actions"></a>附录 B ── Actions</h2><p>Actions 是由下列指令(statement)所组成:</p>
<ul>
<li>表达式 (function calls, assignments..)</li>
<li>print 表达式列表</li>
<li>printf(格式化字符串, 表达式列表)</li>
<li>if( 表达式 ) 语句 [else 语句]</li>
<li>while( 表达式 ) 语句</li>
<li>do 语句 while( 表达式 )</li>
<li>for( 表达式; 表达式; 表达式 ) 语句</li>
<li>for( variable in array ) 语句</li>
<li>delete</li>
<li>break</li>
<li>continue</li>
<li>next</li>
<li>exit [表达式]</li>
<li>语句</li>
</ul>
<p>awk 中大部分指令与 C 语言中的用法一致, 此处仅介绍较为常用或容易混淆的指令的用法.</p>
<h3 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h3><p><strong>if 指令</strong></p>
<p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (表达式) 语句1 [<span class="keyword">else</span> 语句2 ]</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="variable">$1</span> &gt; 25 )</div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is larger than 25"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is not larger than 25"</span></div></pre></td></tr></table></figure></p>
<p>(a) 与 C 语言中相同, 若 表达式 计算(evaluate)后之值不为 0 或空字符串, 则执行 语句1; 否则执行 语句2.<br>(b) 进行逻辑判断的表达式所返回的值有两种, 若最后的逻辑值为<code>true</code>, 则返回1, 否则返回0.<br>(c) 语法中<code>else 语句2</code>以 [ ] 前后括住表示该部分可视需要而予加入或省略.</p>
<p><strong>while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>( 表达式 ) 语句</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(match(buffer,/[0-9]+\.c/)) &#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Find :"</span> substr( buffer,RSTART, RLENGTH)</div><div class="line">    buff = substr( buffer, RSTART + RLENGTH)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上列范例找出 <code>buffer</code> 中所有能匹配 <code>/[0-9]+.c/</code>(数字之后接上 “<code>.c</code>“的所有子字符串).</p>
<p>范例中 <code>while</code> 以函数 <code>match()</code> 所返回的值做为判断条件. 若 <code>buffer</code> 中还含有匹配指定条件的子字符串(match成功), 则 <code>match()</code> 函数返回<code>1</code>, <code>while</code> 将持续进行其后的语句.</p>
<p><strong>do-while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> 语句 <span class="keyword">while</span>(表达式)</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Enter y or n ! "</span></div><div class="line">    getline data</div><div class="line">&#125; <span class="keyword">while</span>( data !~ /^[YyNn]$/)</div></pre></td></tr></table></figure></p>
<p>(a) 上例要求用户从键盘上输入一个字符, 若该字符不是Y, y, N, 或 n则会不停执行该循环, 直到读取正确字符为止.<br>(b) <code>do-while</code> 指令与 <code>while</code> 指令最大的差异是: <code>do-while</code> 指令会先执行<code>statement</code>而后再判断是否应继续执行. 所以, 无论如何其 <code>statement</code> 部分至少会执行一次.</p>
<p><strong>for Statement 指令(一)</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span>  array ) statement</div></pre></td></tr></table></figure></p>
<p>范例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">    BEGIN&#123;</div><div class="line">        X[1]= 50; X[2]= 60; X["last"]= 70</div><div class="line">        for( any in X )</div><div class="line">            printf("X[%s] = %d\n", any, X[any] )</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X[last] = 70</div><div class="line">X[1] = 50</div><div class="line">X[2] = 60</div></pre></td></tr></table></figure></p>
<p>(a) 这个 <code>for</code> 指令, 专用以查找数组中所有的下标值, 并依次使用所指定的变量予以记录. 以本例而言, 变量 any 将逐次代表 “last”, 1 及2 .<br>(b) 以这个 <code>for</code> 指令, 所查找出的下标之值彼此间并无任何次续关系.<br>(c) 第5节中有该指令的使用范例, 及解说.</p>
<p><strong>for Statement 指令(二)</strong></p>
<p>语法 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(expression1; expression2; expression3) statement</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(ｉ=1; i&lt; =10; i++)  sum = sum + i</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上列范例用以计算 1 加到 10 的总和.<br>(b) <code>expression1</code> 常用于设定该 for 循环的起始条件, 如上例中的 <code>i=1</code><br><code>expression2</code> 用于设定该循环的停止条件, 如上例中的 <code>i &lt;= 10</code><br><code>expression3</code> 常用于改变 counter 之值, 如上例中的 <code>i++</code></p>
<p><strong>break 指令</strong></p>
<p><code>break</code> 指令用以强迫中断(跳离) <code>for</code>, <code>while</code>, <code>do-while</code> 等循环.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(  getline &lt; <span class="string">"datafile"</span> &gt; 0 )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="variable">$1</span> == 0 )</div><div class="line">        <span class="built_in">break</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">print</span> <span class="variable">$2</span> / <span class="variable">$1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中, awk 不断地从文件 <code>datafile</code> 中读取资料, 当<code>$1</code>等于0时,就停止该执行循环.</p>
<p><strong>continue 指令</strong></p>
<p>循环中的 <code>statement</code> 进行到一半时, 执行 <code>continue</code> 指令来略过循环中尚未执行的<code>statement</code>.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( index <span class="keyword">in</span> X_array)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( index !~ /[0-9]+/ )  <span class="built_in">continue</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"There is a digital index"</span>, index</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中若 <code>index</code> 不为数字则执行<code>continue</code>, 故将略过(不执行)其后的指令.</p>
<p>需留心 <code>continue</code> 与 <code>break</code> 的差异 : 执行 <code>continue</code> 只是掠过其后未执行的<code>statement</code>, 但并未跳离开该循环.</p>
<p><strong>next 指令</strong></p>
<p>执行 <code>next</code> 指令时, awk 将掠过位于该指令(next)之后的所有指令(包括其后的所有<code>Pattern { Actions }</code>), 接著读取下一笔数据行,继续从第一个 <code>Pattern {Actions}</code> 执行起.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^[ \t]*$/  &#123;  <span class="built_in">print</span> <span class="string">"This is a blank line! Do nothing here !"</span></div><div class="line">    next</div><div class="line">&#125;</div><div class="line"><span class="variable">$2</span> != 0 &#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$1</span>/<span class="variable">$2</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上例中, 当 awk 读入的数据行为空白行时( match <code>/^[ \]*$/</code> ),除打印消息外只执行<code>next</code>, 故 awk 将略过其后的指令, 继续读取下一笔资料, 从头(第一个 <code>Pattern { Actions }</code>)执行起.</p>
<p><strong>exit 指令</strong></p>
<p>执行 <code>exit</code> 指令时, awk将立刻跳离(停止执行)该awk程序.</p>
<h3 id="awk-中的-I-O-指令"><a href="#awk-中的-I-O-指令" class="headerlink" title="awk 中的 I/O 指令"></a>awk 中的 I/O 指令</h3><p><strong>printf 指令</strong></p>
<p>该指令与 C 语言中的用法相同, 可借由该指令控制资料输出时的格式.</p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"format"</span>, item1, item2,.. )</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-2647"</span>;  ave = 89</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ID# : %s   Ave Score : %d\n"</span>, id, ave)</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-2647   Ave Score : 89</div></pre></td></tr></table></figure></p>
<p>(b) <code>format</code> 部分是由 一般的字串(String Constant) 及 格式控制字符(Formatcontrol letter, 其前会加上一个%字符)所构成. 以上式为例”<code>ID# :</code>“ 及 “<code>Ave Score :</code>“为一般字串.<code>%s</code> 及 <code>%d</code> 为格式控制字符.<br>(c) 打印时, 一般字串将被原封不动地打印出来. 遇到格式控制字符时,则依序把<code>format</code>后方之 <code>item</code> 转换成所指定的格式后进行打印.<br>(d) 有关的细节, 读者可从介绍 C 语言的书籍上得到较完整的介绍.</p>
<p>(e) <code>print</code>及<code>printf</code>两个指令, 其后可使用 <code>&gt;</code>或<code>&gt;&gt;</code>将输出到 <code>stdout</code> 的数据重定向到其它文件, 7.1 节中有完整的</p>
<p><strong>print 指令</strong></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-267"</span>;  ave = 89</div><div class="line"><span class="built_in">print</span> <span class="string">"ID# :"</span>, id, <span class="string">"Ave Score :"</span>ave</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-267 Ave Score :89</div></pre></td></tr></table></figure></p>
<p>(b) <code>print</code> 之后可接上字串常数(Constant String)或变量. 它们彼此间可用”,” 隔开.<br>(c) 上式中, 字串 “ID# :” 与变量 id 之间使用”<code>,</code>“隔开, 打印时两者之间会以自动<code>OFS</code>(请参考 附录D 內建变量<code>OFS</code>) 隔开. <code>OFS</code> 之值一般內定为 “一个空格”<br>(d) 上式中, 字串”<code>Ave Score :</code>“与变量<code>ave</code>之间并未以”<code>,</code>“隔开, awk会将这两者先当成字串concate在一起(变成”<code>Ave Score :89</code>“)后,再予打印</p>
<p><strong>getline 指令</strong></p>
<p>语法</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的 file</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>pipe 变量</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p><code>getline</code> 一次读取一行资料, 若读取成功则<code>return 1</code>,若读取失败则<code>return -1</code>, 若遇到文件结束(EOF), 则return 0</p>
<p><strong>close  指令</strong></p>
<p>该指令用以关闭一个打开的文件, 或 pipe (见下例)</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;  <span class="built_in">print</span> <span class="string">"ID #   Salary"</span> &gt; <span class="string">"data.rpt"</span> &#125;</div><div class="line">&#123;  <span class="built_in">print</span> <span class="variable">$1</span> , <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; data.rpt"</span> &#125;</div><div class="line">END&#123;  close( <span class="string">"data.rpt"</span> )</div><div class="line">    close( <span class="string">"sort -k 1 &gt; data.rpt"</span> )</div><div class="line">    <span class="built_in">print</span> <span class="string">" There are"</span>, NR, <span class="string">"records processed."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上例中, 一开始执行<code>print &quot;ID #   Salary&quot; &gt; &quot;data.rpt&quot;</code>指令来输出一行抬头. 它使用 I/O Redirection (<code>&gt;</code>)将数据转输出到<code>data.rpt</code>, 故此时文件 <code>data.rpt</code> 是处於 Open 状态.<br>(b) 指令<code>print $1, $2 * $3</code> 不停的将输出的资料送往 pipe(<code>|</code>), awk在程序将结束时才会呼叫 shell 使用指令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的数据; 并未立即执行, 这点与 Unix 中pipe的用法不尽相同.<br>(c) 最后希望於文件 <code>data.rpt</code> 的末尾处加上一行 “There are…..”.但此时, Shell尚未执行<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 故各数据行排序后的 ID 及 Salary 等数据尚未写入<code>data.rpt</code>. 所以得命令 awk 提前先通知 Shell 执行命令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的资料. awk中这个动作称为 close pipe. 是由执行<code>close ( &quot;shell command&quot; )</code>来完成. 需留心 <code>close( )</code>指令中的 shell command 需与”<code>|</code>“后方的 shell command 完全相同(一字不差), 较佳的方法是先以该字串定义一个简短的变量, 程序中再以此变量代替该shell command<br>(d) 为什么执行 <code>close(&quot;data.rpt&quot;)</code> ?  因为 <code>sort</code> 完后的资料也将写到<code>data.rpt</code>,而该文件正为awk所打开使用(write)中, 故awk程式中应先关闭<code>data.rpt</code>. 以免造成因二个 processes 同时打开一个文件进行输出(write)所产生的错误.</p>
<p><strong>system 指令</strong></p>
<p>该指令用以执行Shell上的 command.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DataFile = <span class="string">"invent.rpt"</span></div><div class="line">system( <span class="string">"rm "</span> DataFile )</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) <code>system(&quot;字符串&quot;)</code>指令接受一个字符串当成Shell的命令. 上例中, 使用一个字串常数”<code>rm</code>“ 连接(concate)一个变量 <code>DataFile</code> 形成要求 Shell 执行的命令.Shell 实际执行的命令为 “<code>rm invent.rpt</code>“.</p>
<p><strong>“<code>|</code>“ pipe指令</strong></p>
<p>“<code>|</code>“ 配合 awk 输出指令, 可把 output 到 stdout 的资料继续转送给Shell 上的某一命令当成input的资料.</p>
<p>“<code>|</code>“  配合 awk <code>getline</code> 指令, 可呼叫 Shell 执行某一命令, 再以 awk 的 <code>getline</code> 指令将该命令的所产生的资料读进 awk 程序中.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; result"</span> &#125;</div><div class="line"><span class="string">"date"</span> |  getline  Date_data</div></pre></td></tr></table></figure></p>
<p>读者请参考7.2 节,其中有完整的范例说明.</p>
<h3 id="awk-释放所占用的记忆体的指令"><a href="#awk-释放所占用的记忆体的指令" class="headerlink" title="awk 释放所占用的记忆体的指令"></a>awk 释放所占用的记忆体的指令</h3><p>awk 程式中常使用数组(Array)来记忆大量数据, <code>delete</code> 指令便是用来释放数组中的元素所占用的内存空间.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> X_arr )</div><div class="line">    delete X_arr[any]</div></pre></td></tr></table></figure></p>
<p>读者请留心, <code>delete</code> 指令一次只能释放数组中的一个元素.</p>
<h3 id="awk-中的数学运算符-Arithmetic-Operators"><a href="#awk-中的数学运算符-Arithmetic-Operators" class="headerlink" title="awk 中的数学运算符(Arithmetic Operators)"></a>awk 中的数学运算符(Arithmetic Operators)</h3><p>+(加), -(減), *(乘), /(除), %(求余数), ^(指数) 与 C 语言中用法相同</p>
<h3 id="awk-中的赋值运算符-Assignment-Operators"><a href="#awk-中的赋值运算符-Assignment-Operators" class="headerlink" title="awk 中的赋值运算符(Assignment Operators)"></a>awk 中的赋值运算符(Assignment Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=, +=, -=, *= , /=, %=, ^=</div></pre></td></tr></table></figure>
<p><code>x += 5</code> 的意思为<code>x = x + 5</code>, 其余类推.</p>
<h3 id="awk-中的条件运算符-Conditional-Operator"><a href="#awk-中的条件运算符-Conditional-Operator" class="headerlink" title="awk 中的条件运算符(Conditional  Operator)"></a>awk 中的条件运算符(Conditional  Operator)</h3><p>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">判断条件 ? value1 : value2</div></pre></td></tr></table></figure></p>
<p>若 判断条件 成立(true) 则返回 value1, 否则返回 value2.</p>
<h3 id="awk-中的逻辑运算符-Logical-Operators"><a href="#awk-中的逻辑运算符-Logical-Operators" class="headerlink" title="awk 中的逻辑运算符(Logical Operators)"></a>awk 中的逻辑运算符(Logical Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;&amp;( and ), ||(or), !(not)</div></pre></td></tr></table></figure>
<p>Extended Regular Expression 中使用 “<code>|</code>“ 表示 or 请勿混淆.</p>
<h3 id="awk-中的关系运算符-Relational-Operators"><a href="#awk-中的关系运算符-Relational-Operators" class="headerlink" title="awk 中的关系运算符(Relational Operators)"></a>awk 中的关系运算符(Relational Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &gt;=, &lt;, &lt; =, ==, !=, ~, !~</div></pre></td></tr></table></figure>
<h3 id="awk-中其它的运算符"><a href="#awk-中其它的运算符" class="headerlink" title="awk 中其它的运算符"></a>awk 中其它的运算符</h3><p>+(正号), -(负号),  ++(Increment Operator), –(Decrement Operator)</p>
<h3 id="awk-中各运算符的运算级"><a href="#awk-中各运算符的运算级" class="headerlink" title="awk 中各运算符的运算级"></a>awk 中各运算符的运算级</h3><p>按优先高低排列:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$</code></td>
<td>(栏位运算元, 例如: <code>i=3</code>; <code>$i</code>表示第3栏)</td>
</tr>
<tr>
<td>^</td>
<td>(指数运算)</td>
</tr>
<tr>
<td>+, -, !</td>
<td>(正,负号,及逻辑上的 not)</td>
</tr>
<tr>
<td>*, /, %</td>
<td>(乘,除,余数)</td>
</tr>
<tr>
<td>+, -</td>
<td>(加,減)</td>
</tr>
<tr>
<td>&gt;, &gt;=, <code>&lt;</code>, <code>&lt;=</code>, ==, !=</td>
<td>(关系运算符)</td>
</tr>
<tr>
<td>~, !~</td>
<td>(match, not match)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>(逻辑上的 and)</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>(逻辑上的 or )</td>
</tr>
<tr>
<td>?:</td>
<td>(条件运算符)</td>
</tr>
<tr>
<td>=, +=, -=, *=, /=, %=, ^=</td>
<td>(赋值运算符)</td>
</tr>
</tbody>
</table>
<h2 id="附录C-──-awk-的內建函数-Built-in-Functions"><a href="#附录C-──-awk-的內建函数-Built-in-Functions" class="headerlink" title="附录C ── awk 的內建函数(Built-in Functions)"></a>附录C ── awk 的內建函数(Built-in Functions)</h2><h3 id="字串函数"><a href="#字串函数" class="headerlink" title="字串函数"></a>字串函数</h3><p><strong>index(原字串, 找寻的子字串)</strong></p>
<p>若原字串中含有欲找寻的子字串,则返回该子字串在原字串中第一次出现的位置,若未曾出现该子字串则返回<code>0</code>.</p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN&#123; print index("8-12-94","-") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2</div></pre></td></tr></table></figure></p>
<p><strong>length(字串): 返回该字串的长度.</strong></p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN &#123; print length("John") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4</div></pre></td></tr></table></figure></p>
<p><strong>match(原字串, 用以找寻比对的正则表达式)</strong></p>
<p>awk会在原字串中找寻合乎正则表达式的子字串. 若合乎条件的子字串有多个, 则以原字串中最左方的子字串为准.</p>
<p>awk找到该字串后会依此字串为依据进行下列动作:<br>设定awk內建变量<code>RSTART</code>,<code>RLENGTH</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> RSTART =  合条件的子字串在原字串中的位置.</div><div class="line">        =  0 ; 若未找到合条件的子字串.</div><div class="line"></div><div class="line">RLENGTH = 合条件的子字串长度.</div><div class="line">        = -1 ; 若未找到合条件的子字串.</div></pre></td></tr></table></figure></p>
<p>返回 <code>RSTART</code> 之值.</p>
<p>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">' BEGIN &#123;</span></div><div class="line">    match( "banana", /(an)+/ )</div><div class="line">    print RSTART, RLENGTH</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>执行结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2 4</div></pre></td></tr></table></figure></p>
<p><strong>split(原字串, 数组名称, 分隔字符)</strong></p>
<p>awk将依所指定的分隔字符(field separator)来分隔原字串成一个个的栏位(field),并以指定的数组记录各个被分隔的栏位.</p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArgLst = &quot;5P12p89&quot;</div><div class="line">split(ArgLst, Arr, /[Pp]/)</div></pre></td></tr></table></figure></p>
<p>执行后: Arr[1]=5,  Arr[2]=12,  Arr[3]=89</p>
<p><strong>sprintf(格式字符串, 项1, 项2, …)</strong></p>
<p>该函数的用法与 awk 或 C 的输出函数<code>printf()</code>相同. 所不同的是<code>sprintf()</code>会将要求印出的结果当成一个字串返回. 一般最常使用<code>sprintf()</code>来改变资料格式. 如: x 为一数值资料, 若欲将其变成一个含二位小数的资料,可执行如下指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = 28</div><div class="line">x = sprintf(<span class="string">"%.2f"</span>,x)</div></pre></td></tr></table></figure></p>
<p>执行后 <code>x = &quot;28.00&quot;</code></p>
<p><strong>sub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p><code>sub()</code>将原字串中第一个(最左边)合乎所指定的正则表达式的子字串改以新字串取代.<br>第二个参数”将替換的新字串”中可用”<code>&amp;&quot;</code>来代表”合於条件的子字串”</p>
<p>承上例,执行下列指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = <span class="string">"a6b12anan212.45an6a"</span></div><div class="line">sub( /(an)+[0-9]*/, <span class="string">"[&amp;]"</span>, A)</div><div class="line"><span class="built_in">print</span> A</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab12[anan212].45an6a</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>不仅可执行替换(replacement)的功用,当第二个参数为空字串(“”)时,<code>sub()</code>所执行的是”去除指定字串”的功用.</p>
<p>通过<code>sub()</code>与<code>match()</code>的搭配使用,可逐次取出原字串中合乎指定条件的所有子字串.</p>
<p>例如执行下列程式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    data = "p12-P34 P56-p61"</div><div class="line">    while( match( data ,/[0-9]+/) &gt; 0) &#123;</div><div class="line">        print substr(data, RSTART, RLENGTH )</div><div class="line">        sub(/[0-9]+/,"",data)</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">12</div><div class="line">34</div><div class="line">56</div><div class="line">61</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>中第三个参数(原字串)若未指定,则其预设值为<code>$0</code>.<br>可用 <code>sub(/[9-0]+/,&quot;digital&quot;)</code> 表示<code>sub(/[0-9]+/,&quot;digital&quot;,$0 )</code></p>
<p><strong>gsub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p>这个函数与<code>sub()</code>一样,同样是进行字串取代的函数. 唯一不同点是</p>
<ul>
<li>gsub()会取代所有合条件的子字串.</li>
<li>gsub()会返回被取代的子字串个数.</li>
</ul>
<p>请参考<code>sub()</code>.</p>
<p><strong>substr(字串, 起始位置 [,长度])</strong></p>
<p>返回从起始位置起,指定长度的子字串. 若未指定长度,则返回起始位置到字串末尾的子字串.</p>
<p>执行下例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print substr("User:Wei-Lin Liu", 6)&#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wei-Lin Liu</div></pre></td></tr></table></figure></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><strong>int(x): 返回x的整数部分(去掉小数).</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int(7.8) 将返回 7</div><div class="line">int(-7.8) 将返回 -7</div></pre></td></tr></table></figure></p>
<p><strong>sqrt(x): 返回x的平方根.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqrt(9) 将返回 3</div></pre></td></tr></table></figure></p>
<p>若 x 为负数,则执行<code>sqrt(x)</code>时将造成 Run Time Error [译者注: 我这里没有发生错误,返回的是”nan”]</p>
<p><strong>exp(x): 将返回e的x次方.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exp(1) 将返回 2.71828</div></pre></td></tr></table></figure></p>
<p><strong>log(x): 将返回x以e为底的对数值.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">log</span>(exp(1))  将返回 1</div></pre></td></tr></table></figure></p>
<p>若<code>x&lt; 0</code> ,则执行<code>sqrt(x)</code>时将造成 Run Time Error. [译者注: 我这里也没有发生错误,返回的是”nan”]</p>
<p><strong>sin(x): x 须以弧度为单位, sin(x)将返回x的sin函数值.</strong></p>
<p><strong>cos(x): x 须以弧度为单位, cos(x)将返回x的cos函数值</strong></p>
<p><strong>atan2(y,x): 返回 y/x 的tan反函数之值, 返回值系以弧度为单位.</strong></p>
<p><strong>rand(): 返回介于0与1之间的(近似)随机数值; 0 &lt; rand() &lt;1.</strong></p>
<p>除非使用者自行指定<code>rand()</code>函数起始的种子, 否则每次执行awk程式时, <code>rand()</code>函数都将使用同一个內定的种子,来产生随机数.</p>
<p><strong>srand([x]): 指定以<code>x</code>为<code>rand( )</code>函数起始的种子.</strong></p>
<p>若省略了<code>x</code>,则awk会以执行时的日期与时间为<code>rand()</code>函数起始的种子.</p>
<h2 id="附录D-──-awk-的內建变量-Built-in-Variables"><a href="#附录D-──-awk-的內建变量-Built-in-Variables" class="headerlink" title="附录D ── awk 的內建变量 Built-in Variables"></a>附录D ── awk 的內建变量 Built-in Variables</h2><p>因內建变量的个数不多, 此处按其相关性分类说明, 并未按其字母顺序排列.</p>
<p><strong>ARGC</strong></p>
<p>ARGC表示命令行上除了选项<code>-F</code>, <code>-v</code>, <code>-f</code> 及其所对应的参数之外的所有参数的个数.若将”awk程式”直接写於命令列上, 则 <code>ARGC</code> 亦不将该”程式部分”列入计算.</p>
<p><strong>ARGV</strong></p>
<p>ARGV数组用以记录命令列上的参数.</p>
<p>例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="_">-f</span> prg.awk  file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="string">'&#123; print $1 * a &#125;'</span> file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>执行上列任一程式后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ARGC    =  3</div><div class="line">ARGV[0] = &quot;awk&quot;</div><div class="line">ARGV[1] = &quot;file1.dat&quot;</div><div class="line">ARGV[2] = &quot;file2.dat&quot;</div></pre></td></tr></table></figure></p>
<p>读者请留心: 当 <code>ARGC = 3</code> 时, 命令列上仅指定了 2 个文件.</p>
<p>注:</p>
<p><code>-F\t</code> 表示以 <code>tab</code> 为栏位分隔字符 <code>FS</code>(field seporator).</p>
<p><code>-v a=8</code> 是用以初始化程序中的变量<code>a</code>.</p>
<p><strong>FILENAME</strong></p>
<p>FILENAME用以表示目前正在处理的文件档名.</p>
<p><strong>FS</strong></p>
<p>栏位分隔字符.</p>
<p><strong>$0</strong></p>
<p>表示目前awk所读入的数据行.</p>
<p><strong>$1,$2..</strong></p>
<p>分別表示所读入的数据行之第一栏, 第二栏,..</p>
<p>说明:<br>当awk读入一笔数据行 <code>&quot;A123  8:15&quot;</code> 时,会先以<code>$0</code>记录.<br>故 <code>$0 = &quot;A123  8:15&quot;</code></p>
<p>若程序中进一步使用了<code>$1</code>, <code>$2</code>.. 或 <code>NF</code> 等內建变量时, awk 才会自动分割<code>$0</code>.<br>以便取得栏位相关的资料. 切割后各个栏位的资料会分別以<code>$1</code>, <code>$2</code>, <code>$3</code>…予以记录.</p>
<p>awk內定(default)的 栏位分隔字符(<code>FS</code>) 为 空白字符(空格及tab).</p>
<p>以本例而言, 读者若未改变<code>FS</code>, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1)=&quot;A123&quot;`,  第二栏($2)=&quot;8:15&quot;`.</div></pre></td></tr></table></figure></p>
<p>使用者可用正则表达式自行定义<code>FS</code>. awk每次需要分割数据行时, 会参考目前FS的值.</p>
<p>例如:<br>令<code>FS = &quot;[ :]+&quot;</code> 表示任何由 <code>空白&quot; &quot;</code> 或 <code>冒号&quot;:&quot;</code> 所组成的字串都可当成分隔字符, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1) = &quot;A123&quot;, 第二栏($2) = &quot;8&quot;, 第三栏($3) = &quot;15&quot;</div></pre></td></tr></table></figure></p>
<p><strong>NR</strong></p>
<p>NR 表从 awk 开始执行该程序后所读取的数据行数.</p>
<p><strong>FNR</strong></p>
<p><code>FNR</code> 与 <code>NR</code> 功用类似. 不同的是awk每打开一个新的文件, <code>FNR</code> 便从 0 重新累计</p>
<p><strong>NF</strong></p>
<p>NF表目前的数据行所被切分的栏位数.</p>
<p>awk 每读入一笔资料后, 在程序中可以 <code>NF</code> 来得知该行数据包含的栏位个数.在下一笔资料被读入之前, <code>NF</code> 并不会改变. 但使用者若自行使用<code>$0</code>来记录数据,例如: 使用 <code>getline</code>, 此时 <code>NF</code> 将代表新的 <code>$0</code> 上所记载的资料的栏位个数.</p>
<p><strong>OFS</strong></p>
<p><code>OFS</code>输出时的栏位分隔字符. 预设值 <code>&quot; &quot;(一个空白)</code>, 详见下面说明.</p>
<p><strong>ORS</strong></p>
<p><code>ORS</code>输出时数据行的分隔字符. 预设值 <code>&quot;\n&quot;(跳行)</code>, 见下面说明.</p>
<p><strong>OFMT</strong></p>
<p><code>OFMT</code>数值资料的输出格式. 预设值”<code>%.6g</code>“(若须要时最多印出6位小数)</p>
<p>当使用 <code>print</code> 指令一次印出多项资料时,<br>例如: <code>print $1, $2</code><br>输出时, awk会自动在 <code>$1</code> 与 <code>$2</code> 之间补上一个 <code>OFS</code> 之值  </p>
<p>每次使用 <code>print</code> 输出后, awk 会自动补上 <code>ORS</code> 之值.</p>
<p>使用 <code>print</code> 输出数值数据时, awk 将采用 <code>OFMT</code> 之值为输出格式.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print 2/3,1; OFS=":"; OFMT="%.2g"; print 2/3,1 &#125;'</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0.666667 1</div><div class="line">0.67:1</div></pre></td></tr></table></figure></p>
<p>程序中通过改变<code>OFS</code>和<code>OFMT</code>的值, 改变了指令 <code>print</code> 的输出格式.</p>
<p><strong>RS</strong></p>
<p><code>RS</code> (Record Separator): awk从文件上读取资料时, 将根据 <code>RS</code> 的定义把资料切割成许多Records,而awk一次仅读入一个Record,以进行处理.</p>
<p><code>RS</code> 的预设值是 “<code>\n</code>“. 所以一般 awk 一次仅读入一行资料.</p>
<p>有时一个Record含括了几行资料(Multi-line Record). 这情況下不能再以”<code>\n</code>“来分隔相邻的Records, 可改用 <code>空白行</code> 来分隔.<br>在awk程式中,令 <code>RS = &quot;&quot;</code> 表示以 <code>空白行</code> 来分隔相邻的Records.</p>
<p><strong>RSTART</strong></p>
<p><code>RSTART</code>与使用字串函数<code>match()</code>有关的变量,详见下面说明.</p>
<p><strong>RLENGTH</strong></p>
<p><code>RLENGTH</code>与使用字串函数<code>match()</code>有关之变量.</p>
<p>当使用者使用 <code>match(...)</code> 函数后, awk会将 <code>match(...)</code> 执行的结果以<code>RSTART</code>, <code>RLENGTH</code> 记录.<br>请参考 附录 C awk的內建函数 match().</p>
<p><strong>SUBSEP</strong></p>
<p><code>SUBSEP</code>(Subscript Separator)数组下标的分隔字符,<br>预设值为”<code>\034</code>“实际上, awk中的 数组 只接受 <code>字串</code> 当它的下标,如: <code>Arr[&quot;John&quot;]</code>.</p>
<p>但使用者在 awk 中仍可使用 <code>数字</code> 当阵列的下标, 甚至可使用多维的数组<code>(Multi-dimenisional Array)</code>如: <code>Arr[2,79]</code></p>
<p>事实上, awk 在接受<code>Arr[2,79]</code> 之前, 就已先把其下标转换成字串<code>&quot;2\03479&quot;</code>, 之后便以<code>Arr[&quot;2\03479&quot;]</code>代替<code>Arr[2,79]</code>.</p>
<p>可参考下例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'BEGIN &#123;</span></div><div class="line">    Arr[2,79] = 78</div><div class="line">    print  Arr[2,79]</div><div class="line">    print  Arr[ 2 , 79 ]</div><div class="line">    print  Arr["2\03479"]</div><div class="line">    idx = 2 SUBSEP 79</div><div class="line">    print Arr[idx]</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行结果输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">78</div><div class="line">78</div><div class="line">78</div><div class="line">78</div></pre></td></tr></table></figure></p>
<h2 id="附录E-──-正则表达式-Regular-Expression-简介"><a href="#附录E-──-正则表达式-Regular-Expression-简介" class="headerlink" title="附录E ── 正则表达式(Regular Expression) 简介"></a>附录E ── 正则表达式(Regular Expression) 简介</h2><h3 id="为什么要使用正则表达式"><a href="#为什么要使用正则表达式" class="headerlink" title="为什么要使用正则表达式"></a>为什么要使用正则表达式</h3><p>UNIX 中提供了许多 指令 和 tools, 它们具有在文件中 查找(Search)字串或替换(Replace)字串 的功能. 像 grep, vi , sed, awk,…</p>
<p>不论是查找字串或替换字串, 都得先告诉这些指令所要查找(被替换)的字串为何.若未能预先明确知道所要查找(被替换)的字串为何, 只知该字串存在的范围或特征时,例如:<br>(一) 找寻 <code>&quot;T0.c&quot;</code>,<code>&quot;T1.c&quot;</code>,<code>&quot;T2.c&quot;</code>….<code>&quot;T9.c&quot;</code> 当中的任一字串.<br>(二) 找寻至少存在一个 “A” 的任意字串.<br>这情況下, 如何告知执行查找字串的指令所要查找的字串为何.<br>例 (一) 中, 要查找任一在 “<code>T</code>“ 与 “<code>.c</code>“ 之间存在一个阿拉伯数字的字串;当然您可以列举的方式, 一一把所要找寻的字串告诉执行命令的指令. 但例 (二) 中合乎该条件的字串有无限种可能, 势必无法一一列举.此时,便需要另一种字串表示的方法(协定).</p>
<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式(以下简称 Regexp)是一种字串表达的方式. 可用以指定具有某特征的所有字串.<br>注: 为区別于一般字串, 本附录中代表 Regexp 的字串之前皆加 “Regexp”. awk 程式中常以<code>/..../</code>括住 <code>Regexp</code>; 以区別于一般字串.</p>
<h3 id="组成正则表达式的元素"><a href="#组成正则表达式的元素" class="headerlink" title="组成正则表达式的元素"></a>组成正则表达式的元素</h3><p>普通字符 除了<code>. * [ ] + ? ( ) \  ^ $</code>外之所有字符.</p>
<p>由普通字符所组成的Regexp其意义与原字串字面意义相同.<br>例如: Regexp “<code>the</code>“ 与一般字串的 “<code>the</code>“ 代表相同的意义.</p>
<p><code>.</code> (Meta character): 用以代表任意一字符.</p>
<p>须留心 UNIX Shell 中使用”<code>*</code>“表示 Wild card, 可用以代表任意长度的字串.而 Regexp 中使用 “<code>.</code>“ 来代表一个任意字符.(注意: 并非任意长度的字串)Regexp 中 “<code>*</code>“ 另有其它涵意, 并不代表任意长度的字串.</p>
<p><code>^</code> 表示该字串必须出现于行首.</p>
<p><code>$</code> 表示该字串必须出现于行末.</p>
<p>例如:<br>Regexp <code>/^The/</code> 用以表示所有出现于行首的字串 “<code>The</code>“.<br>Regexp <code>/The$/</code> 用以表示所有出现于行末字串 “<code>The</code>“.</p>
<p><code>\</code> 将特殊字符还原成字面意义的字符(Escape character)</p>
<p>Regexp 中特殊字符将被解释成特定的意义. 若要表示特殊字符的字面(literal meaning)意义时,在特殊字符之前加上”<code>\</code>“即可.</p>
<p>例如:<br>使用Regexp来表示字串 “a.out”时, 不可写成 <code>/a.out/</code>.</p>
<p>因为”<code>.</code>“是特殊字符, 表任一字符. 可符合 Regexp <code>/a.out/</code> 的字串将不只 “<code>a.out</code>“ 一个; 字串 “<code>a2out</code>“, “<code>a3out</code>“, “<code>aaout</code>“ …都符合 Regexp <code>/a.out/</code> 正确的用法为: <code>/a\.out/</code></p>
<p><code>[...]</code>字符集合, 用以表示两中括号间所有的字符当中的任一个.</p>
<p>例如:<br>Regexp <code>/[Tt]/</code> 可用以表示字符 “<code>T</code>“ 或 “<code>t</code>“. 故 Regexp <code>/[Tt]he/</code> 表示字串 “<code>The</code>“ 或 “<code>the</code>“.</p>
<p>字符集合 <code>[...]</code> 內不可随意留空白.</p>
<p>例如: Regexp <code>/[ Tt ]/</code> 其中括号內有空白字符, 除表示”<code>T</code>“, “<code>t</code>“ 中任一个字符, 也可代表一个 <code>&quot; &quot;(空白字符)</code></p>
<p><code>-</code> 字符集合中可使用 “<code>-</code>“ 来指定字符的区间, 其用法如下:<br>Regexp <code>/[0-9]/</code> 等价于 <code>/[0123456789]/</code> 用以表示任意一个阿拉伯数字.<br>同理 Regexp <code>/[A-Z]/</code> 用以表示任意一个大写英文字母.</p>
<p>但应留心:<br>Regexp <code>/[0-9a-z]/</code> 并不等于 <code>/[0-9][a-z]/</code>; 前者表示一个字符, 后者表示二个字符.<br>Regexp <code>/[-9]/</code> 或 <code>/[9-]/</code> 只代表字符 “<code>9</code>“或 “<code>-</code>“.</p>
<p><code>[^...]</code> 使用<code>[^..]</code>产生字符集合的补集(complement set).</p>
<p>其用法如下:<br>例如: 要指定 “<code>T</code>“ 或 “<code>t</code>“ 之外的任一个字符, 可用 <code>/[^Tt]/</code> 表之.<br>同理 Regexp <code>/[^a-zA-Z]/</code> 表示英文字母之外的任一个字符.</p>
<p>须留心 “<code>^</code>“ 的位置: “<code>^</code>“ 必须紧接於”<code>[</code>“之后, 才代表字符集合的补集<br>例如:Regexp <code>/[0-9\^]/</code> 只是用以表示一个阿拉伯数字或字符”<code>^</code>“.</p>
<p><code>*</code> 形容字符重复次数的特殊字符.</p>
<p>“<code>*</code>“ 形容它前方之字符可出现 1 次或多次, 或不出现(0次).</p>
<p>例如:<br>Regexp <code>/T[0-9]*\.c/</code> 中 <code>*</code> 形容其前 <code>[0-9]</code> (一个阿拉伯数字)出现的次数可为 0 次或 多次. 故Regexp <code>/T[0-9]*\.c/</code> 可用以表示”<code>T.c</code>“, “<code>T0.c</code>“, “<code>T1.c</code>“…”<code>T19.c</code>“</p>
<p><code>+</code> 形容其前的字符出现一次或一次以上.</p>
<p>例如:<br>Regexp <code>/[0-9]+/</code> 用以表示一位或一位以上的数字.</p>
<p><code>?</code> 形容其前的字符可出现一次或不出现.</p>
<p>例如:<br>Regexp <code>/[+-]?[0-9]+/</code> 表示数字(一位以上)之前可出现正负号或不出现正负号.</p>
<p><code>(...)</code> 用以括住一群字符,且将之视成一个group(见下面说明)</p>
<p>例如:<br>Regexp <code>/12+/</code> 表示字串 “<code>12</code>“, “<code>122</code>“, “<code>1222</code>“, “<code>12222</code>“,…<br>Regexp <code>/(12)+/</code> 表示字串 “<code>12</code>“, “<code>1212</code>“, “<code>121212</code>“, “<code>12121212</code>“….<br>上式中 <code>12</code> 以<code>( )</code>括住, 故 “<code>+</code>“ 所形容的是<code>12</code>, 重复出现的也是<code>12</code>.</p>
<p><code>|</code> 表示逻辑上的”<code>或</code>“(or)</p>
<p>例如:<br>Regexp <code>/Oranges?|apples?|water/</code> 可用以表示:  字串 “<code>Orange</code>“, “<code>Oranges</code>“ 或 “<code>apple</code>“, “<code>apples</code>“  或 “<code>water</code>“</p>
<h3 id="match是什么"><a href="#match是什么" class="headerlink" title="match是什么?"></a>match是什么?</h3><p>讨论 Regexp 时, 经常遇到 “某字串匹配( match )某 Regexp”的字眼. 其意思为: “这个 Regexp 可被解释成该字串”.</p>
<p>[例如]:<br>字串 “<code>the</code>“ 匹配(match) Regexp <code>/[Tt]he/</code>.<br>因为 Regexp <code>/[Tt]he/</code> 可解释成字串 “<code>the</code>“ 或 “<code>The</code>“, 故字串 “<code>the</code>“ 或 “<code>The</code>“ 都匹配(match) Regexp <code>/[Th]he/</code>.</p>
<h3 id="awk-中提供二个关系运算符-Relational-Operator-见注一"><a href="#awk-中提供二个关系运算符-Relational-Operator-见注一" class="headerlink" title="awk 中提供二个关系运算符(Relational Operator,见注一) ~ !~"></a>awk 中提供二个关系运算符(Relational Operator,见注一) <code>~</code> <code>!~</code></h3><p>它们也称之为 match, not match. 但函义与一般常称的 match 略有不同.</p>
<p>其定义如下:<br>A  表一字串, B 表一 Regular Expression<br>只要 A 字串中存在有子字串可 match (一般定义的 match) Regexp  B , 则 <code>A ~ B</code> 就算成立, 其值为 true, 反之则为 false.</p>
<p><code>!~</code> 的定义与<code>~</code>恰好相反.</p>
<p>例如:<br>“<code>another</code>“ 中含有子字串 “<code>the</code>“ 可 match Regexp <code>/[Tt]he/</code> , 所以<br><code>&quot;another&quot; ~ /[Tt]he/</code> 之值为 <code>true</code>.</p>
<p>[注一]: 有些论著不把这两个运算符( <code>~</code>, <code>!~</code>)与 Relational Operators 归为一类.</p>
<h3 id="应用-Regular-Expression-解题的简例"><a href="#应用-Regular-Expression-解题的简例" class="headerlink" title="应用 Regular Expression 解题的简例"></a>应用 Regular Expression 解题的简例</h3><p>下面列出一些应用 Regular Expression 的简例, 部分范例中会更改<code>$0</code>之值, 若您使用的 awk 不允许用户更改<code>$0</code>时, 请改用 gawk.</p>
<p>例1:<br>将文件中所有的字串 “Regular Expression” 或 “Regular expression” 换成 “Regexp”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/Regular[ \t]+[Ee]xpression/, "Regexp")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例2:<br>去除文件中的空白行(或仅含空白字符或tab的行)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'$0 !~ /^[ \t]*$/ &#123; print &#125;'</span> $*</div></pre></td></tr></table></figure></p>
<p>例3:<br>在文件中具有 <code>ddd-dddd</code> (电话号码型态,<code>d</code>表<code>digital</code>)的字串前加上”<code>TEL:</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]/, "TEL: &amp;")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例4:<br>从文件的 Fullname 中分离出 路径 与 档名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    Fullname = "/usr/local/bin/xdvi"</div><div class="line">    match(Fullname, /.*\//)</div><div class="line">    path = substr(Fullname, 1, RLENGTH-1)</div><div class="line">    name = substr(Fullname, RLENGTH+1)</div><div class="line">    print "path :", path, "  name :", name</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path : /usr/local/bin   name : xdvi</div></pre></td></tr></table></figure></p>
<p>例5:<br>将某一数值改以现金表示法表示(整数部分每三位加一撇,且含二位小数)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Number = 123456789</div><div class="line">    Number = sprintf("$%.2f",Number)</div><div class="line">    while(match(Number, /[0-9][0-9][0-9][0-9]/))</div><div class="line">        sub(/[0-9][0-9][0-9][.,]/, ",&amp;", Number)</div><div class="line">    print Number</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$123,456,789.00</div></pre></td></tr></table></figure></p>
<p>例6:<br>把文件中所有具”<code>program数字.f</code>“形态的字串改为”<code>[Ref: program数字.c]</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    while(match($0, /program[0-9]+\.f/)) &#123;</div><div class="line">        Replace = "[Ref: "substr($0, RSTART, RLENGTH-2)".c]"</div><div class="line">        sub( /program[0-9]+\.f/, Replace)</div><div class="line">    &#125;</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[跟我一起写Makefile]]></title>
      <url>https://jarsonfang.github.io/uncategorized/how-to-write-makefile/</url>
      <content type="html"><![CDATA[<p><a href="https://seisman.info/how-to-write-makefile.html" target="_blank" rel="external">PDF 重制版</a><br><a href="/uncategorized/how-to-write-makefile/how-to-write-makefile.pdf" title="文档下载">文档下载</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://jarsonfang.github.io/tools/Hexo/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用git保存空目录]]></title>
      <url>https://jarsonfang.github.io/tools/VCS/git-save-empty-dir/</url>
      <content type="html"><![CDATA[<p>git 和 svn 不同，仅仅跟踪文件的变动，不跟踪目录。Perforce 也是如此。所以，一个空目录，如果里面没有文件，即便 git add 这个目录，另外在别处 check out 的时候，是没有这个空目录的。</p>
<p>只跟踪文件变化，不跟踪目录，这么设计是有原因的。但这会带来一些小麻烦。有时候，确实需要在代码仓库中保留某个空目录。比如测试时需要用到的空目录。</p>
<p>变通的解决办法是在空目录下存一个 <code>.gitignore</code> 文件。然后 <code>git add</code> 此目录后，相当于跟踪了 <code>.gitignore</code> 文件，产生的“副作用”就是这个“空”目录也纳入“跟踪”，最终的效果是可以 check out 出一个看起来空空的目录。如果有许多这样的空目录，可以用下面的命令自动补充 <code>.gitignore</code> 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . \( -type d -empty \) -and \( -not -regex ./\.git.* \) -exec touch &#123;&#125;/.gitignore \;</div></pre></td></tr></table></figure></p>
<p>递归找寻当前目录下，类型为目录，且为空，也没有 <code>.git</code> 开头的文件，在其中用 touch 新建一个空的 <code>.gitignore</code> 文件。然后 <code>git add .</code> 之后即可。</p>
<p>如果这些特殊文件会对测试带来干扰，那就只好在测试程序运行具体测试项目之前，先跑一段初始化目录结构的代码。另外可能还需要编写负责清理的代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 3.10 ARM Device Tree 的初始化]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91/linux-3-10-arm-device-tree/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.chinaunix.net/uid-20522771-id-3785808.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3785808.html</a></p>
<p>本文代码均来自标准 linux kernel 3.10，可以到这里下载 <a href="https://www.kernel.org/" target="_blank" rel="external">https://www.kernel.org/</a><br>以 arch/arm/mach-msm/board-dt-8960.c 为例，在该文件中的<code>msm_dt_init</code>函数的作用就是利用 dt（device tree）结构初始化 platform device。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">msm_dt_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    of_platform_populate(<span class="literal">NULL</span>, of_default_bus_match_table, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><code>of_platform_populate</code> 实现在 drivers/of/platform.c，是 OF 的标准函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_platform_populate</span><span class="params">(<span class="keyword">struct</span> device_node *root,</span></span></div><div class="line">                         <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *matches,</div><div class="line">                         <span class="keyword">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,</div><div class="line">                         <span class="keyword">struct</span> device *parent)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> device_node *child;</div><div class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    root = root ? of_node_get(root) : of_find_node_by_path(<span class="string">"/"</span>);</div><div class="line">    <span class="keyword">if</span> (!root)</div><div class="line">        <span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">    for_each_child_of_node(root, child) &#123;</div><div class="line">        rc = of_platform_bus_create(child, matches, lookup, parent, <span class="literal">true</span>);</div><div class="line">        <span class="keyword">if</span> (rc)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    of_node_put(root);</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中<code>of_platform_populate</code>函数的注释写得很明白：“Populate platform_devices from device tree data”。但是这个“device tree data”又是从那里来的呢？<br>在<code>of_platform_populate</code>中如果 root 为 NULL，则将 root 赋值为根节点，这个根节点是用<code>of_find_node_by_path</code>取到的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> device_node *<span class="title">of_find_node_by_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> device_node *np = of_allnodes;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">    raw_spin_lock_irqsave(&amp;devtree_lock, flags);</div><div class="line">    <span class="keyword">for</span> (; np; np = np-&gt;allnext) &#123;</div><div class="line">        <span class="keyword">if</span> (np-&gt;full_name &amp;&amp; (of_node_cmp(np-&gt;full_name, path) == <span class="number">0</span>)</div><div class="line">            &amp;&amp; of_node_get(np))</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    raw_spin_unlock_irqrestore(&amp;devtree_lock, flags);</div><div class="line">    <span class="keyword">return</span> np;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个函数中有一个很关键的全局变量：<code>of_allnodes</code>，它的定义是在 drivers/of/base.c 里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_node *of_allnodes;</div></pre></td></tr></table></figure></p>
<p>这应该所就是那个所谓的“device tree data”了。它应该指向了 device tree 的根节点。问题又来了，这个<code>of_allnodes</code>又是咋来的呢？我们知道 device tree 是由 DTC（Device Tree Compiler）编译成二进制文件 DTB（Ddevice Tree Blob）的，然后在系统上电之后由 bootloader 加载到内存中去，这个时候还没有 device tree，而在内存中只有一个所谓的 DTB，这只是一个以某个内存地址开始的一堆原始的 dt 数据，没有树结构。kernel 的任务需要把这些数据转换成一个树结构然后再把这棵树的根节点的地址赋值给 of_allnodes 就行了。这个过程一定是非常重要，因为没有这个 device tree 那所有的设备就没办法初始化，所以这个 dt 树的形成一定在 kernel 刚刚启动的时候就完成了。<br>既然如此，我们来看看 kernel 初始化的代码（init/main.c），大部分代码与本主题无关用 … 代替。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">asmlinkage <span class="keyword">void</span> __<span class="function">init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    setup_arch(&amp;command_line);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>setup_arch</code> 就是各个架构自己的设置函数（arch 是 architecture 的缩写），哪个参与了编译就调用哪个，在本文中应当是 arch/arm/kernel/setup.c 中的 setup_arch。<br>同样，无关的代码以 … 代替。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    mdesc = setup_machine_fdt(__atags_pointer);</div><div class="line">    ...</div><div class="line">    unflatten_device_tree();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到了吧，<code>setup_machine_fdt</code>，其中 fdt 的 f 就是扁平（flat）的意思。这个时候 DTB 只是加载到内存中的 .dtb 文件而已，这个文件中不仅包含数据结构，还包含了一些文件头等信息，kernel 需要从这些信息中获取到数据结构相关的信息，然后再生成设备树。这个函数的调用还有个参数 <code>__atags_pointer</code>，看名字似乎这是一个指针，干嘛的呢？以后再说，先进入函数看看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* kernel/arch/arm/kernel/devtree.c */</span></div><div class="line"><span class="keyword">struct</span> machine_desc * __<span class="function">init <span class="title">setup_machine_fdt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> dt_phys)</span></span></div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    devtree = phys_to_virt(dt_phys);</div><div class="line">    ...</div><div class="line">    initial_boot_params = devtree;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在有点意思了，<code>phys_to_virt</code>字面上的意思是物理地址转换成虚拟地址，那就是说<code>__atags_pointer</code>是一个物理地址，这就印证了我们的猜测，<code>__atags_pointer</code>的确是一个指针，再看变量 devtree 它指向了一个<code>struct boot_param_header</code>结构体。随后 kernel 把这个指针赋给了全局变量<code>initial_boot_params</code>。也就是说以后 kernel 会是用这个指针指向的数据去初始化 device tree。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> boot_param_header &#123;</div><div class="line">    __be32 magic; <span class="comment">/* magic word OF_DT_HEADER */</span></div><div class="line">    __be32 totalsize; <span class="comment">/* total size of DT block */</span></div><div class="line">    __be32 off_dt_struct; <span class="comment">/* offset to structure */</span></div><div class="line">    __be32 off_dt_strings; <span class="comment">/* offset to strings */</span></div><div class="line">    __be32 off_mem_rsvmap; <span class="comment">/* offset to memory reserve map */</span></div><div class="line">    __be32 version; <span class="comment">/* format version */</span></div><div class="line">    __be32 last_comp_version; <span class="comment">/* last compatible version */</span></div><div class="line">    <span class="comment">/* version 2 fields below */</span></div><div class="line">    __be32 boot_cpuid_phys; <span class="comment">/* Physical CPU id we're booting on */</span></div><div class="line">    <span class="comment">/* version 3 fields below */</span></div><div class="line">    __be32 dt_strings_size; <span class="comment">/* size of the DT strings block */</span></div><div class="line">    <span class="comment">/* version 17 fields below */</span></div><div class="line">    __be32 dt_struct_size; <span class="comment">/* size of the DT structure block */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<pre><code>看这个结构体，很像之前所说的文件头，有魔数、大小、数据结构偏移量、版本等等，kernel 就应该通过这个结构获取数据，并最终生成设备树。现在回到 `setup_arch`，果然在随后的代码中有这么一个函数。
</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* kernel/drivers/of/fdt.c */</span></div><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    __unflatten_device_tree(initial_boot_params, &amp;of_allnodes,</div><div class="line">                early_init_dt_alloc_memory_arch);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>看见了吧，`of_allnodes`就是在这里赋值的，device tree 也是在这里建立完成的。`__unflatten_device_tree` 函数我们就不去深究了，推测其功能应该就是解析数据、申请内存、填充结构等等。
到此为止，device tree 的初始化就算完成了，在以后的启动过程中，kernel 就会依据这个 dt 来初始化各个设备。但是还有一个小问题，那就是在 `setup_arch` 函数中 `__atags_pointer` 从何而来。全局搜索这个变量，结构在 arch/arm/kernel/head-common.S 中发现了它的踪迹。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#define ATAG_CORE 0x54410001</div><div class="line">...</div><div class="line">__mmap_switched:</div><div class="line">    adr r3, __mmap_switched_data</div><div class="line"></div><div class="line">    ldmia &#123;r4, r5, r6, r7&#125;</div><div class="line">    ...</div><div class="line">    THUMB( ldr sp, [r3, #16] )</div><div class="line">    ...</div><div class="line">    str r2, [r6] @ Save atags pointer</div><div class="line">    ...</div><div class="line">__mmap_switched_data:</div><div class="line">    ...</div><div class="line">    .long __atags_pointer @ r6</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>arm 汇编不懂，大概能看出来给 <code>__atags_pointer</code> 赋值的过程（‘@’之后是注释）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Device Tree（三）：代码分析]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91/dt-code-analysis/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html" target="_blank" rel="external">http://www.wowotech.net/linux_kenrel/dt-code-analysis.html</a><br>转自：<a href="www.wowotech.net">蜗窝科技</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Device Tree总共有三篇，分别是：</p>
<p>1、为何要引入Device Tree，这个机制是用来解决什么问题的？（请参考<a href="http://www.wowotech.net/linux_kenrel/why-dt.html" target="_blank" rel="external">引入Device Tree的原因</a>）<br>2、Device Tree的基础概念（请参考<a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html" target="_blank" rel="external">DT基础概念</a>）<br>3、ARM linux中和Device Tree相关的代码分析（这是本文的主题）</p>
<p>本文主要内容是：以Device Tree相关的数据流分析为索引，对ARM linux kernel的代码进行解析。主要的数据流包括：</p>
<p>1、初始化流程。也就是扫描dtb并将其转换成Device Tree Structure。<br>2、运行时参数传递以及platform的识别流程分析<br>3、如何将Device Tree Structure并入linux kernel的设备驱动模型。</p>
<p>注：本文中的linux kernel使用的是3.14版本。<br><a id="more"></a></p>
<h2 id="如何通过Device-Tree实现运行时参数传递以及platform的识别？"><a href="#如何通过Device-Tree实现运行时参数传递以及platform的识别？" class="headerlink" title="如何通过Device Tree实现运行时参数传递以及platform的识别？"></a>如何通过Device Tree实现运行时参数传递以及platform的识别？</h2><h3 id="汇编部分的代码分析"><a href="#汇编部分的代码分析" class="headerlink" title="汇编部分的代码分析"></a>汇编部分的代码分析</h3><p>linux/arch/arm/kernel/head.S文件定义了bootloader和kernel的参数传递要求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MMU = off, D-cache = off, I-cache = dont care, r0 = 0, r1 = machine nr, r2 = atags or dtb pointer.</div></pre></td></tr></table></figure></p>
<p>目前的kernel支持旧的tag list的方式，同时也支持device tree的方式。<code>r2</code>可能是device tree binary file的指针（bootloader在传递给内核之前要copy到memory中），也可以能是tag list的指针。在ARM的汇编部分的启动代码中（主要是head.S和head-common.S），machine type ID和指向DTB或者atags的指针被保存在变量<code>__machine_arch_type</code>和<code>__atags_pointer</code>中，这么做是为了后续c代码进行处理。</p>
<h3 id="和device-tree相关的setup-arch代码分析"><a href="#和device-tree相关的setup-arch代码分析" class="headerlink" title="和device tree相关的setup_arch代码分析"></a>和device tree相关的setup_arch代码分析</h3><p>具体的c代码都是在<code>setup_arch</code>中处理，这个函数是一个总的入口点。具体代码如下（删除了部分无关代码）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">setup_arch</span><span class="params">(<span class="keyword">char</span> **cmdline_p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc;</div><div class="line">    ……</div><div class="line">    mdesc = setup_machine_fdt(__atags_pointer);</div><div class="line">    <span class="keyword">if</span> (!mdesc)</div><div class="line">        mdesc = setup_machine_tags(__atags_pointer, __machine_arch_type);</div><div class="line">    machine_desc = mdesc;</div><div class="line">    machine_name = mdesc-&gt;name;</div><div class="line">    ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于如何确定HW platform这个问题，旧的方法是静态定义若干的machine描述符（<code>struct machine_desc</code>），在启动过程中，通过machine type ID作为索引，在这些静态定义的machine描述符中扫描，找到那个ID匹配的描述符。在新的内核中，首先使用<code>setup_machine_fdt</code>来setup machine描述符，如果返回NULL，才使用传统的方法<code>setup_machine_tags</code>来setup machine描述符。传统的方法需要给出<code>__machine_arch_type</code>（bootloader通过<code>r1</code>寄存器传递给kernel）和tag list的地址（用来进行tag parse）。<code>__machine_arch_type</code>用来寻找machine描述符；tag list用于运行时参数的传递。随着内核的不断发展，相信有一天linux kernel会完全抛弃tag list的机制。</p>
<h3 id="匹配platform（machine描述符）"><a href="#匹配platform（machine描述符）" class="headerlink" title="匹配platform（machine描述符）"></a>匹配platform（machine描述符）</h3><p><code>setup_machine_fdt</code>函数的功能就是根据Device Tree的信息，找到最适合的machine描述符。具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> machine_desc * __<span class="function">init <span class="title">setup_machine_fdt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> dt_phys)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc, *mdesc_best = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!mdesc) &#123;</div><div class="line">        <span class="comment">/* 出错处理 */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Change machine number to match the mdesc we're using */</span></div><div class="line">    __machine_arch_type = mdesc-&gt;nr;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mdesc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>early_init_dt_scan</code>函数有两个功能，一个是为后续的DTB scan进行准备工作，另外一个是运行时参数传递。具体请参考下面一个section的描述。</p>
<p><code>of_flat_dt_match_machine</code>是在machine描述符的列表中scan，找到最合适的那个machine描述符。我们首先看如何组成machine描述符的列表。和传统的方法类似，也是静态定义的。<code>DT_MACHINE_START</code>和<code>MACHINE_END</code>用来定义一个machine描述符。编译的时候，compiler会把这些machine descriptor放到一个特殊的段中（<code>.arch.info.init</code>），形成machine描述符的列表。machine描述符用下面的数据结构来标识（删除了不相关的member）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> machine_desc &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        nr;         <span class="comment">/* architecture number */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span>   *dt_compat; <span class="comment">/* array of device tree 'compatible' strings */</span></div><div class="line">    ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>nr</code>成员就是过去使用的machine type ID。内核machine描述符的table有若干个entry，每个都有自己的ID。bootloader传递了machine type ID，指明使用哪一个machine描述符。目前匹配machine描述符使用compatible strings，也就是<code>dt_compat</code>成员，这是一个string list，定义了这个machine所支持的列表。在扫描machine描述符列表的时候需要不断的获取下一个machine描述符的compatible字符串的信息，具体的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * __<span class="function">init <span class="title">arch_get_next_mach</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> **match)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *mdesc = __arch_info_begin;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> machine_desc *m = mdesc;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m &gt;= __arch_info_end)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    mdesc++;</div><div class="line">    *match = m-&gt;dt_compat;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>__arch_info_begin</code>指向machine描述符列表第一个entry。通过<code>mdesc++</code>不断的移动machine描述符指针（Note：<code>mdesc</code>是static的）。<code>match</code>返回了该machine描述符的compatible string list。具体匹配的算法倒是很简单，就是比较字符串而已，一个是root node的compatible字符串列表，一个是machine描述符的compatible字符串列表，得分最低的（最匹配的）就是我们最终选定的machine type。</p>
<h3 id="运行时参数传递"><a href="#运行时参数传递" class="headerlink" title="运行时参数传递"></a>运行时参数传递</h3><p>运行时参数是在扫描DTB的<code>chosen node</code>时候完成的，具体的动作就是获取<code>chosen node</code>的<code>bootargs</code>、<code>initrd</code>等属性的value，并将其保存在全局变量（<code>boot_command_line</code>、<code>initrd_start</code>、<code>initrd_end</code>）中。使用tag list的方法是类似的，通过分析tag list，获取相关信息，保存在同样的全局变量中。具体代码位于<code>early_init_dt_scan</code>函数中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> __<span class="function">init <span class="title">early_init_dt_scan</span><span class="params">(<span class="keyword">void</span> *params)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!params)</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 全局变量initial_boot_params指向了DTB的header */</span></div><div class="line">    initial_boot_params = params;</div><div class="line"></div><div class="line">    <span class="comment">/* 检查DTB的magic，确认是一个有效的DTB */</span></div><div class="line">    <span class="keyword">if</span> (be32_to_cpu(initial_boot_params-&gt;magic) != OF_DT_HEADER) &#123;</div><div class="line">        initial_boot_params = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描 /chosen node，保存运行时参数（bootargs）到boot_command_line，</span></div><div class="line">     * 此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描根节点，获取 &#123;size,address&#125;-cells信息，</span></div><div class="line">     * 并保存在dt_root_size_cells和dt_root_addr_cells全局变量中</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 扫描DTB中的memory node，并把相关信息保存在meminfo中，</span></div><div class="line">     * 全局变量meminfo保存了系统内存相关的信息。</div><div class="line">     */</div><div class="line">    of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设定meminfo（该全局变量确定了物理内存的布局）有若干种途径：</p>
<p>1、通过tag list（tag是ATAG_MEM）传递memory bank的信息。<br>2、通过command line（可以用tag list，也可以通过DTB）传递memory bank的信息。<br>3、通过DTB的memory node传递memory bank的信息。</p>
<p>目前当然是推荐使用Device Tree的方式来传递物理内存布局信息。</p>
<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><p>在系统初始化的过程中，我们需要将DTB转换成节点是<code>device_node</code>的树状结构，以便后续方便操作。具体的代码位于<code>setup_arch-&gt;unflatten_device_tree</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">unflatten_device_tree</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    __unflatten_device_tree(initial_boot_params, &amp;of_allnodes,</div><div class="line">                early_init_dt_alloc_memory_arch);</div><div class="line"></div><div class="line">    <span class="comment">/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */</span></div><div class="line">    of_alias_scan(early_init_dt_alloc_memory_arch);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们用<code>struct device_node</code>来抽象设备树中的一个节点，具体解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_node &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;               <span class="comment">/* device node name */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;               <span class="comment">/* 对应device_type的属性 */</span></div><div class="line">    phandle phandle;                <span class="comment">/* 对应该节点的phandle属性 */</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *full_name;          <span class="comment">/* 从“/”开始的，表示该node的full path */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span>    property *properties; <span class="comment">/* 该节点的属性列表 */</span></div><div class="line">    <span class="keyword">struct</span>    property *deadprops;  <span class="comment">/* 如果需要删除某些属性，kernel并非真的删除，而是挂入到deadprops的列表 */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *parent;  <span class="comment">/* parent、child以及sibling将所有的device node连接起来 */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *child;</div><div class="line">    <span class="keyword">struct</span>    device_node *sibling;</div><div class="line">    <span class="keyword">struct</span>    device_node *next;    <span class="comment">/* 通过该指针可以获取相同类型的下一个node */</span></div><div class="line">    <span class="keyword">struct</span>    device_node *allnext; <span class="comment">/* 通过该指针可以获取node global list下一个node */</span></div><div class="line">    <span class="keyword">struct</span>    proc_dir_entry *pde;  <span class="comment">/* 开放到userspace的proc接口信息 */</span></div><div class="line">    <span class="keyword">struct</span>    kref kref;            <span class="comment">/* 该node的reference count */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _flags;</div><div class="line">    <span class="keyword">void</span>    *data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>unflatten_device_tree</code>函数的主要功能就是扫描DTB，将device node组织成：</p>
<p>1、global list。全局变量<code>struct device_node *of_allnodes</code>就是指向设备树的global list<br>2、tree。</p>
<p>这些功能主要是在<code>__unflatten_device_tree</code>函数中实现，具体代码如下（去掉一些无关紧要的代码）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __unflatten_device_tree(<span class="keyword">struct</span> boot_param_header *blob, <span class="comment">/* 需要扫描的DTB */</span></div><div class="line">                 <span class="keyword">struct</span> device_node **mynodes,                      <span class="comment">/* global list指针 */</span></div><div class="line">                 <span class="keyword">void</span> * (*dt_alloc)(u64 size, u64 align))           <span class="comment">/* 内存分配函数 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">    <span class="keyword">void</span> *start, *mem;</div><div class="line">    <span class="keyword">struct</span> device_node **allnextp = mynodes;</div><div class="line"></div><div class="line">    <span class="comment">/* 此处删除了health check代码，例如检查DTB header的magic，确认blob的确指向一个DTB。 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* scan过程分成两轮，第一轮主要是确定device-tree structure的长度，保存在size变量中 */</span></div><div class="line">    start = ((<span class="keyword">void</span> *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);</div><div class="line">    size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)unflatten_dt_node(blob, <span class="number">0</span>, &amp;start, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line">    size = ALIGN(size, <span class="number">4</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 初始化的时候，并不是扫描到一个node或者property就分配相应的内存，</span></div><div class="line">     * 实际上内核是一次性的分配了一大片内存，这些内存包括了所有的</div><div class="line">     * struct device_node、node name、struct property所需要的内存。</div><div class="line">     */</div><div class="line">    mem = dt_alloc(size + <span class="number">4</span>, __alignof__(<span class="keyword">struct</span> device_node));</div><div class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, size);</div><div class="line"></div><div class="line">    *(__be32 *)(mem + size) = cpu_to_be32(<span class="number">0xdeadbeef</span>); <span class="comment">/* 用来检验后面unflattening是否溢出 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* 这是第二轮的scan，第一次scan是为了得到保存所有node和property所需要的内存size，</span></div><div class="line">     * 第二次就是实打实的要构建device node tree了</div><div class="line">     */</div><div class="line">    start = ((<span class="keyword">void</span> *)blob) + be32_to_cpu(blob-&gt;off_dt_struct);</div><div class="line">    unflatten_dt_node(blob, mem, &amp;start, <span class="literal">NULL</span>, &amp;allnextp, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* 此处略去校验溢出和校验OF_DT_END。 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体的scan是在<code>unflatten_dt_node</code>函数中，如果已经清楚地了解DTB的结构，其实代码很简单，这里就不再细述了。</p>
<h2 id="如何并入linux-kernel的设备驱动模型"><a href="#如何并入linux-kernel的设备驱动模型" class="headerlink" title="如何并入linux kernel的设备驱动模型"></a>如何并入linux kernel的设备驱动模型</h2><p>在linux kernel引入统一设备模型之后，<code>bus</code>、<code>driver</code>和<code>device</code>形成了设备模型中的铁三角。在驱动初始化的时候会将代表该driver的一个数据结构（一般是<code>xxx_driver</code>）挂入bus上的driver链表。device挂入链表分成两种情况，一种是即插即用类型的bus，在插入一个设备后，总线可以检测到这个行为并动态分配一个device数据结构（一般是<code>xxx_device</code>，例如usb_device），之后，将该数据结构挂入bus上的device链表。bus上挂满了driver和device，那么如何让device遇到“对”的那个driver呢？那么就要靠缘分了，也就是bus的<code>match</code>函数。</p>
<p>上面是一段导论，我们还是回到Device Tree。导致Device Tree的引入ARM体系结构的代码其中一个最重要的原因的太多的静态定义的表格。例如：一般代码中会定义一个<code>static struct platform_device *xxx_devices</code>的静态数组，在初始化的时候调用<code>platform_add_devices</code>。这些静态定义的<code>platform_device</code>往往又需要静态定义各种<code>resource</code>，这导致静态表格进一步增大。如果ARM linux中不再定义这些表格，那么一定需要一个转换的过程，也就是说，系统应该会根据Device tree来动态的增加系统中的platform_device。当然，这个过程并非只是发生在platform bus上（具体可以参考<a href="http://www.wowotech.net/linux_kenrel/platform_device.html" target="_blank" rel="external">“Platform Device”的设备</a>），也可能发生在其他的非即插即用的bus上，例如AMBA总线、PCI总线。一言以蔽之，如果要并入linux kernel的设备驱动模型，那么就需要根据<code>device_node</code>的树状结构（root是<code>of_allnodes</code>）将一个个的device node挂入到相应的总线device链表中。只要做到这一点，总线机制就会安排device和driver的约会。</p>
<p>当然，也不是所有的device node都会挂入bus上的设备链表，比如cpus node，memory node，choose node等。</p>
<h3 id="cpus-node的处理"><a href="#cpus-node的处理" class="headerlink" title="cpus node的处理"></a>cpus node的处理</h3><p>这部分的处理可以参考<code>setup_arch-&gt;arm_dt_init_cpu_maps</code>中的代码，具体的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">arm_dt_init_cpu_maps</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">/* scan device node global list，寻找full path是“/cpus”的那个device node。</span></div><div class="line">     * cpus这个device node只是一个容器，其中包括了各个cpu node的定义以及所有cpu node共享的property。</div><div class="line">     */</div><div class="line">    cpus = of_find_node_by_path(<span class="string">"/cpus"</span>);</div><div class="line"></div><div class="line">    for_each_child_of_node(cpus, cpu) &#123;       <span class="comment">/* 遍历cpus的所有的child node */</span></div><div class="line">        u32 hwid;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (of_node_cmp(cpu-&gt;type, <span class="string">"cpu"</span>))    <span class="comment">/* 我们只关心那些device_type是cpu的node */</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (of_property_read_u32(cpu, <span class="string">"reg"</span>, &amp;hwid)) &#123; <span class="comment">/* 读取reg属性的值并赋值给hwid */</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* reg的属性值的8 MSBs必须设置为0，这是ARM CPU binding定义的。 */</span></div><div class="line">        <span class="keyword">if</span> (hwid &amp; ~MPIDR_HWID_BITMASK)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* 不允许重复的CPU id，那是一个灾难性的设定 */</span></div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; cpuidx; j++)</div><div class="line">            <span class="keyword">if</span> (WARN(tmp_map[j] == hwid, <span class="string">"Duplicate /cpu reg "</span></div><div class="line">                             <span class="string">"properties in the DT\n"</span>))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">/* 数组tmp_map保存了系统中所有CPU的MPIDR值（CPU ID值），</span></div><div class="line">         * 具体的index的编码规则是： tmp_map[0]保存了booting CPU的id值，</div><div class="line">         * 其余的CPU的ID值保存在1～NR_CPUS的位置。</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (hwid == mpidr) &#123;</div><div class="line">            i = <span class="number">0</span>;</div><div class="line">            bootcpu_valid = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            i = cpuidx++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tmp_map[i] = hwid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 根据DTB中的信息设定cpu logical map数组。 */</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cpuidx; i++) &#123;</div><div class="line">        set_cpu_possible(i, <span class="literal">true</span>);</div><div class="line">        cpu_logical_map(i) = tmp_map[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要理解这部分的内容，需要理解ARM CUPs binding的概念，可以参考linux/Documentation/devicetree/bindings/arm目录下的CPU.txt文件的描述。</p>
<h3 id="memory的处理"><a href="#memory的处理" class="headerlink" title="memory的处理"></a>memory的处理</h3><p>这部分的处理可以参考<code>setup_arch-&gt;setup_machine_fdt-&gt;early_init_dt_scan-&gt;early_init_dt_scan_memory</code>中的代码。具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">early_init_dt_scan_memory</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> node, <span class="keyword">const</span> <span class="keyword">char</span> *uname,</span></span></div><div class="line">                     <span class="keyword">int</span> depth, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *type = of_get_flat_dt_prop(node, <span class="string">"device_type"</span>, <span class="literal">NULL</span>); <span class="comment">/* 获取device_type属性值 */</span></div><div class="line">    __be32 *reg, *endp;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> l;</div><div class="line"></div><div class="line">    <span class="comment">/* 在初始化的时候，我们会对每一个device node都要调用该call back函数，</span></div><div class="line">     * 因此，我们要过滤掉那些和memory block定义无关的node。</div><div class="line">     * 和memory block定义有的节点有两种，一种是node name是memory@形态的，</div><div class="line">     * 另外一种是node中定义了device_type属性并且其值是memory。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (type == <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (depth != <span class="number">1</span> || <span class="built_in">strcmp</span>(uname, <span class="string">"memory@0"</span>) != <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">"memory"</span>) != <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 获取memory的起始地址和length的信息。</span></div><div class="line">     * 有两种属性和该信息有关，一个是linux,usable-memory，</div><div class="line">     * 不过最新的方式还是使用reg属性。</div><div class="line">     */</div><div class="line">    reg = of_get_flat_dt_prop(node, <span class="string">"linux,usable-memory"</span>, &amp;l);</div><div class="line">    <span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</div><div class="line">        reg = of_get_flat_dt_prop(node, <span class="string">"reg"</span>, &amp;l);</div><div class="line">    <span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    endp = reg + (l / <span class="keyword">sizeof</span>(__be32));</div><div class="line"></div><div class="line">    <span class="comment">/* reg属性的值是address，size数组，那么如何来取出一个个的address/size呢？</span></div><div class="line">     * 由于memory node一定是root node的child，因此dt_root_addr_cells（root node的#address-cells属性值）</div><div class="line">     * 和dt_root_size_cells（root node的#size-cells属性值）之和就是address，size数组的entry size。</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123;</div><div class="line">        u64 base, size;</div><div class="line"></div><div class="line">        base = dt_mem_next_cell(dt_root_addr_cells, &amp;reg;);</div><div class="line">        size = dt_mem_next_cell(dt_root_size_cells, &amp;reg;);</div><div class="line"></div><div class="line">        early_init_dt_add_memory_arch(base, size);  <span class="comment">/* 将具体的memory block信息加入到内核中。 */</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="interrupt-controller的处理"><a href="#interrupt-controller的处理" class="headerlink" title="interrupt controller的处理"></a>interrupt controller的处理</h3><p>初始化是通过<code>start_kernel-&gt;init_IRQ-&gt;machine_desc-&gt;init_irq()</code>实现的。我们用S3C2416为例来描述interrupt controller的处理过程。下面是machine描述符的定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DT_MACHINE_START(S3C2416_DT, <span class="string">"Samsung S3C2416 (Flattened Device Tree)"</span>)</div><div class="line">    ……</div><div class="line">    .init_irq    = irqchip_init,</div><div class="line">    ……</div><div class="line">MACHINE_END</div></pre></td></tr></table></figure></p>
<p>在driver/irqchip/irq-s3c24xx.c文件中定义了两个interrupt controller，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IRQCHIP_DECLARE(s3c2416_irq, <span class="string">"samsung,s3c2416-irq"</span>, s3c2416_init_intc_of);</div><div class="line">IRQCHIP_DECLARE(s3c2410_irq, <span class="string">"samsung,s3c2410-irq"</span>, s3c2410_init_intc_of);</div></pre></td></tr></table></figure></p>
<p>当然，系统中可以定义更多的irqchip，不过具体用哪一个是根据DTB中的interrupt controller node中的compatible属性确定的。在driver/irqchip/irqchip.c文件中定义了irqchip_init函数，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">irqchip_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    of_irq_init(__irqchip_begin);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>__irqchip_begin</code>就是所有的irqchip的一个列表，<code>of_irq_init</code>函数是遍历Device Tree，找到匹配的irqchip。具体的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">of_irq_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> device_node *np, *parent = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">struct</span> intc_desc *desc, *temp_desc;</div><div class="line">    <span class="keyword">struct</span> list_head intc_desc_list, intc_parent_list;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&amp;intc_desc_list);</div><div class="line">    INIT_LIST_HEAD(&amp;intc_parent_list);</div><div class="line"></div><div class="line">    <span class="comment">/* 遍历所有的node，寻找定义了interrupt-controller属性的node，</span></div><div class="line">     * 如果定义了interrupt-controller属性则说明该node就是一个中断控制器。</div><div class="line">     */</div><div class="line">    for_each_matching_node(np, matches) &#123;</div><div class="line">        <span class="keyword">if</span> (!of_find_property(np, <span class="string">"interrupt-controller"</span>, <span class="literal">NULL</span>) ||</div><div class="line">                !of_device_is_available(np))</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">     <span class="comment">/* 分配内存并挂入链表，当然还有根据interrupt-parent建立controller之间的父子关系。</span></div><div class="line">      * 对于interrupt controller，它也可能是一个树状的结构。</div><div class="line">      */</div><div class="line">        desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);</div><div class="line">        <span class="keyword">if</span> (WARN_ON(!desc))</div><div class="line">            <span class="keyword">goto</span> err;</div><div class="line"></div><div class="line">        desc-&gt;dev = np;</div><div class="line">        desc-&gt;interrupt_parent = of_irq_find_parent(np);</div><div class="line">        <span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</div><div class="line">            desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</div><div class="line">        list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 正因为interrupt controller被组织成树状的结构，因此初始化的顺序就需要控制，</span></div><div class="line">     * 应该从根节点开始，依次递进到下一个level的interrupt controller。</div><div class="line">     */</div><div class="line">    <span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</div><div class="line">        <span class="comment">/* intc_desc_list链表中的节点会被一个个的处理，</span></div><div class="line">         * 每处理完一个节点就会将该节点删除，当所有的节点被删除，整个处理过程也就是结束了。</div><div class="line">         */</div><div class="line">        list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</div><div class="line">            <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *match;</div><div class="line">            <span class="keyword">int</span> ret;</div><div class="line">            <span class="keyword">of_irq_init_cb_t</span> irq_init_cb;</div><div class="line"></div><div class="line">            <span class="comment">/* 最开始的时候parent变量是NULL，确保第一个被处理的是root interrupt controller。</span></div><div class="line">             * 在处理完root node之后，parent变量被设定为root interrupt controller，</div><div class="line">             * 因此，第二个循环中处理的是所有parent是root interrupt controller的child interrupt controller。</div><div class="line">             * 也就是level 1（如果root是level 0的话）的节点。</div><div class="line">             */</div><div class="line">            <span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            list_del(&amp;desc-&gt;<span class="built_in">list</span>);                     <span class="comment">/* 从链表中删除 */</span></div><div class="line">            match = of_match_node(matches, desc-&gt;dev); <span class="comment">/* 匹配并初始化 */</span></div><div class="line">            <span class="keyword">if</span> (WARN(!match-&gt;data,                     <span class="comment">/* match-&gt;data是初始化函数 */</span></div><div class="line">                <span class="string">"of_irq_init: no init function for %s\n"</span>,</div><div class="line">                match-&gt;compatible)) &#123;</div><div class="line">                kfree(desc);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            irq_init_cb = (<span class="keyword">of_irq_init_cb_t</span>)match-&gt;data;</div><div class="line">            ret = irq_init_cb(desc-&gt;dev, desc-&gt;interrupt_parent); <span class="comment">/* 执行初始化函数 */</span></div><div class="line">            <span class="keyword">if</span> (ret) &#123;</div><div class="line">                kfree(desc);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* 处理完的节点放入intc_parent_list链表，后面会用到 */</span></div><div class="line">            list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* 对于level 0，只有一个root interrupt controller，</span></div><div class="line">         * 对于level 1，可能有若干个interrupt controller，</div><div class="line">         * 因此要遍历这些parent interrupt controller，以便处理下一个level的child node。</div><div class="line">         */</div><div class="line">        desc = list_first_entry_or_null(&amp;intc_parent_list,</div><div class="line">                        typeof(*desc), <span class="built_in">list</span>);</div><div class="line">        <span class="keyword">if</span> (!desc) &#123;</div><div class="line">            pr_err(<span class="string">"of_irq_init: children remain, but no parents\n"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        parent = desc-&gt;dev;</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, <span class="built_in">list</span>) &#123;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line">err:</div><div class="line">    list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</div><div class="line">        list_del(&amp;desc-&gt;<span class="built_in">list</span>);</div><div class="line">        kfree(desc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>只有该node中有<code>interrupt-controller</code>这个属性定义，那么linux kernel就会分配一个interrupt controller的描述符（<code>struct intc_desc</code>）并挂入队列。通过<code>interrupt-parent</code>属性，可以确定各个interrupt controller的层次关系。在scan了所有的Device Tree中的interrupt controller的定义之后，系统开始匹配过程。一旦匹配到了interrupt chip列表中的项次后，就会调用相应的初始化函数。如果CPU是S3C2416的话，匹配到的是irqchip的初始化函数是<code>s3c2416_init_intc_of</code>。</p>
<p>OK，我们已经通过<code>compatible</code>属性找到了适合的interrupt controller，那么如何解析reg属性呢？我们知道，对于s3c2416的interrupt controller而言，其<code>#interrupt-cells</code>的属性值是4，定义为。每个域的解释如下：</p>
<p>（1）ctrl_num表示使用哪一种类型的interrupt controller，其值的解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- 0 ... main controller</div><div class="line">- 1 ... sub controller</div><div class="line">- 2 ... second main controller</div></pre></td></tr></table></figure></p>
<p>（2）parent_irq。对于sub controller，parent_irq标识了其在main controller的bit position。<br>（3）ctrl_irq标识了在controller中的bit位置。<br>（4）type标识了该中断的trigger type，例如：上升沿触发还是电平触发。</p>
<p>为了更顺畅的描述后续的代码，我需要简单的介绍2416的中断控制器，其block diagram如下：<br><img src="/kernel/内核设备树/dt-code-analysis/irqs-2416.gif" alt="irqs-2416.gif" title=""><br>53个Samsung2416的中断源被分成两种类型，一种是需要sub寄存器进行控制的，例如DMA，系统中的8个DMA中断是通过两级识别的，先在SRCPND寄存器中得到是DMA中断的信息，具体是哪一个channel的DMA中断需要继续查询SUBSRC寄存器。那些不需要sub寄存器进行控制的，例如timer，5个timer的中断可以直接从SRCPND中得到。<br>中断MASK寄存器可以控制产生的中断是否要报告给CPU，当一个中断被mask的时候，虽然SRCPND寄存器中，硬件会set该bit，但是不会影响到INTPND寄存器，从而不会向CPU报告该中断。对于SUBMASK寄存器，如果该bit被set，也就是该sub中断被mask了，那么即便产生了对应的sub中断，也不会修改SRCPND寄存器的内容，只是修改SUBSRCPND中寄存器的内容。</p>
<p>不过随着硬件的演化，更多的HW block加入到SOC中，这使得中断源不够用了，因此中断寄存器又被分成两个group，一个是group 1（开始地址是<code>0X4A000000</code>，也就是main controller了），另外一个是group2（开始地址是<code>0X4A000040</code>，叫做second main controller）。group 1中的sub寄存器的起始地址是<code>0X4A000018</code>（也就是sub controller）。</p>
<p>了解了上面的内容后，下面的定义就比较好理解了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> s3c24xx_irq_of_ctrl s3c2416_ctrl[] = &#123;</div><div class="line">    &#123;</div><div class="line">        .name = <span class="string">"intc"</span>,               <span class="comment">/* main controller */</span></div><div class="line">        .offset = <span class="number">0</span>,</div><div class="line">    &#125;, &#123;</div><div class="line">        .name = <span class="string">"subintc"</span>,            <span class="comment">/* sub controller */</span></div><div class="line">        .offset = <span class="number">0x18</span>,</div><div class="line">        .parent = &amp;s3c_intc[<span class="number">0</span>],</div><div class="line">    &#125;, &#123;</div><div class="line">        .name = <span class="string">"intc2"</span>,              <span class="comment">/* second main controller */</span></div><div class="line">        .offset = <span class="number">0x40</span>,</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对于s3c2416而言，irqchip的初始化函数是<code>s3c2416_init_intc_of</code>，<code>s3c2416_ctrl</code>作为参数传递给了<code>s3c_init_intc_of</code>，大部分的处理都是在<code>s3c_init_intc_of</code>函数中完成的，由于这个函数和中断子系统非常相关，这里就不详述了，后续会有一份专门的文档描述之。</p>
<h3 id="GPIO-controller的处理"><a href="#GPIO-controller的处理" class="headerlink" title="GPIO controller的处理"></a>GPIO controller的处理</h3><p>暂不描述，后续会有一份专门的文档描述GPIO sub system。</p>
<h3 id="machine初始化"><a href="#machine初始化" class="headerlink" title="machine初始化"></a>machine初始化</h3><p>machine初始化的代码可以沿着<code>start_kernel-&gt;rest_init-&gt;kernel_init-&gt;kernel_init_freeable-&gt;do_basic_setup-&gt;do_initcalls</code>路径寻找。在<code>do_initcalls</code>函数中，kernel会依次执行各个<code>initcall</code>函数，在这个过程中，会调用<code>customize_machine</code>，具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">customize_machine</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (machine_desc-&gt;init_machine)</div><div class="line">        machine_desc-&gt;init_machine();</div><div class="line">    <span class="keyword">else</span></div><div class="line">        of_platform_populate(<span class="literal">NULL</span>, of_default_bus_match_table, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">arch_initcall(customize_machine);</div></pre></td></tr></table></figure></p>
<p>在这个函数中，一般会调用machine描述符中的<code>init_machine callback</code>函数来把各种Device Tree中定义各个设备节点加入到系统。如果machine描述符中没有定义<code>init_machine</code>函数，那么直接调用<code>of_platform_populate</code>把所有的platform device加入到kernel中。对于s3c2416，其machine描述符中的<code>init_machine callback</code>函数就是<code>s3c2416_dt_machine_init</code>，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function">init <span class="title">s3c2416_dt_machine_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    of_platform_populate(<span class="literal">NULL</span>, <span class="comment">/* 传入NULL参数表示从root node开始scan */</span></div><div class="line">        of_default_bus_match_table, s3c2416_auxdata_lookup, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    s3c_pm_init();             <span class="comment">/* power management相关的初始化 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见，最终生成platform device的代码来自<code>of_platform_populate</code>函数。该函数的逻辑比较简单，遍历device node global list中所有的node，并调用<code>of_platform_bus_create</code>处理，<code>of_platform_bus_create</code>函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">of_platform_bus_create</span><span class="params">(<span class="keyword">struct</span> device_node *bus, <span class="comment">/* 要创建的那个device node */</span></span></span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> of_device_id *matches,      <span class="comment">/* 要匹配的list */</span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">struct</span> of_dev_auxdata *lookup,     <span class="comment">/* 附属数据 */</span></div><div class="line">                  <span class="keyword">struct</span> device *parent, <span class="keyword">bool</span> strict)      <span class="comment">/* parent指向父节点。strict是否要求完全匹配 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> of_dev_auxdata *auxdata;</div><div class="line">    <span class="keyword">struct</span> device_node *child;</div><div class="line">    <span class="keyword">struct</span> platform_device *dev;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">void</span> *platform_data = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 删除确保device node有compatible属性的代码。 */</span></div><div class="line"></div><div class="line">    auxdata = of_dev_lookup(lookup, bus); <span class="comment">/* 在传入的lookup table寻找和该device node匹配的附加数据 */</span></div><div class="line">    <span class="keyword">if</span> (auxdata) &#123;</div><div class="line">        bus_id = auxdata-&gt;name;           <span class="comment">/* 如果找到，那么就用附加数据中的静态定义的内容 */</span></div><div class="line">        platform_data = auxdata-&gt;platform_data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* ARM公司提供了CPU core，除此之外，它设计了AMBA的总线来连接SOC内的各个block。</span></div><div class="line">     * 符合这个总线标准的SOC上的外设叫做ARM Primecell Peripherals。</div><div class="line">     * 如果一个device node的compatible属性值是arm,primecell的话，</div><div class="line">     * 可以调用of_amba_device_create来向amba总线上增加一个amba device。</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (of_device_is_compatible(bus, <span class="string">"arm,primecell"</span>)) &#123;</div><div class="line">        of_amba_device_create(bus, bus_id, platform_data, parent);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 如果不是ARM Primecell Peripherals，那么我们就需要向platform bus上增加一个platform device了 */</span></div><div class="line">    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);</div><div class="line">    <span class="keyword">if</span> (!dev || !of_match_node(matches, bus))</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 一个device node可能是一个桥设备，因此要重复调用of_platform_bus_create来把所有的device node处理掉。 */</span></div><div class="line"></div><div class="line">    for_each_child_of_node(bus, child) &#123;</div><div class="line">        pr_debug(<span class="string">"   create child: %s\n"</span>, child-&gt;full_name);</div><div class="line">        rc = of_platform_bus_create(child, matches, lookup, &amp;dev-&gt;dev, strict);</div><div class="line">        <span class="keyword">if</span> (rc) &#123;</div><div class="line">            of_node_put(child);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体增加platform device的代码在<code>of_platform_device_create_pdata</code>中，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> platform_device *<span class="title">of_platform_device_create_pdata</span><span class="params">(</span></span></div><div class="line">                    <span class="keyword">struct</span> device_node *np,</div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *bus_id,</div><div class="line">                    <span class="keyword">void</span> *platform_data,</div><div class="line">                    <span class="keyword">struct</span> device *parent)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> platform_device *dev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!of_device_is_available(np)) <span class="comment">/* check status属性，确保是enable或者OK的。 */</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* of_device_alloc除了分配struct platform_device的内存，</span></div><div class="line">     * 还分配了该platform device需要的resource的内存（参考struct platform_device 中的resource成员）。</div><div class="line">     * 当然，这就需要解析该device node的interrupt资源以及memory address资源。</div><div class="line">     */</div><div class="line">    dev = of_device_alloc(np, bus_id, parent);</div><div class="line">    <span class="keyword">if</span> (!dev)</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">/* 设定platform_device 中的其他成员 */</span></div><div class="line">    dev-&gt;dev.coherent_dma_mask = DMA_BIT_MASK(<span class="number">32</span>);</div><div class="line">    <span class="keyword">if</span> (!dev-&gt;dev.dma_mask)</div><div class="line">        dev-&gt;dev.dma_mask = &amp;dev-&gt;dev.coherent_dma_mask;</div><div class="line">    dev-&gt;dev.bus = &amp;platform_bus_type;</div><div class="line">    dev-&gt;dev.platform_data = platform_data;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (of_device_add(dev) != <span class="number">0</span>) &#123; <span class="comment">/* 把这个platform device加入统一设备模型系统中 */</span></div><div class="line">        platform_device_put(dev);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dev;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><span style="color:red;">PS: 上述分析中的 of<em>* 函数，其 of</em> 前缀为Open Firmware的缩写？</span></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Device Tree（二）：基本概念]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91/dt-basic-concept/</url>
      <content type="html"><![CDATA[<p>转自：<a href="www.wowotech.net">蜗窝科技</a><br>原文链接：<a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html" target="_blank" rel="external">http://www.wowotech.net/linux_kenrel/dt_basic_concept.html</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一些背景知识（例如：为何要引入Device Tree，这个机制是用来解决什么问题的）请参考<a href="http://www.wowotech.net/linux_kenrel/why-dt.html" target="_blank" rel="external">引入Device Tree的原因</a>，本文主要是介绍Device Tree的基础概念。</p>
<p>简单的说，如果要使用Device Tree，首先用户要了解自己的硬件配置和系统运行参数，并把这些信息组织成Device Tree source file。通过DTC（Device Tree Compiler），可以将这些适合人类阅读的Device Tree source file变成适合机器处理的Device Tree binary file（有一个更好听的名字，DTB，device tree blob）。在系统启动的时候，boot program（例如：firmware、bootloader）可以将保存在flash中的DTB copy到内存（当然也可以通过其他方式，例如可以通过bootloader的交互式命令加载DTB，或者firmware可以探测到device的信息，组织成DTB保存在内存中），并把DTB的起始地址传递给client program（例如OS kernel，bootloader或者其他特殊功能的程序）。对于计算机系统（computer system），一般是firmware-&gt;bootloader-&gt;OS，对于嵌入式系统，一般是bootloader-&gt;OS。</p>
<p>本文主要描述下面两个主题：<br>1、Device Tree source file语法介绍<br>2、Device Tree binary file格式介绍<br><a id="more"></a></p>
<h2 id="Device-Tree的结构"><a href="#Device-Tree的结构" class="headerlink" title="Device Tree的结构"></a>Device Tree的结构</h2><p>在描述Device Tree的结构之前，我们先问一个基础问题：<span style="color:red;">是否Device Tree要描述系统中的所有硬件信息？答案是否定的。</span>基本上，那些可以动态探测到的设备是不需要描述的，例如USB device。不过对于SOC上的usb host controller，它是无法动态识别的，需要在device tree中描述。同样的道理，在computer system中，PCI device可以被动态探测到，不需要在device tree中描述，但是PCI bridge如果不能被探测，那么就需要描述之。</p>
<p>为了了解Device Tree的结构，我们首先给出一个Device Tree的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/ o device-tree</div><div class="line">      |- name = &quot;device-tree&quot;</div><div class="line">      |- model = &quot;MyBoardName&quot;</div><div class="line">      |- compatible = &quot;MyBoardFamilyName&quot;</div><div class="line">      |- #address-cells = &lt;2&gt;</div><div class="line">      |- #size-cells = &lt;2&gt;</div><div class="line">      |- linux,phandle = &lt;0&gt;</div><div class="line">      |</div><div class="line">      o cpus</div><div class="line">      | | - name = &quot;cpus&quot;</div><div class="line">      | | - linux,phandle = &lt;1&gt;</div><div class="line">      | | - #address-cells = &lt;1&gt;</div><div class="line">      | | - #size-cells = &lt;0&gt;</div><div class="line">      | |</div><div class="line">      | o PowerPC,970@0</div><div class="line">      |   |- name = &quot;PowerPC,970&quot;</div><div class="line">      |   |- device_type = &quot;cpu&quot;</div><div class="line">      |   |- reg = &lt;0&gt;</div><div class="line">      |   |- clock-frequency = &lt;0x5f5e1000&gt;</div><div class="line">      |   |- 64-bit</div><div class="line">      |   |- linux,phandle = &lt;2&gt;</div><div class="line">      |</div><div class="line">      o memory@0</div><div class="line">      | |- name = &quot;memory&quot;</div><div class="line">      | |- device_type = &quot;memory&quot;</div><div class="line">      | |- reg = &lt;0x00000000 0x00000000 0x00000000 0x20000000&gt;</div><div class="line">      | |- linux,phandle = &lt;3&gt;</div><div class="line">      |</div><div class="line">      o chosen</div><div class="line">        |- name = &quot;chosen&quot;</div><div class="line">        |- bootargs = &quot;root=/dev/sda2&quot;</div><div class="line">        |- linux,phandle = &lt;4&gt;</div></pre></td></tr></table></figure></p>
<p>从上图中可以看出，device tree的基本单元是node。这些node被组织成树状结构，除了root node，每个node都只有一个parent。<span style="color:red;">一个device tree文件中只能有一个root node。</span>每个node中包含了若干的property/value来描述该node的一些特性。<span style="color:red;">每个node用节点名字（node name）标识，节点名字的格式是<code>node-name@unit-address</code>。如果该node没有reg属性（后面会描述这个property），那么该节点名字中必须不能包括@和unit-address。</span>unit-address的具体格式是和设备挂在那个bus上相关。例如对于cpu，其unit-address就是从0开始编址，以此加一。而具体的设备，例如以太网控制器，其unit-address就是寄存器地址。root node的node name是确定的，必须是“/”。</p>
<p>在一个树状结构的device tree中，如何引用一个node呢？要想唯一指定一个node必须使用full path，例如<code>/node-name-1/node-name-2/node-name-N</code>。在上面的例子中，cpu node我们可以通过<code>/cpus/PowerPC,970@0</code>访问。<br>属性（property）值标识了设备的特性，它的值（value）是多种多样的：<br>1、<span style="color:red;">可能是空，也就是没有值的定义。</span>例如上图中的64-bit ，这个属性没有赋值。<br>2、可能是一个u32、u64的数值（值得一提的是cell这个术语，在Device Tree表示32bit的信息单位）。例如<code>#address-cells = &lt;1&gt;</code>。当然，可能是一个数组。例如<code>&lt;0x00000000 0x00000000 0x00000000 0x20000000&gt;</code><br>4、可能是一个字符串。例如<code>device_type = &quot;memory&quot;</code>，当然也可能是一个string list。例如<code>&quot;PowerPC,970&quot;</code></p>
<h2 id="Device-Tree-source-file语法介绍"><a href="#Device-Tree-source-file语法介绍" class="headerlink" title="Device Tree source file语法介绍"></a>Device Tree source file语法介绍</h2><p>了解了基本的device tree的结构后，我们总要把这些结构体现在device tree source code上来。在linux kernel中，扩展名是dts的文件就是描述硬件信息的device tree source file，在dts文件中，一个node被定义成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[label:] node-name[@unit-address] &#123;</div><div class="line">   [properties definitions]</div><div class="line">   [child nodes]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“[]”表示option，因此可以定义一个只有node name的空节点。label方便在dts文件中引用，具体后面会描述。child node的格式和node是完全一样的，因此，一个dts文件中就是若干嵌套组成的node，property以及child note、child note property描述。</p>
<p>考虑到空泛的谈比较枯燥，我们用实例来讲解Device Tree Source file 的数据格式。假设蜗窝科技制作了一个S3C2416的开发板，我们把该development board命名为snail，那么需要撰写一个s3c2416-snail.dts的文件。如果把所有的开发板的硬件信息（SOC以及外设）都描述在一个文件中是不合理的，因此有可能其他公司也使用S3C2416搭建自己的开发板并命名pig、cow什么的，如果大家都用自己的dts文件描述硬件，那么其中大部分是重复的，因此我们把和S3C2416相关的硬件描述保存成一个单独的<strong>dts</strong>文件可以供使用S3C2416的target board来引用并将文件的扩展名变成<strong>dtsi</strong>（i表示include）。同理，三星公司的S3C24xx系列是一个SOC family，这些SOCs（2410、2416、2450等）也有相同的内容，因此同样的道理，我们可以将公共部分抽取出来，变成s3c24xx.dtsi，方便大家include。同样的道理，各家ARM vendor也会共用一些硬件定义信息，这个文件就是skeleton.dtsi。我们自下而上（类似C＋＋中的从基类到顶层的派生类）逐个进行分析。</p>
<p><strong>1、skeleton.dtsi。</strong>位于linux-3.14\arch\arm\boot\dts目录下，具体该文件的内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;1&gt;;</div><div class="line">    chosen &#123; &#125;;</div><div class="line">    aliases &#123; &#125;;</div><div class="line">    memory &#123; device_type = &quot;memory&quot;; reg = &lt;0 0&gt;; &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>device tree顾名思义是一个树状的结构，既然是树，必然有根。“/”是根节点的node name。“{”和“}”之间的内容是该节点的具体的定义，其内容包括各种属性的定义以及child node的定义。chosen、aliases和memory都是sub node，sub node的结构和root node是完全一样的，因此，sub node也有自己的属性和它自己的sub node，最终形成了一个树状的device tree。属性的定义采用<code>property ＝ value</code>的形式。例如<code>#address-cells</code>和<code>#size-cells</code>就是property，而<code>&lt;1&gt;</code>就是value。value有三种情况：<br>1）属性值是text string或者string list，用双引号表示。例如<code>device_type = &quot;memory&quot;</code><br>2）属性值是32bit unsigned integers，用尖括号表示。例如<code>#size-cells = &lt;1&gt;</code><br>3）属性值是binary data，用方括号表示。例如<code>binary-property = [0x01 0x23 0x45 0x67]</code></p>
<p>如果一个device node中包含有寻址需求（要定义reg property）的sub node（后文也许会用child node，和sub node是一样的意思），那么就必须要定义这两个属性。<span style="color:red;">“#”是number的意思，</span><code>#address-cells</code>这个属性是用来描述sub node中的reg属性的地址域特性的，也就是说需要用多少个u32的cell来描述该地址域。同理可以推断<code>#size-cells</code>的含义，下面对reg的描述中会给出更详细的信息。</p>
<p>chosen node主要用来描述由系统firmware指定的runtime parameter。如果存在chosen这个node，其parent node必须是名字是“/”的根节点。原来通过tag list传递的一些linux kernel的运行时参数可以通过Device Tree传递。例如command line可以通过bootargs这个property这个属性传递；initrd的开始地址也可以通过linux,initrd-start这个property这个属性传递。在本例中，chosen节点是空的，在实际中，建议增加一个bootargs的属性，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;root=/dev/nfs nfsroot=1.1.1.1:/nfsboot ip=1.1.1.2:1.1.1.1:1.1.1.1:255.255.255.0::usbd0:off console=ttyS0,115200 mem=64M@0x30000000&quot;</div></pre></td></tr></table></figure></p>
<p>通过该command line可以控制内核从usbnet启动，当然，具体项目要相应修改command line以便适应不同的需求。我们知道，device tree用于HW platform识别，runtime parameter传递以及硬件设备描述。chosen节点并没有描述任何硬件设备节点的信息，它只是传递了runtime parameter。</p>
<p>aliases 节点定义了一些别名。为何要定义这个node呢？因为Device tree是树状结构，当要引用一个node的时候要指明相对于root node的full path，例如<code>/node-name-1/node-name-2/node-name-N</code>。如果多次引用，每次都要写这么复杂的字符串多少是有些麻烦，因此可以在aliases 节点定义一些设备节点full path的缩写。skeleton.dtsi中没有定义aliases，下面的section中会进一步用具体的例子描述之。</p>
<p>memory device node是所有设备树文件的必备节点，它定义了系统物理内存的layout。device_type属性定义了该node的设备类型，例如cpu、serial等。对于memory node，其device_type必须等于memory。reg属性定义了访问该device node的地址信息，该属性的值被解析成任意长度的（address，size）数组，具体用多长的数据来表示address和size是在其parent node中定义（<code>#address-cells</code>和<code>#size-cells</code>）。对于device node，reg描述了memory-mapped IO register的offset和length。对于memory node，定义了该memory的起始地址和长度。</p>
<p>本例中的物理内存的布局并没有通过memory node传递，其实我们可以使用command line传递，我们command line中的参数“<code>mem=64M@0x30000000</code>”已经给出了具体的信息。我们用另外一个例子来加深对本节描述的各个属性以及memory node的理解。假设我们的系统是64bit的，physical memory分成两段，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RAM: starting address 0x0, length 0x80000000 (2GB)</div><div class="line">RAM: starting address 0x100000000, length 0x100000000 (4GB)</div></pre></td></tr></table></figure></p>
<p>对于这样的系统，我们可以将root node中的<code>#address-cells</code>和<code>#size-cells</code>这两个属性值设定为2，可以用下面两种方法来描述物理内存：<br>方法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">memory@0 &#123;</div><div class="line">    device_type = &quot;memory&quot;;</div><div class="line">    reg = &lt;0x000000000 0x00000000 0x00000000 0x80000000</div><div class="line">              0x000000001 0x00000000 0x00000001 0x00000000&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">memory@0 &#123;</div><div class="line">    device_type = &quot;memory&quot;;</div><div class="line">    reg = &lt;0x000000000 0x00000000 0x00000000 0x80000000&gt;;</div><div class="line">&#125;;</div><div class="line">memory@100000000 &#123;</div><div class="line">    device_type = &quot;memory&quot;;</div><div class="line">    reg = &lt;0x000000001 0x00000000 0x00000001 0x00000000&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>2、s3c24xx.dtsi。</strong>位于linux-3.14\arch\arm\boot\dts目录下，具体该文件的内容如下（有些内容省略了，领会精神即可，不需要描述每一个硬件定义的细节）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#include &quot;skeleton.dtsi&quot;</div><div class="line">/ &#123;</div><div class="line">    compatible = &quot;samsung,s3c24xx&quot;; －－－－－－－－－－－－－－－－－－－（A）</div><div class="line">    interrupt-parent = &lt;&amp;intc&gt;; －－－－－－－－－－－－－－－－－－－－－－（B）</div><div class="line">    aliases &#123;</div><div class="line">        pinctrl0 = &amp;pinctrl_0; －－－－－－－－－－－－－－－－－－－－－－－－（C）</div><div class="line">    &#125;;</div><div class="line">    intc:interrupt-controller@4a000000 &#123; －－－－－－－－－－－－－－－－－－（D）</div><div class="line">        compatible = &quot;samsung,s3c2410-irq&quot;;</div><div class="line">        reg = &lt;0x4a000000 0x100&gt;;</div><div class="line">        interrupt-controller;</div><div class="line">        #interrupt-cells = &lt;4&gt;;</div><div class="line">    &#125;;</div><div class="line">    serial@50000000 &#123; －－－－－－－－－－－－－－－－－－－－－－（E）</div><div class="line">        compatible = &quot;samsung,s3c2410-uart&quot;;</div><div class="line">        reg = &lt;0x50000000 0x4000&gt;;</div><div class="line">        interrupts = &lt;1 0 4 28&gt;, &lt;1 1 4 28&gt;;</div><div class="line">        status = &quot;disabled&quot;;</div><div class="line">    &#125;;</div><div class="line">    pinctrl_0: pinctrl@56000000 &#123;－－－－－－－－－－－－－－－－－－（F）</div><div class="line">        reg = &lt;0x56000000 0x1000&gt;;</div><div class="line">        wakeup-interrupt-controller &#123;</div><div class="line">            compatible = &quot;samsung,s3c2410-wakeup-eint&quot;;</div><div class="line">            interrupts = &lt;0 0 0 3&gt;,</div><div class="line">                     &lt;0 0 1 3&gt;,</div><div class="line">                     &lt;0 0 2 3&gt;,</div><div class="line">                     &lt;0 0 3 3&gt;,</div><div class="line">                     &lt;0 0 4 4&gt;,</div><div class="line">                     &lt;0 0 5 4&gt;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个文件描述了三星公司的S3C24xx系列SOC family共同的硬件block信息。首先提出的问题就是：<span style="color:red;">为何定义了两个根节点？</span>按理说Device Tree只能有一个根节点，所有其他的节点都是派生于根节点的。我的猜测是这样的：<span style="color:red;">Device Tree Compiler会对DTS的node进行合并，</span>最终生成的DTB只有一个root node。OK，我们下面开始逐一分析：</p>
<p>（A）在描述compatible属性之前要先描述model属性。model属性指明了该设备属于哪个设备生产商的哪一个model。一般而言，我们会给model赋值<code>“manufacturer,model”</code>。例如<code>model = &quot;samsung,s3c24xx&quot;</code>。samsung是生产商，s3c24xx是model类型，指明了具体的是哪一个系列的SOC。OK，现在我们回到compatible属性，该属性的值是string list，定义了一系列的modle（每个string是一个model）。<span style="color:red;">这些字符串列表被操作系统用来选择用哪一个driver来驱动该设备。</span>假设定义该属性：<code>compatible = “aaaaaa”, “bbbbb&quot;</code>。那么操作操作系统可能首先使用aaaaaa来匹配适合的driver，如果没有匹配到，那么使用字符串bbbbb来继续寻找适合的driver，对于本例，<code>compatible = &quot;samsung,s3c24xx&quot;</code>，这里只定义了一个modle而不是一个list。对于root node，compatible属性是用来匹配machine type的（在device tree代码分析文章中会给出更细致的描述）。对于普通的HW block的节点，例如interrupt-controller，compatible属性是用来匹配适合的driver的。</p>
<p>（B）具体各个HW block的interrupt source是如何物理的连接到interruptcontroller的呢？在dts文件中是用interrupt-parent这个属性来标识的。且慢，这里定义interrupt-parent属性的是root node，难道root node会产生中断到interrupt controller吗？当然不会，只不过如果一个能够产生中断的device node没有定义interrupt-parent的话，其interrupt-parent属性就是跟随parent node。因此，与其在所有的下游设备中定义interrupt-parent，不如统一在root node中定义了。</p>
<p>intc是一个lable，标识了一个device node（在本例中是标识了<code>interrupt-controller@4a000000</code>这个device node）。实际上，interrupt-parent属性值应该是是一个u32的整数值（这个整数值在Device Tree的范围内唯一识别了一个device node，也就是phandle），不过，在dts文件中中，可以使用类似c语言的Labels and References机制。定义一个lable，唯一标识一个node或者property，后续可以使用&amp;来引用这个lable。DTC会将lable转换成u32的整数值放入到DTB中，用户层面就不再关心具体转换的整数值了。</p>
<p>关于interrupt，我们值得进一步描述。在Device Tree中，有一个概念叫做interrupt tree，也就是说interrupt也是一个树状结构。我们以下图为例（该图来自Power_ePAPR_APPROVED_v1.1）：<br><img src="/kernel/内核设备树/dt-basic-concept/it.gif" alt="it.gif" title=""><br>系统中有一个interrrupt tree的根节点，device1、device2以及PCI host bridge的interrupt line都是连接到root interrupt controller的。PCI host bridge设备中有一些下游的设备，也会产生中断，但是他们的中断都是连接到PCI host bridge上的interrupt controller（术语叫做interrupt nexus），然后报告到root interrupt controller的。每个能产生中断的设备都可以产生一个或者多个interrupt，每个interrupt source（另外一个术语叫做interrupt specifier，描述了interrupt source的信息）都是限定在其所属的interrupt domain中。</p>
<p>在了解了上述的概念后，我们可以回头再看看interrupt-parent这个属性。其实这个属性是建立interrupt tree的关键属性。它指明了设备树中的各个device node如何路由interrupt event。另外，需要提醒的是interrupt controller也是可以级联的，上图中没有表示出来。那么在这种情况下如何定义interrupt tree的root呢？那个没有定义interrupt-parent的interrupt controller就是root。</p>
<p>（C）pinctrl0是一个缩写，他是<code>/pinctrl@56000000</code>的别名。这里同样也是使用了Labels and References机制。</p>
<p>（D）intc（node name是<code>interrupt-controller@4a000000</code>，我这里直接使用lable）是描述interrupt controller的device node。根据S3C24xx的datasheet，我们知道interrupt controller的寄存器地址从<code>0x4a000000</code>开始，长度为<code>0x100</code>（实际2451的interrupt的寄存器地址空间没有那么长，<code>0x4a000074</code>是最后一个寄存器），也就是reg属性定义的内容。interrupt-controller属性为空，只是用来标识该node是一个interrupt controller而不是interrupt nexus（interrupt nexus需要在不同的interrupt domains之间进行翻译，需要定义interrupt-map的属性，本文不涉及这部分的内容）。<code>#interrupt-cells</code>和<code>#address-cells</code>概念是类似的，也就是说，用多少个u32来标识一个interrupt source。我们可以看到，在具体HW block的interrupt定义中都是用了4个u32来表示，例如串口的中断是这样定义的：<br><code>interrupts = &lt;1 0 4 28&gt;, &lt;1 1 4 28&gt;;</code></p>
<p>（E） 从reg属性可以serial controller寄存器地址从<code>0x50000000</code>开始，长度为<code>0x4000</code>。对于一个能产生中断的设备，必须定义interrupts这个属性。也可以定义interrupt-parent这个属性，如果不定义，则继承其parent node的interrupt-parent属性。 对于interrupt属性值，各个interrupt controller定义是不一样的，有的用3个u32表示，有的用4个。具体上面的各个数字的解释权归相关的interrupt controller所有。对于中断属性的具体值的描述我们会在device tree的第三份文档－代码分析中描述。</p>
<p>（F）这个node是描述GPIO控制的。这个节点定义了一个wakeup-interrupt-controller 的子节点，用来描述有唤醒功能的中断源。</p>
<p><strong>3、s3c2416.dtsi。</strong>位于linux-3.14\arch\arm\boot\dts目录下，具体该文件的内容如下（有些内容省略了，领会精神即可，不需要描述每一个硬件定义的细节）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &quot;s3c24xx.dtsi&quot;</div><div class="line">#include &quot;s3c2416-pinctrl.dtsi&quot;</div><div class="line">/ &#123;</div><div class="line">    model = &quot;Samsung S3C2416 SoC&quot;;</div><div class="line">    compatible = &quot;samsung,s3c2416&quot;; －－－－－－－－－－－－－－－A</div><div class="line">    cpus &#123; －－－－－－－－－－－－－－－－－－－－－－－－－－－－B</div><div class="line">        #address-cells = &lt;1&gt;;</div><div class="line">        #size-cells = &lt;0&gt;;</div><div class="line">        cpu &#123;</div><div class="line">            compatible = &quot;arm,arm926ejs&quot;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    interrupt-controller@4a000000 &#123; －－－－－－－－－－－－－－－－－C</div><div class="line">        compatible = &quot;samsung,s3c2416-irq&quot;;</div><div class="line">    &#125;;</div><div class="line">……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>（A）在s3c24xx.dtsi文件中已经定义了compatible这个属性，在s3c2416.dtsi中重复定义了这个属性，一个node不可能有相同名字的属性，具体如何处理就交给DTC了。经过反编译，可以看出，DTC是丢弃掉了前一个定义。因此，到目前为止，<code>compatible ＝ samsung,s3c2416</code>。在s3c24xx.dtsi文件中定义了compatible的属性值被覆盖了。</p>
<p>（B）对于根节点，必须有一个cpus的child node来描述系统中的CPU信息。对于CPU的编址我们用一个u32整数就可以描述了，因此，对于cpus node，<code>#address-cells</code>是1，而<code>#size-cells</code>是0。其实CPU的node可以定义很多属性，例如TLB，cache、频率信息什么的，不过对于ARM，这里只是定义了compatible属性就OK了，arm926ejs包括了所有的processor相关的信息。</p>
<p>（C）s3c24xx.dtsi文件和s3c2416.dtsi中都有<code>interrupt-controller@4a000000</code>这个node，DTC会对这两个node进行合并，最终编译的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">interrupt-controller@4a000000 &#123;</div><div class="line">        compatible = &quot;samsung,s3c2416-irq&quot;;</div><div class="line">        reg = &lt;0x4a000000 0x100&gt;;</div><div class="line">        interrupt-controller;</div><div class="line">        #interrupt-cells = &lt;0x4&gt;;</div><div class="line">        linux,phandle = &lt;0x1&gt;;</div><div class="line">        phandle = &lt;0x1&gt;;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p><strong>4、s3c2416-pinctrl.dtsi</strong><br>  这个文件定义了<code>pinctrl@56000000</code>这个节点的若干child node，主要用来描述GPIO的bank信息。</p>
<p><strong>5、s3c2416-snail.dts</strong><br>  这个文件应该定义一些SOC之外的peripherals的定义。</p>
<h2 id="Device-Tree-binary格式"><a href="#Device-Tree-binary格式" class="headerlink" title="Device Tree binary格式"></a>Device Tree binary格式</h2><p><strong>1、DTB整体结构</strong></p>
<p>经过Device Tree Compiler编译，Device Tree source file变成了Device Tree Blob（又称作flattened device tree）的格式。Device Tree Blob的数据组织如下图所示：<br><img src="/kernel/内核设备树/dt-basic-concept/dt.gif" alt="dt.gif" title=""></p>
<p><strong>2、DTB header。</strong></p>
<p>对于DTB header，其各个成员解释如下：</p>
<table>
<thead>
<tr>
<th>field name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>magic</td>
<td>用来识别DTB的。通过这个magic，kernel可以确定bootloader传递的参数block是一个DTB还是tag list。</td>
</tr>
<tr>
<td>totalsize</td>
<td>DTB的total size</td>
</tr>
<tr>
<td>off_dt_struct</td>
<td>device tree structure block的offset</td>
</tr>
<tr>
<td>off_dt_strings</td>
<td>device tree strings block的offset</td>
</tr>
<tr>
<td>off_mem_rsvmap</td>
<td>offset to memory reserve map。有些系统，我们也许会保留一些memory有特殊用途（例如DTB或者initrd image），或者在有些DSP+ARM的SOC platform上，有写memory被保留用于ARM和DSP进行信息交互。这些保留内存不会进入内存管理系统。</td>
</tr>
<tr>
<td>version</td>
<td>该DTB的版本。</td>
</tr>
<tr>
<td>last_comp_version</td>
<td>兼容版本信息</td>
</tr>
<tr>
<td>boot_cpuid_phys</td>
<td>我们在哪一个CPU（用ID标识）上booting</td>
</tr>
<tr>
<td>dt_strings_size</td>
<td>device tree strings block的size。和off_dt_strings一起确定了strings block在内存中的位置</td>
</tr>
<tr>
<td>dt_struct_size</td>
<td>device tree structure block的size。和和off_dt_struct一起确定了device tree structure block在内存中的位置</td>
</tr>
</tbody>
</table>
<p><strong>3、 memory reserve map的格式描述</strong></p>
<p>这个区域包括了若干的reserve memory描述符。每个reserve memory描述符是由address和size组成。其中address和size都是用U64来描述。</p>
<p><strong>4、device tree structure block的格式描述</strong></p>
<p>device tree structure block区域是由若干的分片组成，每个分片开始位置都是保存了token，以此来描述该分片的属性和内容。共计有5种token：<br>（1）FDT_BEGIN_NODE (<code>0x00000001</code>)。该token描述了一个node的开始位置，紧挨着该token的就是node name（包括unit address）<br>（2）FDT_END_NODE (<code>0x00000002</code>)。该token描述了一个node的结束位置。<br>（3）FDT_PROP (<code>0x00000003</code>)。该token描述了一个property的开始位置，该token之后是两个u32的数据，分别是length和name offset。length表示该property value data的size。name offset表示该属性字符串在device tree strings block的偏移值。length和name offset之后就是长度为length具体的属性值数据。<br>（4）FDT_NOP (<code>0x00000004</code>)。<br>（5）FDT_END (<code>0x00000009</code>)。该token标识了一个DTB的结束位置。</p>
<p>一个可能的DTB的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">（1）若干个FDT_NOP（可选）</div><div class="line">（2）FDT_BEGIN_NODE</div><div class="line">              node name</div><div class="line">              paddings</div><div class="line">（3）若干属性定义。</div><div class="line">（4）若干子节点定义。</div><div class="line">（5）若干个FDT_NOP（可选）</div><div class="line">（6）FDT_END</div></pre></td></tr></table></figure></p>
<p><strong>5、device tree strings bloc的格式描述</strong></p>
<p>device tree strings bloc定义了各个node中使用的属性的字符串表。由于很多属性会出现在多个node中，因此，所有的属性字符串组成了一个string block。这样可以压缩DTB的size。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Device Tree（一）：背景介绍]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91/why-dt/</url>
      <content type="html"><![CDATA[<p>转自：<a href="www.wowotech.net">蜗窝科技</a><br>原文链接<a href="http://www.wowotech.net/device_model/why-dt.html" target="_blank" rel="external">http://www.wowotech.net/device_model/why-dt.html</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个多年耕耘在linux 2.6.23内核的开发者，各个不同项目中各种不同周边外设驱动的开发以及各种琐碎的、扯皮的俗务占据了大部分的时间。当有机会下载3.14的内核并准备学习的时候，突然发现linux kernel对于我似乎变得非常的陌生了，各种新的机制，各种framework、各种新的概念让我感到阅读内核代码变得举步维艰。 还好，剖析内核的热情还在，剩下的就交给时间的。首先进入视线的是Device Tree机制，这是和porting内核非常相关的机制，如果想让将我们的硬件平台迁移到高版本的内核上，Device Tree是一个必须要扫清的障碍。</p>
<p>我想从下面三个方面来了解Device Tree：<br>1、为何要引入Device Tree，这个机制是用来解决什么问题的？（这是本文的主题）<br>2、Device Tree的基础概念（请参考<a href="http://www.wowotech.net/linux_kenrel/dt_basic_concept.html" target="_blank" rel="external">DT基础概念</a>）<br>3、ARM linux中和Device Tree相关的代码分析（请参考<a href="http://www.wowotech.net/linux_kenrel/dt-code-analysis.html" target="_blank" rel="external">DT代码分析</a>）</p>
<p>阅读linux内核代码就像欣赏冰山，有看得到的美景（各种内核机制及其代码），也有埋在水面之下看不到的基础（机制背后的源由和目的）。沉醉于各种内核机制的代码固然有无限乐趣，但更重要的是注入更多的思考，思考其背后的机理，真正理解软件抽象。这样才能举一反三，并应用在具体的工作和生活中。</p>
<p>本文主要从下面几个方面阐述为何ARM linux会引入Device Tree：<br>1、没有Device Tree的ARM linux是如何运转的？<br>2、混乱的ARM architecture代码和存在的问题<br>3、新内核的解决之道<br><a id="more"></a></p>
<h2 id="没有Device-Tree的ARM-linux是如何运转的？"><a href="#没有Device-Tree的ARM-linux是如何运转的？" class="headerlink" title="没有Device Tree的ARM linux是如何运转的？"></a>没有Device Tree的ARM linux是如何运转的？</h2><p>我曾经porting内核到两个ARM-based的平台上。一个是小的芯片公司的应用处理器，公司自己购买了CPU core，该CPU core使用ARM兼容的指令集（但不是ARM）加上各种公司自行设计的多媒体外设整合成公司的产品进行销售。而我的任务就是porting 2.4.18内核到该平台上。在黑白屏幕的手机时代，那颗AP（application process）支持了彩屏、camera、JPEG硬件加速、2D/3D加速、MMC/SD卡、各种音频加速（内置DSP）等等特性，功能强大到无法直视。另外一次移植经历是让2.6.23内核跑在一个大公司的冷门BP（baseband processor）上。具体porting的方法是很简单的：</p>
<p>1、自己撰写一个bootloader并传递适当的参数给kernel。除了传统的command line以及tag list之类的，最重要的是申请一个machine type，当拿到属于自己项目的machine type ID的时候，当时心情雀跃，似乎自己已经是开源社区的一份子了（其实当时是有意愿，或者说有目标是想将大家的代码并入到linux kernel main line的）。</p>
<p>2、在内核的arch/arm目录下建立mach-xxx目录，这个目录下，放入该SOC的相关代码，例如中断controller的代码，时间相关的代码，内存映射，睡眠相关的代码等等。此外，最重要的是建立一个board specific文件，定义一个machine的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MACHINE_START(project name, <span class="string">"xxx公司的xxx硬件平台"</span>)</div><div class="line">    .phys_io = <span class="number">0x40000000</span>,</div><div class="line">    .boot_params = <span class="number">0xa0000100</span>,</div><div class="line">    .io_pg_offst = (io_p2v(<span class="number">0x40000000</span>) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xfffc</span>,</div><div class="line">    .map_io = xxx_map_io,</div><div class="line">    .init_irq = xxx_init_irq,</div><div class="line">    .timer = &amp;xxx_timer,</div><div class="line">    .init_machine = xxx_init,</div><div class="line">MACHINE_END</div></pre></td></tr></table></figure></p>
<p>在xxx_init函数中，一般会加入很多的platform device。因此，伴随这个board specific文件中是大量的静态table，描述了各种硬件设备信息。</p>
<p>3、调通了system level的driver（timer，中断处理，clock等）以及串口terminal之后，linux kernel基本是可以起来了，后续各种driver不断的添加，直到系统软件支持所有的硬件。<br>综上所述，在linux kernel中支持一个SOC平台其实是非常简单的，让linux kernel在一个特定的平台上“跑”起来也是非常简单的，问题的重点是如何优雅的”跑”。</p>
<h2 id="混乱的ARM-architecture代码和存在的问题"><a href="#混乱的ARM-architecture代码和存在的问题" class="headerlink" title="混乱的ARM architecture代码和存在的问题"></a>混乱的ARM architecture代码和存在的问题</h2><p>每次正式的linux kernel release之后都会有两周的merge window，在这个窗口期间，kernel各个部分的维护者都会提交各自的patch，将自己测试稳定的代码请求并入kernel main line。每到这个时候，Linus就会比较繁忙，他需要从各个内核维护者的分支上取得最新代码并merge到自己的kernel source tree中。Tony Lindgren，内核OMAP development tree的维护者，发送了一个邮件给Linus，请求提交OMAP平台代码修改，并给出了一些细节描述：<br>1、简单介绍本次改动<br>2、关于如何解决merge conficts。有些git mergetool就可以处理，不能处理的，给出了详细介绍和解决方案</p>
<p>一切都很平常，也给出了足够的信息，然而，正是这个pull request引发了一场针对ARM linux的内核代码的争论。我相信Linus一定是对ARM相关的代码早就不爽了，ARM的merge工作量较大倒在其次，主要是他认为ARM很多的代码都是垃圾，代码里面有若干愚蠢的table，而多个人在维护这个table，从而导致了冲突。因此，在处理完OMAP的pull request之后（Linus并非针对OMAP平台，只是Tony Lindgren撞在枪口上了），他发出了怒吼：</p>
<blockquote>
<p>Gaah. Guys, this whole ARM thing is a f*cking pain in the ass.</p>
</blockquote>
<p>负责ARM linux开发的Russell King脸上挂不住，进行了反驳：事情没有那么严重，这次的merge conficts就是OMAP和IMX/MXC之间一点协调的问题，不能抹杀整个ARM linux团队的努力。其他的各个ARM平台维护者也加入讨论：ARM平台如何复杂，如何庞大，对于arm linux code我们已经有一些思考，正在进行中……一时间，讨论的气氛有些尖锐，但总体是坦诚和友好的。</p>
<p>对于一件事情，不同层次的人有不同层次的思考。这次争论涉及的人包括：<br>1、内核维护者（CPU体系结构无关的代码）<br>2、维护ARM系统结构代码的人<br>3、维护ARM sub architecture的人（来自各个ARM SOC vendor）</p>
<p>维护ARM sub architecture的人并没有强烈的使命感，作为公司的一员，他们最大的目标是以最快的速度支持自己公司的SOC，尽快的占领市场。这些人的软件功力未必强，对linux kernel的理解未必深入（有些人可能很强，但是人在江湖身不由己）。在这样的情况下，很多SOC specific的代码都是通过copy and paste，然后稍加修改代码就提交了。此外，各个ARM vendor的SOC family是一长串的CPU list，每个CPU多多少少有些不同，这时候＃ifdef就充斥了各个源代码中，让ARM mach-和plat-目录下的代码有些不忍直视。</p>
<p>作为维护ARM体系结构的人，其能力不容置疑。以Russell King为首的team很好的维护了ARM体系结构的代码。基本上，除了mach-和plat-目录，其他的目录中的代码和目录组织是很好的。作为ARM linux的维护者，维护一个不断有新的SOC加入的CPU architecture code的确是一个挑战。在Intel X86的架构一统天下的时候，任何想正面攻击Intel的对手都败下阵来。想要击倒巨人（或者说想要和巨人并存）必须另辟蹊径。ARM的策略有两个，一个是focus在嵌入式应用上，也就意味着要求低功耗，同时也避免了和Intel的正面对抗。另外一个就是博采众家之长，采用license IP的方式，让更多的厂商加入ARM建立的生态系统。毫无疑问，ARM公司是成功的，但是这种模式也给ARM linux的维护者带来了噩梦。越来越多的芯片厂商加入ARM阵营，越来越多的ARM platform相关的代码被加入到内核，不同厂商的周边HW block设计又各不相同……</p>
<p>内核维护者是真正对操作系统内核软件有深入理解的人，他们往往能站在更高的层次上去观察问题，发现问题。Linus注意到每次merge window中，ARM的代码变化大约占整个ARCH目录的60％，他认为这是一个很明显的符号，意味着ARM linux的代码可能存在问题。其实，60％这个比率的确很夸张，因为unicore32是在2.6.39 merge window中第一次全新提交，它的代码是全新的，但是其代码变化大约占整个ARCH目录的9.6％（需要提及的是unicore32是一个中国芯）。有些维护ARM linux的人认为这是CPU市场占用率的体现，不是问题，直到内核维护者贴出实际的代码并指出问题所在。内核维护者当然想linux kernel支持更多的硬件平台，但是他们更愿意为linux kernel制定更长远的规划。例如：对于各种繁杂的ARM平台，用一个kernel image来支持。</p>
<p>经过争论，确定的问题如下：<br>1、ARM linux缺少platform（各个ARM sub architecture，或者说各个SOC）之间的协调，导致arm linux的代码有重复。值得一提的是在本次争论之前，ARM维护者已经进行了不少相关的工作（例如PM和clock tree）来抽象相同的功能模块。<br>2、ARM linux中大量的board specific的源代码应该踢出kernel，否则这些垃圾代码和table会影响linux kernel的长期目标。<br>3、各个sub architecture的维护者直接提交给Linux并入主线的机制缺乏层次。</p>
<h2 id="四、新内核的解决之道"><a href="#四、新内核的解决之道" class="headerlink" title="四、新内核的解决之道"></a>四、新内核的解决之道</h2><p>针对ARM linux的现状，最需要解决的是人员问题，也就是如何整合ARM sub architecture（各个ARM Vendor）的资源。因此，内核社区成立了一个ARM sub architecture的team，该team主要负责协调各个ARM厂商的代码（not ARM core part），Russell King继续负责ARM core part的代码。此外，建立一个ARM platform consolidation tree。ARM sub architecture team负责review各个sub architecture维护者提交的代码，并在ARM platform consolidation tree上维护。在下一个merge window到来的时候，将patch发送给Linus。</p>
<p>针对重复的代码问题，如果不同的SOC使用了相同的IP block（例如I2C controller），那么这个driver的code要从各个arch/arm/mach-xxx中独立出来，变成一个通用的模块供各个SOC specific的模块使用。移动到哪个目录呢？对于I2C或者USB OTG而言，这些HW block的驱动当然应该移动到kernel/drivers目录。因为，对于这些外设，可能是in-chip，也可能是off-chip的，但是对于软件而言，它们是没有差别的（或者说好的软件抽象应该掩盖底层硬件的不同）。对于那些system level的code呢？例如clock control、interrupt control。其实这些也不是ARM-specific，应该属于linux kernel的核心代码，应该放到linux/kernel目录下，属于core-Linux-kernel frameworks。当然对于ARM平台，也需要保存一些和framework交互的code，这些code叫做ARM SoC core architecture code。OK，总结一下：<br>1、ARM的核心代码仍然保存在arch/arm目录下<br>2、ARM SoC core architecture code保存在arch/arm目录下<br>3、ARM SOC的周边外设模块的驱动保存在drivers目录下<br>4、ARM SOC的特定代码在arch/arm/mach-xxx目录下<br>5、ARM SOC board specific的代码被移除，由Device Tree机制来负责传递硬件拓扑和硬件资源信息。</p>
<p>OK，终于来到了Device Tree了。本质上，Device Tree改变了原来用hardcode方式将HW 配置信息嵌入到内核代码的方法，改用bootloader传递一个DB的形式。对于基于ARM CPU的嵌入式系统，我们习惯于针对每一个platform进行内核的编译。但是随着ARM在消费类电子上的广泛应用（甚至桌面系统、服务器系统），我们期望ARM能够象X86那样用一个kernel image来支持多个platform。在这种情况下，如果我们认为kernel是一个black box，那么其输入参数应该包括：<br>1、识别platform的信息<br>2、runtime的配置参数<br>3、设备的拓扑结构以及特性</p>
<p>对于嵌入式系统，在系统启动阶段，bootloader会加载内核并将控制权转交给内核，此外，还需要把上述的三个参数信息传递给kernel，以便kernel可以有较大的灵活性。在linux kernel中，Device Tree的设计目标就是如此。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设备树使用手册（译）]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E6%A0%91/dt-usage/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://devicetree.org/Device_Tree_Usage" target="_blank" rel="external">http://devicetree.org/Device_Tree_Usage</a><br>参考译文：<a href="http://blog.chinaunix.net/uid-20522771-id-3457184.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3457184.html</a></p>
<p>本文将介绍如何为一个新机器编写设备树。我们准备提供一个有关设备树概念的概述和如何使用这些设备树来描述一个机器。<br>完整的设备树数据格式的技术说明书请参考 ePAPR 规范。ePAPR 规范涵盖了比本文基本主题更丰富的细节，要查阅本文没有涉及到的高级用法请参考该规范。<br><a id="more"></a></p>
<h2 id="基本数据格式（Basic-Data-Format）"><a href="#基本数据格式（Basic-Data-Format）" class="headerlink" title="基本数据格式（Basic Data Format）"></a>基本数据格式（Basic Data Format）</h2><p>设备树是一个包含节点和属性的简单树状结构。属性就是键－值对，而节点可以同时包含属性和子节点。例如，以下就是一个<code>.dts</code>格式的简单树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    node1 &#123;</div><div class="line">        a-string-property = &quot;A string&quot;;</div><div class="line">        a-string-list-property = &quot;first string&quot;, &quot;second string&quot;;</div><div class="line">        a-byte-data-property = [0x01 0x23 0x34 0x56];</div><div class="line">        child-node1 &#123;</div><div class="line">            first-child-property;</div><div class="line">            second-child-property = &lt;1&gt;;</div><div class="line">            a-string-property = &quot;Hello, world&quot;;</div><div class="line">        &#125;;</div><div class="line">        child-node2 &#123;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    node2 &#123;</div><div class="line">        an-empty-property;</div><div class="line">        a-cell-property = &lt;1 2 3 4&gt;; /* each number (cell) is a uint32 */</div><div class="line">        child-node1 &#123;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这棵树显然是没什么用的，因为它并没有描述任何东西，但它确实体现了节点的一些属性：</p>
<ul>
<li>一个单独的根节点：<code>/</code></li>
<li>两个子节点：<code>node1</code>和<code>node2</code></li>
<li>两个<code>node1</code>的子节点：<code>child-node1</code>和<code>child-node2</code></li>
<li>一堆分散在树里的属性。<br>属性是简单的键－值对，它的值可以为空或者包含一个任意字节流。虽然数据类型并没有编码进数据结构，但在设备树源文件中任有几个基本的数据表示形式。</li>
<li>文本字符串（以空字符结束 null terminated）可以用双引号表示：<br><code>string-property = &quot;a string&quot;</code></li>
<li>‘Cells’（单元）是 32 位无符号整数，用尖括号限定：<br><code>cell-property = &lt;0xbeef 123 0xabcd1234&gt;</code></li>
<li>二进制数据用方括号限定：<br><code>binary-property = [0x01 0x23 0x45 0x67];</code></li>
<li>不同表示形式的数据可以使用逗号连在一起：<br><code>mixed-property = &quot;a string&quot;, [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;;</code></li>
<li>逗号也可用于创建字符串列表：<br><code>string-list = &quot;red fish&quot;, &quot;blue fish&quot;;</code></li>
</ul>
<h2 id="基本概念（Basic-Concepts）"><a href="#基本概念（Basic-Concepts）" class="headerlink" title="基本概念（Basic Concepts）"></a>基本概念（Basic Concepts）</h2><p>我们将以一个简单机器开始，然后通过一步步的建立一个描述这个简单机器的设备树，来了解如何使用设备树。</p>
<h3 id="模型机（Sample-Machine）"><a href="#模型机（Sample-Machine）" class="headerlink" title="模型机（Sample Machine）"></a>模型机（Sample Machine）</h3><p>考虑下面这个假想的机器（大致基于ARM Versatile），制造商为<code>Acme</code>，并命名为<code>Coyote&#39;s Revenge</code>：</p>
<ul>
<li>一个32位 ARM CPU</li>
<li>处理器本地总线连接到内存映射的串行口、spi 总线控制器、i2c 控制器、中断控制器和外部总线桥</li>
<li>256MB SDRAM 起始地址为 0</li>
<li>两个串口起始地址：<code>0x101F1000</code>和<code>0x101F2000</code></li>
<li>GPIO 控制器起始地址：<code>0x101F3000</code></li>
<li>带有以下设备的 SPI 控制器起始地址：<code>0x10170000</code><ul>
<li>MMC 插槽的 SS 管脚连接至 GPIO #1</li>
</ul>
</li>
<li>外部总线桥挂载以下设备<ul>
<li>SMC SMC91111 以太网设备连接到外部总线，起始地址：<code>0x10100000</code></li>
<li>i2c 控制器起始地址：<code>0x10160000</code>，并挂载以下设备<ul>
<li>Maxim DS1338 实时时钟。响应从地址<code>1101000 (0x58)</code></li>
</ul>
</li>
<li>64MB NOR 闪存起始地址<code>0x30000000</code></li>
</ul>
</li>
</ul>
<h3 id="初始结构（Initial-structure）"><a href="#初始结构（Initial-structure）" class="headerlink" title="初始结构（Initial structure）"></a>初始结构（Initial structure）</h3><p>第一步就是要为这个模型机构建一个基本结构，这是一个有效的设备树最基本的结构。在这个阶段你需要唯一的标识该机器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    compatible = &quot;acme,coyotes-revenge&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>compatible</code>指定了系统的名称。它包含了一个“&lt;制造商&gt;,&lt;型号&gt;”形式的字符串。重要的是要指定一个确切的设备，并且包括制造商的名字，以避免命名空间冲突。由于操作系统会使用<code>compatible</code>的值来决定如何在机器上运行，所以正确的设置这个属性变得非常重要。<br>理论上讲，兼容性（compatible）是操作系统唯一标识一个机器所需的所有数据。如果所有的机器细节都是硬编码的，那么操作系统则可以在顶层的<code>compatible</code>属性中具体查看<code>acme,coyotes-revenge</code>。</p>
<h3 id="中央处理器（CPUs）"><a href="#中央处理器（CPUs）" class="headerlink" title="中央处理器（CPUs）"></a>中央处理器（CPUs）</h3><p>接下来就应该描述每个 CPU 了。先添加一个名为<code>cpus</code>的容器节点，然后为每个 CPU 分别添加子节点。具体到我们的情况是一个 ARM 的 双核 Cortex A9 系统。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    compatible = &quot;acme,coyotes-revenge&quot;;</div><div class="line"></div><div class="line">    cpus &#123;</div><div class="line">        cpu@0 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        &#125;;</div><div class="line">        cpu@1 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每个<code>cpu</code>节点的<code>compatible</code>属性是一个“&lt;制造商&gt;,&lt;型号&gt;”形式的字符串，指定了确切的 <code>cpu</code>，就像顶层的<code>compatible</code>属性一样。<br>稍后将会有更多的属性添加进<code>cpu</code>节点，但我们先得讨论更多一些的基本概念。</p>
<h3 id="节点名称（Node-Names）"><a href="#节点名称（Node-Names）" class="headerlink" title="节点名称（Node Names）"></a>节点名称（Node Names）</h3><p>现在应该花点时间来讨论命名约定了。每个节点必须有一个“&lt;名称&gt;[@&lt;单元地址&gt;]”（&lt;name&gt;[@&lt;unit-address&gt;]）形式的名字。</p>
<p>&lt;名称&gt; 是一个长度不超过31位的简单ascii字符串。通常，节点的命名应该根据它所表述的设备类型。比如一个”3com”以太网适配器的节点就应该命名为<code>ethernet</code>，而不应该是<code>3com509</code>。</p>
<p>如果该节点描述的设备包含有一个地址，则还应该加上单元地址（<code>unit-address</code>）。通常，单元地址就是用来访问该设备的主地址，并且该地址也在节点的<code>reg</code>属性中列出。本文档中我们将在稍后讲述<code>reg</code>属性。</p>
<p>同级（兄弟）节点命名必须是唯一的，但只要地址不同，多个节点也可以使用一样的通用名称（例如<code>serial@101f1000</code>和<code>serial@101f2000</code>）。关于节点命名的更多细节请参考ePAPR规范2.2.1节。</p>
<h3 id="设备（Devices）"><a href="#设备（Devices）" class="headerlink" title="设备（Devices）"></a>设备（Devices）</h3><p>系统中每个设备都表示为一个设备树节点。所以接下来就应该为这个设备树填充设备节点。现在，直到我们讨论如何进行寻址和中断请求如何处理之前这些新节点将一直为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    compatible = &quot;acme,coyotes-revenge&quot;;</div><div class="line"></div><div class="line">    cpus &#123;</div><div class="line">        cpu@0 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        &#125;;</div><div class="line">        cpu@1 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    serial@101F0000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    serial@101F2000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    gpio@101F3000 &#123;</div><div class="line">        compatible = &quot;arm,pl061&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    interrupt-controller@10140000 &#123;</div><div class="line">        compatible = &quot;arm,pl190&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    spi@10115000 &#123;</div><div class="line">        compatible = &quot;arm,pl022&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    external-bus &#123;</div><div class="line">        ethernet@0,0 &#123;</div><div class="line">            compatible = &quot;smc,smc91c111&quot;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        i2c@1,0 &#123;</div><div class="line">            compatible = &quot;acme,a1234-i2c-bus&quot;;</div><div class="line">            rtc@58 &#123;</div><div class="line">                compatible = &quot;maxim,ds1338&quot;;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        flash@2,0 &#123;</div><div class="line">            compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在此树中，已经为系统中的每个设备添加了节点，而且这个层次结构也反映了设备与系统的连接方式。例如，外部总线上的设备就是外部总线节点的子节点，i2c 设备就是 i2c 总线控制器节点的子节点。通常，这个层次结构表现的是 CPU 视角的系统视图。</p>
<p>现在这棵树还是无效的，因为它缺少关于设备之间互联的信息。稍后将添加这些信息。</p>
<p>在这颗树中，应该注意这些事情：</p>
<ul>
<li>每个设备节点都拥有一个<code>compatible</code>属性。</li>
<li>闪存（flash）节点的<code>compatible</code>属性由两个字符串构成。欲知为何，请阅读下一节。</li>
<li>正如前面所述，节点的命名应当反映设备的类型而不是特定的型号。请查阅 ePAPR 规范第 2.2.2 节里定义的通用节点名，应当优先使用这些节点名。</li>
</ul>
<h3 id="理解-compatible-属性"><a href="#理解-compatible-属性" class="headerlink" title="理解 compatible 属性"></a>理解 compatible 属性</h3><p>树中每个表示设备的节点都需要一个<code>compatible</code>属性。<code>compatible</code>属性是操作系统用来决定使用哪个设备驱动来绑定一个设备的关键因素。</p>
<p><code>compatible</code>是一个字符串列表，其中的第一个字符串指定了这个节点所表示的确切的设备，该字符串的格式为：”&lt;制造商&gt;,&lt;型号&gt;”。剩下的字符串的则表示其它与之相兼容的设备。</p>
<p>例如，Freescale MPC8349 片上系统（SoC）拥有一个实现了美国国家半导体<code>ns16550</code>寄存器接口的串行设备，那么 MPC8349 的串行设备的<code>compatible</code>属性就应该是：<code>compatible = &quot;fsl,mpc8349-uart&quot;, &quot;ns16550&quot;</code>。在这里，<code>fsl,mpc8349-uart</code>指定了确切的设备，而<code>ns16550</code>则说明这是与美国国家半导体<code>ns16550</code>UART 在寄存器级别兼容。</p>
<p>注：<code>ns16550</code>并没有制造商前缀，这仅仅是历史原因造成的。所有新的<code>compatible</code>值都应该使用制造商前缀。</p>
<p>这种做法可以使现有的设备驱动能够绑定到新设备上，并仍然唯一的指定确切的硬件。</p>
<p>警告：不要使用带通配符的<code>compatible</code>值，比如<code>fsl,mpc83xx-uart</code>或类似情况。芯片提供商总会做出一些打破通配符所假定情况的变化，这时候修改已来不及。相反，应该选择一个特定的芯片然后是所有后续芯片都与之兼容。</p>
<h2 id="如何编址（How-Addressing-Works）"><a href="#如何编址（How-Addressing-Works）" class="headerlink" title="如何编址（How Addressing Works）"></a>如何编址（How Addressing Works）</h2><p>可编址设备使用以下属性将地址信息编码进设备树：</p>
<ul>
<li>reg</li>
<li>#address-cells</li>
<li>#size-cells<br>每个可编址设备都有一个reg元组列表，形式为：<br><code>reg = &lt;address1 length1 [address2 length2] [address3 length3] ... &gt;</code><br>每个元组都表示一个该设备使用的地址范围，每个地址（address）值是一个或多个 32 位整型数（称为 cell）列表，同样，长度（length）值也可以是一个 cell 列表或者为空。</li>
</ul>
<p>由于地址和长度字段都是大小可变的变量，那么父节点的<code>#address-cells</code>和<code>#size-cells</code>属性就用来声明各个字段的 cell 的数量。换句话说，正确解释一个 reg 属性需要用到父节点的<code>#address-cells</code>和<code>#size-cells</code>的值。要知道这一切是如何运作的，我们将给模型机添加编址属性，就从 CPU 开始。</p>
<h3 id="CPU-编址（CPU-addressing）"><a href="#CPU-编址（CPU-addressing）" class="headerlink" title="CPU 编址（CPU addressing）"></a>CPU 编址（CPU addressing）</h3><p>CPU 节点表示了一个关于编址的最简单的例子。每个 CPU 都分配了一个唯一的 ID，并且没有 CPU id 相关的大小信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cpus &#123;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;0&gt;;</div><div class="line">    cpu@0 &#123;</div><div class="line">        compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        reg = &lt;0&gt;;</div><div class="line">    &#125;;</div><div class="line">    cpu@1 &#123;</div><div class="line">        compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">        reg = &lt;1&gt;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在 cpu 节点中，<code>#address-cells</code>设置为 1，<code>#size-cells</code>设置为 0，这意味着子节点的 reg 值是一个单一的 uint32，这是一个不包含大小字段的地址，为这两个 cpu 分配的地址是 0 和 1。cpu 节点的<code>#size-cells</code>为 0 是因为只为每个 cpu 分配一个单一的地址。</p>
<p>你可能还会注意到 reg 的值和节点名字中的单元地址值是相同的。按照惯例，<span style="color:red;">如果一个节点有 reg 属性，那么该节点的名字就必须包含单元地址（unit-address），且该地址就是 reg 属性里第一个地址值。</span></p>
<h3 id="内存映射设备（Memory-Mapped-Devices）"><a href="#内存映射设备（Memory-Mapped-Devices）" class="headerlink" title="内存映射设备（Memory Mapped Devices）"></a>内存映射设备（Memory Mapped Devices）</h3><p>与 cpu 节点里单一地址值不同，内存映射设备将分配到一个与其对应的地址范围。<code>#size-cells</code>声明每个子节点的 reg 元组中长度字段的大小。在接下来的例子中，每个地址值是 1 cell（32 位），每个长度值也是 1 cell，这是典型的 32 位系统。64 位的机器则可以使用值为 2 的<code>#address-cells</code>和<code>#size-cells</code>来获得在设备树中的 64 位编址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;1&gt;;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    serial@101f0000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">        reg = &lt;0x101f0000 0x1000 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    serial@101f2000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">        reg = &lt;0x101f2000 0x1000 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    gpio@101f3000 &#123;</div><div class="line">        compatible = &quot;arm,pl061&quot;;</div><div class="line">        reg = &lt;0x101f3000 0x1000</div><div class="line">               0x101f4000 0x0010&gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    interrupt-controller@10140000 &#123;</div><div class="line">        compatible = &quot;arm,pl190&quot;;</div><div class="line">        reg = &lt;0x10140000 0x1000 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    spi@10115000 &#123;</div><div class="line">        compatible = &quot;arm,pl022&quot;;</div><div class="line">        reg = &lt;0x10115000 0x1000 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每个设备都被分配了一个基址以及该区域的大小。这个例子中为 GPIO 设备分配了两个地址范围：<code>0x101f3000...0x101f3fff</code>和<code>0x101f4000..0x101f400f</code>。</p>
<p>一些挂在总线上的设备有不同的编址方案。例如一个带独立片选线的设备可以连接至外部总线。由于父节点会为其子节点定义地址域，所以可以选择不同的地址映射来最恰当的描述该系统。下面的代码展示了设备连接至外部总线并将其片选号编码进地址的地址分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">external-bus &#123;</div><div class="line">    #address-cells = &lt;2&gt;</div><div class="line">    #size-cells = &lt;1&gt;;</div><div class="line"></div><div class="line">    ethernet@0,0 &#123;</div><div class="line">        compatible = &quot;smc,smc91c111&quot;;</div><div class="line">        reg = &lt;0 0 0x1000&gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    i2c@1,0 &#123;</div><div class="line">        compatible = &quot;acme,a1234-i2c-bus&quot;;</div><div class="line">        reg = &lt;1 0 0x1000&gt;;</div><div class="line">        rtc@58 &#123;</div><div class="line">            compatible = &quot;maxim,ds1338&quot;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    flash@2,0 &#123;</div><div class="line">        compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;</div><div class="line">        reg = &lt;2 0 0x4000000&gt;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>外部总线的地址值使用了两个 cell，一个用于片选号；另一个则用于片选基址的偏移量。而长度字段则还是单个 cell，这是因为只有地址的偏移部分才需要一个范围量。所以，在这个例子中，每个 reg 项都有三个 cell：片选号、偏移量和长度。</p>
<p>由于地址域是包含在一个节点及其子节点的，所以父节点可以自由的定义任何对于该总线来说有意义的编址方案。那些在直接父节点（immediate parent）和子节点（child nodes）以外的节点通常不关心本地地址域，而地址应该从一个域映射到另一个域。</p>
<h3 id="非内存映射设备（Non-Memory-Mapped-Devices）"><a href="#非内存映射设备（Non-Memory-Mapped-Devices）" class="headerlink" title="非内存映射设备（Non Memory Mapped Devices）"></a>非内存映射设备（Non Memory Mapped Devices）</h3><p>其他没有被映射到处理器总线上的设备，虽然这些设备可以有一个地址范围，但它们并不能由 CPU 直接访问。取而代之的是，父设备的驱动程序会代表 CPU 间接访问设备资源。</p>
<p>以 i2c 设备为例，每个设备都分配了一个地址，但并没有与之关联的长度或范围信息。这看起来和 CPU 的地址分配很像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">i2c@1,0 &#123;</div><div class="line">    compatible = &quot;acme,a1234-i2c-bus&quot;;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;0&gt;;</div><div class="line">    reg = &lt;1 0 0x1000&gt;;</div><div class="line">    rtc@58 &#123;</div><div class="line">        compatible = &quot;maxim,ds1338&quot;;</div><div class="line">        reg = &lt;58&gt;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="范围（地址转换）Ranges-Address-Translation"><a href="#范围（地址转换）Ranges-Address-Translation" class="headerlink" title="范围（地址转换）Ranges (Address Translation)"></a>范围（地址转换）Ranges (Address Translation)</h3><p>我们已经讨论了如何给设备分配地址，但目前来说这些地址还只是设备节点的本地地址，我们还没有描述如何将这些地址映射成 CPU 可使用的地址。</p>
<p>根节点始终描述的是 CPU 视角的地址空间。根节点的子节点已经使用的是 CPU 的地址域，所以它们不需要任何显式的映射。例如，<code>serial@101f0000</code>设备就是直接分配<code>0x101f0000</code>地址。</p>
<p>那些不是根节点直接子节点的节点就没有使用 CPU 地址域。为了得到一个内存映射地址，设备树必须指定如何从一个域到另一个域地址转换的方法，因此<code>ranges</code>属性应运而生。</p>
<p>下面就是一个添加了 ranges 属性的示例设备树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    compatible = &quot;acme,coyotes-revenge&quot;;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;1&gt;;</div><div class="line">    ...</div><div class="line">    external-bus &#123;</div><div class="line">        #address-cells = &lt;2&gt;</div><div class="line">        #size-cells = &lt;1&gt;;</div><div class="line">        ranges = &lt;0 0  0x10100000   0x10000      // Chipselect 1, Ethernet</div><div class="line">                  1 0  0x10160000   0x10000      // Chipselect 2, i2c controller</div><div class="line">                  2 0  0x30000000   0x10000000&gt;; // Chipselect 3, NOR Flash</div><div class="line"></div><div class="line">        ethernet@0,0 &#123;</div><div class="line">            compatible = &quot;smc,smc91c111&quot;;</div><div class="line">            reg = &lt;0 0 0x1000&gt;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        i2c@1,0 &#123;</div><div class="line">            compatible = &quot;acme,a1234-i2c-bus&quot;;</div><div class="line">            #address-cells = &lt;1&gt;;</div><div class="line">            #size-cells = &lt;0&gt;;</div><div class="line">            reg = &lt;1 0 0x1000&gt;;</div><div class="line">            rtc@58 &#123;</div><div class="line">                compatible = &quot;maxim,ds1338&quot;;</div><div class="line">                reg = &lt;58&gt;;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        flash@2,0 &#123;</div><div class="line">            compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;</div><div class="line">            reg = &lt;2 0 0x4000000&gt;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>ranges</code>是一个地址转换列表，<code>ranges</code>表中的每一项都是一个元组，包含子地址、父地址和子地址空间区域的大小。每个字段的值都取决于子节点的<code>#address-cells</code>、父节点的<code>#address-cells</code>和子节点的<code>#size-cells</code>。以本例中的外部总线来说，子地址是 2 cell、父地址是 1 cell、区域大小也是 1 cell。那么三个 ranges 被翻译为：</p>
<ul>
<li>从片选 0 偏移量 0 开始的地址被映射到地址范围：<code>0x10100000..0x1010ffff</code></li>
<li>从片选 1 偏移量 0 开始的地址被映射到地址范围：<code>0x10160000..0x1016ffff</code></li>
<li>从片选 2 偏移量 0 开始的地址被映射到地址范围：<code>0x30000000..0x3fffffff</code><br>另外，如果父地址空间和子地址空间是相同的，那么该节点可以添加一个空的 range 属性。一个空的 range 属性意味着子地址空间中的地址将被 1:1 映射到父地址空间。</li>
</ul>
<p>你有可能会问当全都可以设计成 1:1 映射的时候为何还要使用地址转换。答案就是，有一些具有完全不同地址空间的总线（比如 PCI），而它们的细节需要暴露给操作系统；另外一些带有 DMA 引擎的设备需要知道总线上的真实地址；有时需要将设备组合到一块，因为它们共享相同的软件可编程物理地址映射。是否应该使用 1:1 映射在很大程度上取决于操作系统需要的信息以及硬件设计。</p>
<p>你还应该注意到在<code>i2c@1,0</code>节点中并没有<code>range</code>属性。不同于外部总线，这里的原因是 i2c 总线上的设备并没有被内存映射到 CPU 的地址域。相反，CPU 将通过<code>i2c@1,0</code>设备间接访问<code>rtc@58</code>设备。缺少<code>ranges</code>属性意味着这个设备将不能被它的父设备以外的任何设备直接访问。</p>
<h2 id="中断如何工作（How-Interrupts-Work）"><a href="#中断如何工作（How-Interrupts-Work）" class="headerlink" title="中断如何工作（How Interrupts Work）"></a>中断如何工作（How Interrupts Work）</h2><p>与遵循树的自然结构而进行的地址转换不同，机器上的任何设备都可以发起和终止中断信号。另外，与在设备树中自然表示的地址编址不同，中断信号表示为独立于设备树结构的节点之间的链接。有四个属性用来描述中断连接：</p>
<ul>
<li><code>interrupt-controller</code>一个空的属性定义一个接收中断信号的设备节点。</li>
<li><code>#interrupt-cells</code>这是一个中断控制器节点的属性。它声明了该中断控制器的中断指示符（interrupt specifier）中 cell 的个数（类似于<code>#address-cells</code>和<code>#size-cells</code>）。</li>
<li><code>interrupt-parent</code>这是一个设备节点的属性，包含一个指向该设备所连接的中断控制器的 <code>phandle</code>。那些没有<code>interrupt-parent</code>属性的节点则从它们的父节点中继承该属性。</li>
<li><code>interrupts</code>一个设备节点属性，包含一个中断指示符列表，对应于该设备上的每个中断输出信号。<br>中断指示符是一个或多个 cell 的数据（由<code>#interrupt-cells</code>指定），这些数据指定了该设备连接至哪些中断输入。如以下的例子所示，大部分设备都只有一个中断输出，但也有可能在一个设备上有多个中断输出。一个中断指示符的意义完全取决于中断控制器设备的 binding（绑定）。每个中断控制器可以决定使用几个 cell 来唯一的定义一个中断输入。</li>
</ul>
<p>下面的代码为我们的 Coyote’s Revenge 模型机添加了中断连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">/ &#123;</div><div class="line">    compatible = &quot;acme,coyotes-revenge&quot;;</div><div class="line">    #address-cells = &lt;1&gt;;</div><div class="line">    #size-cells = &lt;1&gt;;</div><div class="line">    interrupt-parent = &lt;&amp;intc&gt;;</div><div class="line"></div><div class="line">    cpus &#123;</div><div class="line">        #address-cells = &lt;1&gt;;</div><div class="line">        #size-cells = &lt;0&gt;;</div><div class="line">        cpu@0 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">            reg = &lt;0&gt;;</div><div class="line">        &#125;;</div><div class="line">        cpu@1 &#123;</div><div class="line">            compatible = &quot;arm,cortex-a9&quot;;</div><div class="line">            reg = &lt;1&gt;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    serial@101f0000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">        reg = &lt;0x101f0000 0x1000 &gt;;</div><div class="line">        interrupts = &lt; 1 0 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    serial@101f2000 &#123;</div><div class="line">        compatible = &quot;arm,pl011&quot;;</div><div class="line">        reg = &lt;0x101f2000 0x1000 &gt;;</div><div class="line">        interrupts = &lt; 2 0 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    gpio@101f3000 &#123;</div><div class="line">        compatible = &quot;arm,pl061&quot;;</div><div class="line">        reg = &lt;0x101f3000 0x1000</div><div class="line">               0x101f4000 0x0010&gt;;</div><div class="line">        interrupts = &lt; 3 0 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    intc: interrupt-controller@10140000 &#123;</div><div class="line">        compatible = &quot;arm,pl190&quot;;</div><div class="line">        reg = &lt;0x10140000 0x1000 &gt;;</div><div class="line">        interrupt-controller;</div><div class="line">        #interrupt-cells = &lt;2&gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    spi@10115000 &#123;</div><div class="line">        compatible = &quot;arm,pl022&quot;;</div><div class="line">        reg = &lt;0x10115000 0x1000 &gt;;</div><div class="line">        interrupts = &lt; 4 0 &gt;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    external-bus &#123;</div><div class="line">        #address-cells = &lt;2&gt;</div><div class="line">        #size-cells = &lt;1&gt;;</div><div class="line">        ranges = &lt;0 0  0x10100000   0x10000     // Chipselect 1, Ethernet</div><div class="line">                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller</div><div class="line">                  2 0  0x30000000   0x1000000&gt;; // Chipselect 3, NOR Flash</div><div class="line"></div><div class="line">        ethernet@0,0 &#123;</div><div class="line">            compatible = &quot;smc,smc91c111&quot;;</div><div class="line">            reg = &lt;0 0 0x1000&gt;;</div><div class="line">            interrupts = &lt; 5 2 &gt;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        i2c@1,0 &#123;</div><div class="line">            compatible = &quot;acme,a1234-i2c-bus&quot;;</div><div class="line">            #address-cells = &lt;1&gt;;</div><div class="line">            #size-cells = &lt;0&gt;;</div><div class="line">            reg = &lt;1 0 0x1000&gt;;</div><div class="line">            interrupts = &lt; 6 2 &gt;;</div><div class="line">            rtc@58 &#123;</div><div class="line">                compatible = &quot;maxim,ds1338&quot;;</div><div class="line">                reg = &lt;58&gt;;</div><div class="line">                interrupts = &lt; 7 3 &gt;;</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        flash@2,0 &#123;</div><div class="line">            compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;</div><div class="line">            reg = &lt;2 0 0x4000000&gt;;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一些需要注意的事情：</p>
<ul>
<li>这个机器只有一个中断控制器：<code>interrupt-controller@10140000</code>。</li>
<li>中断控制器节点上添加了<code>inc:</code>标签，该标签用于给根节点的<code>interrupt-parent</code>属性分配一个<code>phandle</code>。这个<code>interrupt-parent</code>将成为本系统的默认值，因为所有的子节点都将继承它，除非显式覆写这个属性。</li>
<li>每个设备使用一个<code>interrupts</code>属性指定一个不同的中断输入线。</li>
<li><code>#interrupt-cells</code>是 2，所以每个中断指示符都有 2 个 cell。本例使用一种通用的模式，也就是用第一个 cell 来编码中断线号（interrupt line number）；然后用第二个 cell 编码标志位，比如高电平/低电平有效，或者边缘/水平触发。对于任何给定的中断控制器，请参考该控制器的 binding 文档以了解指示符如何编码。</li>
</ul>
<h2 id="设备特定数据（Device-Specific-Data）"><a href="#设备特定数据（Device-Specific-Data）" class="headerlink" title="设备特定数据（Device Specific Data）"></a>设备特定数据（Device Specific Data）</h2><p>除了通用属性以外，一个节点中可以添加任何属性和子节点。只要遵循一些规则，可以添加任何操作系统所需要的数据。</p>
<p>首先，新的设备特定属性的名字都应该使用制造商前缀，以避免和现有标准属性名相冲突。</p>
<p>其次，属性和子节点的含义必须记录在 binding 文档中，以便设备驱动程序的程序员知道如何解释这些数据。一个 binding 记录了一个特定<code>compatible</code>值的意义、应该包含什么样的属性、有可能包含那些子节点、以及它代表了什么样的设备。每个特别的<code>compatible</code>值都应该有一个它自己的 binding（或者要求与其他<code>compatible</code>值兼容）。新设备的 binding 存档在本 wiki 中。请查看主页上的文档格式描述和审核流程。</p>
<p>第三，使用邮件列表 devicetree-discuss@lists.ozlabs.org 发送新的 binding 以进行审核。新 binding 的审核可以捕获很多可能在以后导致问题的常见错误。</p>
<h2 id="特殊节点（Special-Nodes）"><a href="#特殊节点（Special-Nodes）" class="headerlink" title="特殊节点（Special Nodes）"></a>特殊节点（Special Nodes）</h2><h3 id="aliases-节点"><a href="#aliases-节点" class="headerlink" title="aliases 节点"></a>aliases 节点</h3><p>引用一个特定的节点通常使用全路径，如<code>/external-bus/ethernet@0</code>,0，但当用户真正想知道的只是“哪个设备是 eth0？”时，这样的全路径就变得很冗长。这时，aliases 节点就可以用于指定一个设备全路径的别名。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">aliases &#123;</div><div class="line">    ethernet0 = &amp;eth0;</div><div class="line">    serial0 = &amp;serial0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当给一个设备分配一个标识符时，操作系统更乐意使用别名。</p>
<p>在这里你会发现一个新语法。<code>property = &amp;label;</code> 语法指定由标签引用的节点的完整路径为一个字符串属性。这与之前的把一个<code>phandle</code>值装入一个 cell的 <code>phandle = &lt; &amp;label &gt;;</code> 形式不同。</p>
<h3 id="chosen-节点"><a href="#chosen-节点" class="headerlink" title="chosen 节点"></a>chosen 节点</h3><p><code>chosen</code> 节点并不代表一个真正的设备，只是作为一个固件和操作系统之间传递数据的地方，比如引导参数。<code>chosen</code>节点里的数据也不代表硬件。通常，<code>chosen</code>节点在<code>.dts</code>源文件中为空，并在启动时填充。</p>
<p>在我们的示例系统中，固件可以往 chosen 节点添加以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">chosen &#123;</div><div class="line">    bootargs = &quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="高级主题（Advanced-Topics）"><a href="#高级主题（Advanced-Topics）" class="headerlink" title="高级主题（Advanced Topics）"></a>高级主题（Advanced Topics）</h2><h3 id="高级模型机（Advanced-Sample-Machine）"><a href="#高级模型机（Advanced-Sample-Machine）" class="headerlink" title="高级模型机（Advanced Sample Machine）"></a>高级模型机（Advanced Sample Machine）</h3><p>现在，我们已经掌握了基本的定义，接下来让我们往模型机里添加一些硬件，以讨论一些更复杂的用例。</p>
<p>高级模型机添加了一个 PCI 主桥，其控制寄存器映射到内存<code>0x10180000</code>，并且 BARs 编程至以<code>0x80000000</code>为起始的地址。</p>
<p>既然关于设备树我们已经有所了解了，那么我们就从以下所示新增加的节点来介绍 PCI 主桥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pci@10180000 &#123;</div><div class="line">    compatible = &quot;arm,versatile-pci-hostbridge&quot;, &quot;pci&quot;;</div><div class="line">    reg = &lt;0x10180000 0x1000&gt;;</div><div class="line">    interrupts = &lt;8 0&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="PCI-主桥（PCI-Host-Bridge）"><a href="#PCI-主桥（PCI-Host-Bridge）" class="headerlink" title="PCI 主桥（PCI Host Bridge）"></a>PCI 主桥（PCI Host Bridge）</h3><p>本节介绍 Host/PCI 桥节点。</p>
<p>注，本节将假定读者了解 PCI 的一些基本知识。本文并不是 PCI 教程，想要了解更深入的信息，请阅读参考文献<sup><a href="#ref-1">1</a></sup>。你也可以参考 ePAPR 或 PCI Bus Binding to Open Firmware（<a href="http://playground.sun.com/1275/bindings/pci/pci2_1.pdf" target="_blank" rel="external">http://playground.sun.com/1275/bindings/pci/pci2_1.pdf</a>）。还可以访问<a href="http://devicetree.org/MPC5200:PCI" target="_blank" rel="external">http://devicetree.org/MPC5200:PCI</a>，这里可以找到 Freescale MPC5200 的一个完整工作的例子。</p>
<h3 id="PCI-总线编号（PCI-Bus-numbering）"><a href="#PCI-总线编号（PCI-Bus-numbering）" class="headerlink" title="PCI 总线编号（PCI Bus numbering）"></a>PCI 总线编号（PCI Bus numbering）</h3><p>每个 PCI 总线段都是唯一编号的，并且总线的编号通过使用<code>bus-ranges</code>属性在 pci 节点中暴露出来的，这个属性包含两个 cell。第一个 cell 给出分配给该节点的总线号；第二个 cell 给出任何次级 PCI 总线最大总线号。</p>
<p>模型机只有一个 pci 总线，所以两个 cell 都是 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pci@0x10180000 &#123;</div><div class="line">    compatible = &quot;arm,versatile-pci-hostbridge&quot;, &quot;pci&quot;;</div><div class="line">    reg = &lt;0x10180000 0x1000&gt;;</div><div class="line">    interrupts = &lt;8 0&gt;;</div><div class="line">    bus-ranges = &lt;0 0&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="PCI-地址转换（PCI-Address-Translation）"><a href="#PCI-地址转换（PCI-Address-Translation）" class="headerlink" title="PCI 地址转换（PCI Address Translation）"></a>PCI 地址转换（PCI Address Translation）</h3><p>类似于前面所描述的本地总线，PCI 地址空间和 CPU 地址空间是完全分离的，所以需要一个从 PCI 地址到 CPU 地址的转换。同样，完成这样的转换将使用<code>ranges</code>、<code>#address-cells</code>和<code>#size-cells</code>属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pci@0x10180000 &#123;</div><div class="line">    compatible = &quot;arm,versatile-pci-hostbridge&quot;, &quot;pci&quot;;</div><div class="line">    reg = &lt;0x10180000 0x1000&gt;;</div><div class="line">    interrupts = &lt;8 0&gt;;</div><div class="line">    bus-ranges = &lt;0 0&gt;;</div><div class="line"></div><div class="line">    #address-cells = &lt;3&gt;</div><div class="line">    #size-cells = &lt;2&gt;;</div><div class="line">    ranges = &lt;0x42000000 0 0x80000000 0x80000000 0 0x20000000</div><div class="line">              0x02000000 0 0xa0000000 0xa0000000 0 0x10000000</div><div class="line">              0x01000000 0 0x00000000 0xb0000000 0 0x01000000&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>正如你所看到的，子地址（PCI 地址）使用 3 个 cell，同时 PCI rangs 被编码为 2 个 cell。那么第一个问题就可能是，为什么我们要用三个 32 位 cell 来指定一个 PCI 地址？ 这三个 cell 分别标记为 phys.hi、phys.mid 和 phys.low<sup><a href="#ref-2">2</a></sup>。</p>
<ul>
<li>phys.hi cell:<code>npt000ss bbbbbbbb dddddfff rrrrrrrr</code></li>
<li>phys.mid cell:<code>hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh</code></li>
<li>phys.low cell:<code>llllllll llllllll llllllll llllllll</code><br>PCI 地址是 64 位的，并被编码为 phys.mid 和 phys.low。然而真正有意思的是在 phys.high 里面，这是一个位域。</li>
<li><code>n</code>: 可重定位区域标志（relocatable region flag）（在这里不起作用）</li>
<li><code>p</code>: 可预取（可缓存）区域标志（prefetchable (cacheable) region flag）</li>
<li><code>t</code>: 地址别名标志（aliased address flag）（在这里不起作用）</li>
<li><code>ss</code>: 空间代码（space code ）<ul>
<li><code>00</code>: 配置空间（configuration space）</li>
<li><code>01</code>: I/O 空间（I/O space）</li>
<li><code>10</code>: 32 位内存空间（32 bit memory space）</li>
<li><code>11</code>: 64 位内存空间（64 bit memory space）</li>
</ul>
</li>
<li><code>bbbbbbbb</code>: PCI 总线号。PCI 可以是分层结构，所以我们可能有 PCI/PCI 桥（用来定义子总线）。</li>
<li><code>ddddd</code>: 设备号，通常与 IDSEL 信号相关联。</li>
<li><code>fff</code>: 功能号。用于多功能 PCI 设备。</li>
<li><p><code>rrrrrrrr</code>: 寄存器号，于配置周期时使用。<br>对于 PCI 地址转换来说，<code>p</code>和<code>ss</code>是最重要的字段。在 phys.hi 里的<code>p</code>和<code>ss</code>的值决定了访问哪个 PCI 地址空间。因此，通过查找 ranges 属性，我们将得到三个区域。</p>
</li>
<li><p>以 PCI 地址<code>0x80000000</code>开始的一个 512 MByte 32 位预取存储区，该区域将映射到主机 CPU 地址<code>0x80000000</code>。</p>
</li>
<li>以 PCI 地址<code>0xa0000000</code>开始的一个 256 MByte 32 位非预取存储区，该区域将映射到主机 CPU 地址<code>0xa0000000</code>。</li>
<li>以 PCI 地址<code>0x00000000</code>开始的一个 16 MByte I/O 区，该区域将映射到主机 CPU 地址<code>0xb0000000</code>。<br>为阻止这些工作，phys.hi 位域的存在就意味着操作系统必须知道该节点代表了一个 PCI 桥，这样操作系统才能为了地址转换而忽略那些不相关的字段。为了判断应该掩码哪些额外的字段，操作系统需要在 PCI 总线节点中寻找“pci”字符串。</li>
</ul>
<h3 id="高级中断映射（Advanced-Interrupt-Mapping）"><a href="#高级中断映射（Advanced-Interrupt-Mapping）" class="headerlink" title="高级中断映射（Advanced Interrupt Mapping）"></a>高级中断映射（Advanced Interrupt Mapping）</h3><p>现在我们来到了最有趣的部分，PCI 中断映射。一个 PCI 设备可以使用引线<code>#INTA</code>、<code>#INTB</code>、<code>#INTC</code>和<code>#INTD</code>来触发中断。如果我们没有多功能 PCI 设备，那么设备中断必须使用<code>#INTA</code>。然而，每个 PCI 插槽或设备通常会连接到中断控制器上不同的输入端。所以设备树需要一种能将各个 PCI 中断信号映射到中断控制器输入端的途径。<code>#interrupt-cells</code>、<code>interrupt-map</code>和<code>interrupt-map-mask</code>属性就被用来描述这个中断映射。</p>
<p>这里所描述的中断映射并不仅仅局限于 PCI 总线，事实上，任何节点都可以指定复杂的中断映射，但 PCI 是最常见的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">pci@0x10180000 &#123;</div><div class="line">    compatible = &quot;arm,versatile-pci-hostbridge&quot;, &quot;pci&quot;;</div><div class="line">    reg = &lt;0x10180000 0x1000&gt;;</div><div class="line">    interrupts = &lt;8 0&gt;;</div><div class="line">    bus-ranges = &lt;0 0&gt;;</div><div class="line"></div><div class="line">    #address-cells = &lt;3&gt;</div><div class="line">    #size-cells = &lt;2&gt;;</div><div class="line">    ranges = &lt;0x42000000 0 0x80000000  0x80000000  0 0x20000000</div><div class="line">              0x02000000 0 0xa0000000  0xa0000000  0 0x10000000</div><div class="line">              0x01000000 0 0x00000000  0xb0000000  0 0x01000000&gt;;</div><div class="line"></div><div class="line">    #interrupt-cells = &lt;1&gt;;</div><div class="line">    interrupt-map-mask = &lt;0xf800 0 0 7&gt;;</div><div class="line">    interrupt-map = &lt;0xc000 0 0 1 &amp;intc  9 3 // 1st slot</div><div class="line">                     0xc000 0 0 2 &amp;intc 10 3</div><div class="line">                     0xc000 0 0 3 &amp;intc 11 3</div><div class="line">                     0xc000 0 0 4 &amp;intc 12 3</div><div class="line"></div><div class="line">                     0xc800 0 0 1 &amp;intc 10 3 // 2nd slot</div><div class="line">                     0xc800 0 0 2 &amp;intc 11 3</div><div class="line">                     0xc800 0 0 3 &amp;intc 12 3</div><div class="line">                     0xc800 0 0 4 &amp;intc  9 3&gt;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>首先你会发现，PCI 中断号只使用了一个 cell，不像系统中断控制器，它使用两个 cell，一个用于中断号，另一个用于标志。PCI 中断只使用了一个 cell，因为 PCI 中断指定为始终是低电平触发。</p>
<p>在这个示例板上，我们有 2 个分别包含 4 个中断线的 PCI 插槽，所以我们需要映射 8 个中断线到中断控制器上。这已经在<code>interrupt-map</code>属性中完成了。关于中断映射的具体步骤请参考<sup><a href="#ref-3">3</a></sup>。</p>
<p>因为要区分单一 PCI 总线上的若干 PCI 设备中断号（<code>#INA</code>等）是不够用的，所以我们还需要指出是哪个 PCI 设备触发了中断线。幸运的是我们还可以使用每个设备所拥有的唯一设备号。为了区分这些 PCI 设备，我们需要一个元组，该元组由 PCI 设备号和 PCI 中断号组成。通俗的说，我们构造了由四个 cell 组成的设备中断指示符。</p>
<ul>
<li>三个<code>#address-cells</code>由 phys.hi、phys.mid、phys.low 组成，然后</li>
<li>一个<code>#interrupt-cell</code>（<code>#INTA</code>、<code>#INTB</code>、<code>#INTC</code>、<code>#INTD</code>）<br>因为我们只需要 PCI 地址中的设备号部分，所以 interrupt-map-mask 发挥了作用。<code>interrupt-map-mask</code>也是 4 元组，就像设备中断指示符一样。掩码的第一部分指出我们应该考虑设备中断指示符中哪一部分。在本例中，我们可以看到在 phys.hi 中只需要设备号部分，另外我们还需要 3 位来区分四个中断线（PCI 中断线是从 1 开始计数的，不是 0！）。</li>
</ul>
<p>现在。我们可以构建<code>interrupt-map</code>属性了。该属性是一个表，这个表的每一项都由一个子（PCI 总线）设备中断指示符、一个父句柄（<code>parent handle</code>）（用于中断服务的中断控制器）和一个父设备中断指示符组成。因此，在第一行中我们可以知道 PCI 中断<code>#INTA</code>将被映射到中断控制器的 IRQ 9，并且是低电平有效。<sup><a href="#ref-4">4</a></sup></p>
<p>目前为止，唯一没有讨论的就是 PCI 总线设备中断指示符里古怪的数字了。来自 phys.hi 位域的设备号是设备中断指示符中的重要组成部分。设备号是平台特定的，并取决于 PCI 主控制器如何激活各个设备的 IDSEL 管脚。在本例中，PCI slot 1 分配设备 id 24（0x18）,PCI slot 2 分配设备 id 25（0x19）。每个 slot 的 phys.hi 值是通过将设备号左移 11 位至位域的<code>ddddd</code>段得到的，就像下面：</p>
<ul>
<li>slot 1 的 phys.hi 就是<code>0xC000</code>， 并且</li>
<li>slot 2 的 phys.hi 就是<code>0xC800</code>。<br>把这些放在一起之后，interrupt-map 属性就显示为：</li>
<li>在主中断控制器上 slot 1 的<code>#INTA</code>是<code>IRQ9</code>，低电平触发</li>
<li>在主中断控制器上 slot 1 的<code>#INTB</code>是<code>IRQ10</code>，低电平触发</li>
<li>在主中断控制器上 slot 1 的<code>#INTC</code>是<code>IRQ11</code>，低电平触发</li>
<li>在主中断控制器上 slot 1 的<code>#INTD</code>是<code>IRQ12</code>，低电平触发<br>而</li>
<li>在主中断控制器上 slot 2 的<code>#INTA</code>是<code>IRQ10</code>，低电平触发</li>
<li>在主中断控制器上 slot 2 的<code>#INTA</code>是<code>IRQ11</code>，低电平触发</li>
<li>在主中断控制器上 slot 2 的<code>#INTA</code>是<code>IRQ12</code>，低电平触发</li>
<li>在主中断控制器上 slot 2 的<code>#INTA</code>是<code>IRQ9</code>，低电平触发<br>属性<code>interrupts = &lt;8 0&gt;;</code>描述了主控制器或 PCI 桥控制器本身有可能触发中断。不要与 PCI 设备触发的中断（使用 INTA，INTB，…）搞混了。</li>
</ul>
<p>最后需要注意的事。就像<code>interrupt-parent</code>属性一样，节点中<code>interrupt-map</code>属性的存在将改变子节点和孙节点的默认中断控制器。在这个 PCI 示例中，这意味着 PCI 主桥变成了默认中断控制器。如果一个通过 PCI 总线连接的设备同时还直接连接至另一个中断控制器，这时就需要指定它自己的 interrupt-parent 属性。</p>
<h2 id="附注（Notes）"><a href="#附注（Notes）" class="headerlink" title="附注（Notes）"></a>附注（Notes）</h2><p><a name="ref-1">[1]</a> Tom Shanley / Don Anderson: PCI System Architecture. <a href="http://www.mindshare.com/" target="_blank" rel="external">Mindshare Inc.</a><br><a name="ref-2">[2]</a> <a href="http://playground.sun.com/1275/bindings/pci/pci2_1.pdf" target="_blank" rel="external">PCI Bus Bindings to Open Firmware.</a><br><a name="ref-3">[3]</a> <a href="http://playground.sun.com/1275/practice/imap/imap0_9d.pdf" target="_blank" rel="external">Open Firmware Recommended Practice: Interrupt Mapping</a><br><a name="ref-4">[4]</a> PCI interrupts are always level low sensitive.（PCI 中断总是低电平触发。）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Relay：一种内核到用户空间的高效数据传输技术]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/relay/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-relay/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-relay/index.html</a></p>
<p>Relay 是一种从 Linux 内核到用户空间的高效数据传输技术。通过用户定义的 relay 通道，内核空间的程序能够高效、可靠、便捷地将数据传输到用户空间。Relay 特别适用于内核空间有大量数据需要传输到用户空间的情形，目前已经广泛应用在内核调试工具如 SystemTap中。本文介绍了 Relay 的历史和原理，并且用一个简单的实例介绍了 Relay 的具体用法。<br><a id="more"></a></p>
<h2 id="Relay要解决的问题"><a href="#Relay要解决的问题" class="headerlink" title="Relay要解决的问题"></a>Relay要解决的问题</h2><p>对于任何在内核工作的程序而言，如何把大量的调试信息从内核空间传输到用户空间都是一个大麻烦，对于运行中的内核更是如此。特别是对于哪些用于调试内核性能的工具，更是如此。</p>
<p>对于这种大量数据需要在内核中缓存并传输到用户空间需求，很多传统的方法都已到达了极限，例如内核程序员很熟悉的<code>printk()</code>调用。此外，如果不同的内核子系统都开发自己的缓存和传输代码，造成很大的代码冗余，而且也带来维护上的困难。</p>
<p>这些，都要求开发一套能够高效可靠地将数据从内核空间转发到用户空间的系统，而且这个系统应该独立于各个调试子系统。</p>
<p>这样就诞生了 RelayFS。</p>
<h2 id="Relay的发展历史"><a href="#Relay的发展历史" class="headerlink" title="Relay的发展历史"></a>Relay的发展历史</h2><p>Relay的前身是RelayFS，即作为Linux的一个新型文件系统。2003年3月，RelayFS的第一个版本的代码被开发出来，在7月14日，第一个针对2.6内核的版本也开始提供下载。经过广泛的试用和改进，直到2005年9月，RelayFS才被加入mainline内核(2.6.14)。同时，RelayFS也被移植到2.4内核中。在2006年2月，从2.6.17开始，RelayFS不再作为单独的文件系统存在，而是成为内核的一部分。它的源码也从fs/目录下转移到kernel/relay.c中，名称中也从RelayFS改成了Relay。</p>
<p>RelayFS目前已经被越来越多的内核工具使用，包括内核调试工具SystemTap、LTT，以及一些特殊的文件系统例如DebugFS。</p>
<h2 id="Relay的基本原理"><a href="#Relay的基本原理" class="headerlink" title="Relay的基本原理"></a>Relay的基本原理</h2><p>总的说来，Relay提供了一种机制，使得内核空间的程序能够通过用户定义的relay通道(channel)将大量数据高效的传输到用户空间。</p>
<p>一个relay通道由一组和CPU一一对应的内核缓冲区组成。这些缓冲区又被称为relay缓冲区(buffer)，其中的每一个在用户空间都用一个常规文件来表示，这被叫做relay文件(file)。内核空间的用户可以利用relay提供的API接口来写入数据，这些数据会被自动的写入当前的CPU id对应的那个relay缓冲区；同时，这些缓冲区从用户空间看来，是一组普通文件，可以直接使用read()进行读取，也可以使用mmap()进行映射。Relay并不关心数据的格式和内容，这些完全依赖于使用relay的用户程序。Relay的目的是提供一个足够简单的接口，从而使得基本操作尽可能的高效。</p>
<p>Relay将数据的读和写分离，使得突发性大量数据写入的时候，不需要受限于用户空间相对较慢的读取速度，从而大大提高了效率。Relay作为写入和读取的桥梁，也就是将内核用户写入的数据缓存并转发给用户空间的程序。这种转发机制也正是Relay这个名称的由来。</p>
<p>下面这个图给出了Relay的基本结构和典型操作：<br><img src="/kernel/内核文件系统/relay/relay.png" alt="relay.png" title=""><br>可以看到，这里的relay通道由四个relay缓冲区(<code>kbuf0</code>到<code>kbuf3</code>)组成，分别对应于系统中的<code>cpu0</code>到<code>cpu3</code>。每个CPU上的代码调用<code>relay_write()</code>的时候将数据写入自己对应的relay缓冲区内。每个relay缓冲区称一个relay文件，即<code>/cpu0</code>到<code>/cpu3</code>。当文件系统被mount到<code>/mnt/</code>以后，这个relay文件就被映射成映射到用户空间的地址空间。一旦数据可用，用户程序就可以把它的数据读出来写入到硬盘上的文件中，即<code>cpu0.out</code>到<code>cpu3.out</code>。</p>
<h2 id="Relay的主要API"><a href="#Relay的主要API" class="headerlink" title="Relay的主要API"></a>Relay的主要API</h2><p>前面提到的<code>relay_write()</code>就是 relay API 之一。除此以外，Relay 还提供了更多的 API来支持用户程序完整的使用 relay。这些 API，主要按照面向用户空间和面向内核空间分为两大类，下面我们来分别进行介绍。</p>
<p><strong>面向用户空间的API</strong></p>
<p>这些 Relay 编程接口向用户空间程序提供了访问 relay 通道缓冲区数据的基本操作的入口，包括：</p>
<ul>
<li><code>open()</code> 允许用户打开一个已经存在的通道缓冲区</li>
<li><code>mmap()</code> 使通道缓冲区被映射到位于用户空间的调用者的地址空间。要特别注意的是，我们不能仅对局部区域进行映射。也就是说，必须映射整个缓冲区文件，其大小是CPU的个数和单个CPU缓冲区大小的乘积</li>
<li><code>read()</code> 读取通道缓冲区的内容。这些数据一旦被读出，就意味着他们被用户空间的程序消费掉了，也就不能被之后的读操作看到</li>
<li><code>sendfile()</code> 将数据从通道缓冲区传输到一个输出文件描述符。其中可能的填充字符会被自动去掉，不会被用户看到</li>
<li><code>poll()</code> 支持 POLLIN/POLLRDNORM/POLLERR 信号。每次子缓冲区的边界被越过时，等待着的用户空间程序会得到通知</li>
<li><code>close()</code> 将通道缓冲区的引用数减1。当引用数减为0时，表明没有进程或者内核用户需要打开它，从而这个通道缓冲区被释放。</li>
</ul>
<p><strong>面向内核空间的API</strong></p>
<p>这些API接口向位于内核空间的用户提供了管理relay通道、数据写入等功能。下面介绍其中主要的部分，完整的API接口列表请参见这里。</p>
<ul>
<li><code>relay_open()</code> 创建一个relay通道，包括创建每个CPU对应的relay缓冲区。</li>
<li><code>relay_close()</code> 关闭一个relay通道，包括释放所有的relay缓冲区，在此之前会调用<code>relay_switch()</code>来处理这些relay缓冲区以保证已读取但是未满的数据不会丢失。</li>
<li><code>relay_write()</code> 将数据写入到当前CPU对应的relay缓冲区内。由于它使用了<code>local_irqsave()</code>保护，因此也可以在中断上下文中使用。</li>
<li><code>relay_reserve()</code> 在relay通道中保留一块连续的区域来留给未来的写入操作。这通常用于那些希望直接写入到relay缓冲区的用户。考虑到性能或者其它因素，这些用户不希望先把数据写到一个临时缓冲区中，然后再通过<code>relay_write()</code>进行写入。</li>
</ul>
<h2 id="Relay的例子"><a href="#Relay的例子" class="headerlink" title="Relay的例子"></a>Relay的例子</h2><p>我们用一个最简单的例子来介绍怎么使用Relay。这个例子由两部分组成：一部分是位于内核空间将数据写入relay文件的程序，使用时需要作为一个内核模块被加载；另一部分是位于用户空间从relay文件中读取数据的程序，使用时作为普通用户态程序运行。</p>
<p><strong>内核空间的程序主要操作</strong></p>
<ul>
<li>加载模块时，打开一个relay通道，并且往打开的relay通道中写入消息；</li>
<li>卸载模块时，关闭relay通道。</li>
</ul>
<p>程序内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * hello-mod.c</div><div class="line"> * a kernel-space client example of relayfs filesystem</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/relayfs_fs.h&gt;</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> rchan *hello_rchan;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_module</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *msg=<span class="string">"Hello world\n"</span>;</div><div class="line">        hello_rchan = relay_open(<span class="string">"cpu"</span>, <span class="literal">NULL</span>, <span class="number">8192</span>, <span class="number">2</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span>(!hello_rchan)&#123;</div><div class="line">                printk(<span class="string">"relay_open() failed.\n"</span>);</div><div class="line">                <span class="keyword">return</span> -ENOMEM;</div><div class="line">        &#125;</div><div class="line">        relay_write(hello_rchan, msg, <span class="built_in">strlen</span>(msg));</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span>(hello_rchan) &#123;</div><div class="line">                relay_close(hello_rchan);</div><div class="line">                hello_rchan = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line">MODULE_LICENSE (<span class="string">"GPL"</span>);</div><div class="line">MODULE_DESCRIPTION (<span class="string">"Simple example of Relay"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>用户空间的函数主要操作</strong></p>
<ul>
<li>如果relayfs文件系统还没有被mount，则将其mount到目录/mnt/relay上；</li>
<li>遍历每一个CPU对应的缓冲文件<ul>
<li>打开文件</li>
<li>读取所有文件内容</li>
<li>关闭文件</li>
</ul>
</li>
<li>最后，umount掉relay文件系统。</li>
</ul>
<p>程序内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * audience.c</div><div class="line"> * a user-space client example of relayfs filesystem</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mount.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFLEN 256</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> filename_base[]=<span class="string">"/mnt/relay/cpu"</span>;</div><div class="line"><span class="comment">// implement your own get_cputotal() before compilation</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_cputotal</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">char</span> filename[<span class="number">128</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">char</span> buf[MAX_BUFLEN];</div><div class="line">        <span class="keyword">int</span> fd, c, i, bytesread, cputotal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(mount(<span class="string">"relayfs"</span>, <span class="string">"/mnt/relay"</span>, <span class="string">"relayfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>)</div><div class="line">                        &amp;&amp; (errno != EBUSY)) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"mount() failed: %s\n"</span>, strerror(errno));</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        cputotal = get_cputotal();</div><div class="line">        <span class="keyword">if</span>(cputotal &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"invalid cputotal value: %d\n"</span>, cputotal);</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;cputotal; i++) &#123;</div><div class="line">                <span class="comment">// open per-cpu file</span></div><div class="line">                <span class="built_in">sprintf</span>(filename, <span class="string">"%s%d"</span>, filename_base, i);</div><div class="line">                fd = open(filename, O_RDONLY);</div><div class="line">                <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</div><div class="line">                        <span class="built_in">printf</span>(<span class="string">"fopen() failed: %s\n"</span>, strerror(errno));</div><div class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// read per-cpu file</span></div><div class="line">                bytesread = read(fd, buf, MAX_BUFLEN);</div><div class="line">                <span class="keyword">while</span>(bytesread &gt; <span class="number">0</span>) &#123;</div><div class="line">                        buf[bytesread] = <span class="string">'\0'</span>;</div><div class="line">                        <span class="built_in">puts</span>(buf);</div><div class="line">                        bytesread = read(fd, buf, MAX_BUFLEN);</div><div class="line">                &#125;;</div><div class="line">                <span class="comment">// close per-cpu file</span></div><div class="line">                <span class="keyword">if</span>(fd &gt; <span class="number">0</span>) &#123;</div><div class="line">                        close(fd);</div><div class="line">                        fd = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(umount(<span class="string">"/mnt/relay"</span>) &amp;&amp; (errno != EINVAL)) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"umount() failed: %s\n"</span>, strerror(errno));</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子给出了使用relay的一个最简单的情形，并没有实际用处，但是形象描述了从用户空间和内核空间两个方面使用relay的基本流程。实际应用中对relay的使用当然要比这复杂得多。更多的例子请参见relay的主页。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Relay的主页：<a href="http://relayfs.sourceforge.net/" target="_blank" rel="external">http://relayfs.sourceforge.net/</a><br>示例代码： <a href="/kernel/内核文件系统/relay/relay-apps-0.94.tar.gz" title="relay-apps-0.94.tar.gz">relay-apps-0.94.tar.gz</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux LCD 驱动学习]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/linux-lcd-driver/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/gzliu_hit/article/details/6719457" target="_blank" rel="external">S3C2410 LCD驱动学习心得</a></p>
<h2 id="实验内容简要描述"><a href="#实验内容简要描述" class="headerlink" title="实验内容简要描述"></a>实验内容简要描述</h2><p><strong>1．实验目的</strong><br>学会驱动程序的编写方法，配置S3C2410的LCD驱动，以及在LCD屏上显示包括bmp和jpeg两种格式的图片<br><strong>2．实验内容</strong><br>（1）分析S3c2410实验箱LCD以及LCD控制器的硬件原理，据此找出相应的硬件设置参数，参考xcale实验箱关于lcd的设置，完成s3c2410实验箱LCD的设置<br>（2）在LCD上显示一张BMP图片或JPEG图片<br><strong>3．实验条件（软硬件环境）</strong><br>PC机、S3C2410开发板、PXA255开发板<br><a id="more"></a></p>
<h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><h3 id="S3C2410内置LCD控制器分析"><a href="#S3C2410内置LCD控制器分析" class="headerlink" title="S3C2410内置LCD控制器分析"></a>S3C2410内置LCD控制器分析</h3><h4 id="S3C2410-LCD控制器"><a href="#S3C2410-LCD控制器" class="headerlink" title="S3C2410 LCD控制器"></a>S3C2410 LCD控制器</h4><p>一块LCD屏显示图像，不但需要LCD驱动器，还需要有相应的LCD控制器。通常LCD驱动器会以COF/COG的形式与LCD玻璃基板制作在一起，而LCD控制器则由外部电路来实现。而S3C2410内部已经集成了LCD控制器，因此可以很方便地去控制各种类型的LCD屏，例如：STN和TFT屏。S3C2410 LCD控制器的特性如下：  </p>
<ol>
<li>STN屏<br>支持3种扫描方式：4bit单扫、4位双扫和8位单扫<br>支持单色、4级灰度和16级灰度屏<br>支持256色和4096色彩色STN屏（CSTN）<br>支持分辩率为640<em>480、320</em>240、160*160以及其它规格的多种LCD</li>
<li>TFT屏<br>支持单色、4级灰度、256色的调色板显示模式<br>支持64K和16M色非调色板显示模式<br>支持分辩率为640<em>480，320</em>240及其它多种规格的LCD<br>对于控制TFT屏来说，除了要给它送视频资料（<code>VD[23:0]</code>）以外，还有以下一些信号是必不可少的，分别是：<br><code>VSYNC(VFRAME)</code>：帧同步信号<br><code>HSYNC(VLINE)</code>：行同步信号<br><code>VCLK</code>：像数时钟信号<br><code>VDEN(VM)</code>：数据有效标志信号</li>
</ol>
<p>由于本项目所用的S3C2410上的LCD是TFT屏，并且TFT屏将是今后应用的主流，因此接下来，重点围绕TFT屏的控制来进行。<br>图1.1 是S3C2410内部的LCD控制器的逻辑示意图：</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd1.jpg" alt="图1.1" title="图1.1">
<p><code>REGBANK</code> 是LCD控制器的寄存器组，用来对LCD控制器的各项参数进行设置。而 <code>LCDCDMA</code> 则是LCD控制器专用的DMA信道，负责将视频资料从系统总线（System Bus）上取来，通过 <code>VIDPRCS</code> 从<code>VD[23:0]</code>发送给LCD屏。同时 <code>TIMEGEN</code> 和 <code>LPC3600</code> 负责产生 LCD屏所需要的控制时序，例如<code>VSYNC</code>、<code>HSYNC</code>、<code>VCLK</code>、<code>VDEN</code>，然后从 <code>VIDEO MUX</code> 送给LCD屏。</p>
<h4 id="TFT屏时序分析"><a href="#TFT屏时序分析" class="headerlink" title="TFT屏时序分析"></a>TFT屏时序分析</h4><p>图1.2 是TFT屏的典型时序。其中<code>VSYNC</code>是帧同步信号，<code>VSYNC</code>每发出1个脉冲，都意味着新的1屏视频资料开始发送。而<code>HSYNC</code>为行同步信号，每个<code>HSYNC</code>脉冲都表明新的1行视频资料开始发送。而<code>VDEN</code>则用来标明视频资料的有效，<code>VCLK</code>是用来锁存视频资料的像数时钟。<br>在帧同步以及行同步的头尾都必须留有回扫时间，例如对于<code>VSYNC</code>来说前回扫时间就是<code>(VSPW+1)＋(VBPD+1)</code>，后回扫时间就是<code>(VFPD +1)</code>；<code>HSYNC</code>亦类同。这样的时序要求是当初CRT显示器由于电子枪偏转需要时间，但后来成了实际上的工业标准，乃至于后来出现的TFT屏为了在时序上与CRT兼容，也采用了这样的控制时序。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd2.jpg" alt="图1.2" title="图1.2">
<p>S3C2410实验箱上的LCD是一款3.5寸TFT真彩LCD屏，分辩率为240*320，下图为该屏的时序要求。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd3.jpg" alt="图1.3" title="图1.3">
<p>通过对比图1.2和图1.3，我们不难看出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">VSPW+1=2 =&gt; VSPW=1</div><div class="line">VBPD+1=2 =&gt; VBPD=1</div><div class="line">LINVAL+1=320 =&gt; LINVAL=319</div><div class="line">VFPD+1=3 =&gt; VFPD=2</div><div class="line">HSPW+1=4 =&gt; HSPW=3</div><div class="line">HBPD+1=7 =&gt; HBPW=6</div><div class="line">HOZVAL+1=240 =&gt; HOZVAL=239</div><div class="line">HFPD+1=31 =&gt; HFPD=30</div></pre></td></tr></table></figure></p>
<p>以上各参数，除了<code>LINVAL</code>和<code>HOZVAL</code>直接和屏的分辩率有关，其它的参数在实际操作过程中应以上面的为参考，不应偏差太多。</p>
<h4 id="LCD控制器主要寄存器功能详解"><a href="#LCD控制器主要寄存器功能详解" class="headerlink" title="LCD控制器主要寄存器功能详解"></a>LCD控制器主要寄存器功能详解</h4><img src="/kernel/设备驱动/linux-lcd-driver/lcd4.jpg" alt="图1.4" title="图1.4">
<p><code>LINECNT</code>：当前行扫描计数器值，标明当前扫描到了多少行。<br><code>CLKVAL</code>：决定VCLK的分频比。LCD控制器输出的VCLK是直接由系统总线（AHB）的工作频率HCLK直接分频得到的。作为240*320的TFT屏，应保证得出的VCLK在5~10MHz之间。<br><code>MMODE</code>：VM信号的触发模式（仅对STN屏有效，对TFT屏无意义）。<br><code>PNRMODE</code>：选择当前的显示模式，对于TFT屏而言，应选择<code>[11]</code>，即TFT LCD panel。<br><code>BPPMODE</code>：选择色彩模式，对于真彩显示而言，选择16bpp（64K色）即可满足要求。<br><code>ENVID</code>：使能LCD信号输出。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd5.jpg" alt="图1.5" title="图1.5">
<p><code>VBPD</code>， <code>LINEVAL</code>， <code>VFPD</code>， <code>VSPW</code> 的各项含义已经在前面的时序图中得到体现。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd6.jpg" alt="图1.6" title="图1.6">
<p><code>HBPD</code>， <code>HOZVAL</code>， <code>HFPD</code> 的各项含义已经在前面的时序图中得到体现。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd7.jpg" alt="图1.7" title="图1.7">
<p><code>HSPW</code> 的含义已经在前面的时序图中得到体现。<br><code>MVAL</code> 只对STN屏有效，对TFT屏无意义。<br><code>HSPW</code> 的含义已经在前面的时序图中得到体现，这里不再赘述。<br><code>MVAL</code> 只对STN屏有效，对TFT屏无意义。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd8.jpg" alt="图1.8" title="图1.8">
<p><code>VSTATUS</code>：当前<code>VSYNC</code>信号扫描状态，指明当前<code>VSYNC</code>同步信号处于何种扫描阶段。<br><code>HSTATUS</code>：当前<code>HSYNC</code>信号扫描状态，指明当前<code>HSYNC</code>同步信号处于何种扫描阶段。<br><code>BPP24BL</code>：设定<code>24bpp</code>显示模式时，视频资料在显示缓冲区中的排列顺序（即低位有效还是高位有效）。对于<code>16bpp</code>的64K色显示模式，该设置位无意义。<br><code>FRM565</code>：对于<code>16bpp</code>显示模式，有2种形式，一种是<code>RGB = 5:5:5:1</code>，另一种是<code>5:6:5</code>。后一种模式最为常用，它的含义是表示64K种色彩的16bit RGB资料中，红色（R）占了5bit，绿色（G）占了6bit，蓝色（B）占了5bit<br><code>INVVCLK</code>，<code>INVLINE</code>，<code>INVFRAME</code>，<code>INVVD</code>：通过前面的时序图，我们知道，CPU的LCD控制器输出的时序默认是正脉冲，而LCD需要<code>VSYNC(VFRAME)</code>、<code>VLINE(HSYNC)</code>均为负脉冲，因此 <code>INVLINE</code> 和 <code>INVFRAME</code> 必须设为“1”，即选择反相输出。</p>

<p><code>INVVDEN</code>，<code>INVPWREN</code>，<code>INVLEND</code> 的功能同前面的类似。<br><code>PWREN</code> 为LCD电源使能控制。在CPU LCD控制器的输出信号中，有一个电源使能管脚<code>LCD_PWREN</code>，用来做为LCD屏电源的开关信号。<br><code>ENLEND</code> 对普通的TFT屏无效，可以不考虑。<br><code>BSWP</code> 和 <code>HWSWP</code> 为字节（Byte）或半字（Half-Word）交换使能。由于不同的GUI对FrameBuffer（显示缓冲区）的管理不同，必要时需要通过调整 <code>BSWP</code> 和 <code>HWSWP</code> 来适应GUI。</p>
<h3 id="Linux-驱动"><a href="#Linux-驱动" class="headerlink" title="Linux 驱动"></a>Linux 驱动</h3><h4 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h4><p>Linux是工作在保护模式下，所以用户态进程是无法像DOS那样使用显卡BIOS里提供的中断调用来实现直接写屏，Linux仿显卡的功能，将显存抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。Framebuffer机制将硬件结构抽象掉，可以通过Framebuffer的读写直接对显存进行操作。用户可以将Framebuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由Framebuffer设备驱动来完成的。</p>
<p>在Linux系统下，FrameBuffer的主要的结构如图所示。Linux为了开发FrameBuffer程序的方便，使用了分层结构。<code>fbmem.c</code> 处于Framebuffer设备驱动技术的中心位置。它为上层应用程序提供系统调用，也为下一层的特定硬件驱动提供接口；那些底层硬件驱动需要用到这儿的接口来向系统内核注册它们自己。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd10.jpg" alt="图2.1" title="图2.1">
<p><code>fbmem.c</code> 为所有支持FrameBuffer的设备驱动提供了通用的接口，避免重复工作。下将介绍<code>fbmem.c</code>主要的一些数据结构。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="Linux-FrameBuffer的数据结构"><a href="#Linux-FrameBuffer的数据结构" class="headerlink" title="Linux FrameBuffer的数据结构"></a>Linux FrameBuffer的数据结构</h5><p>在FrameBuffer中，<code>fb_info</code>可以说是最重要的一个结构体，它是Linux为帧缓冲设备定义的驱动层接口。它不仅包含了底层函数，而且还有记录设备状态的数据。每个帧缓冲设备都与一个<code>fb_info</code>结构相对应。<code>fb_info</code>的主要成员如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> fb_info &#123;</div><div class="line">    <span class="keyword">int</span> node;</div><div class="line">    <span class="keyword">struct</span> fb_var_screeninfo var; <span class="comment">/* Current var */</span></div><div class="line">    <span class="keyword">struct</span> fb_fix_screeninfo fix; <span class="comment">/* Current fix */</span></div><div class="line">    <span class="keyword">struct</span> fb_videomode *mode;    <span class="comment">/* current mode */</span></div><div class="line"></div><div class="line">    <span class="keyword">struct</span> fb_ops *fbops;</div><div class="line">    <span class="keyword">struct</span> device *device; <span class="comment">/* This is the parent */</span></div><div class="line">    <span class="keyword">struct</span> device *dev;    <span class="comment">/* This is this fb device */</span></div><div class="line"></div><div class="line">    <span class="keyword">char</span> __iomem *screen_base; <span class="comment">/* Virtual address */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> screen_size; <span class="comment">/* Amount of ioremapped VRAM or 0 */</span></div><div class="line">    …………</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中<code>node</code>成员域标示了特定的FrameBuffer，实际上也就是一个FrameBuffer设备的次设备号。<code>fb_var_screeninfo</code>结构体成员记录用户可修改的显示控制器参数，包括屏幕分辨率和每个像素点的比特数。<code>fb_var_screeninfo</code>中的<code>xres</code>定义屏幕一行有多少个点, <code>yres</code>定义屏幕一列有多少个点, <code>bits_per_pixel</code>定义每个点用多少个字节表示。其他域见以下代码注释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> fb_var_screeninfo &#123;</div><div class="line">    __u32 xres;   <span class="comment">/* visible resolution */</span></div><div class="line">    __u32 yres;</div><div class="line">    __u32 xoffset;  <span class="comment">/* offset from virtual to visible */</span></div><div class="line">    __u32 yoffset;  <span class="comment">/* resolution */</span></div><div class="line">    __u32 bits_per_pixel; <span class="comment">/* bits/pixel */</span></div><div class="line">    __u32 pixclock; <span class="comment">/* pixel clock in ps (pico seconds) */</span></div><div class="line">    __u32 left_margin;  <span class="comment">/* time from sync to picture */</span></div><div class="line">    __u32 right_margin; <span class="comment">/* time from picture to sync */</span></div><div class="line">    __u32 hsync_len;  <span class="comment">/* length of horizontal sync */</span></div><div class="line">    __u32 vsync_len;  <span class="comment">/* length of vertical sync */</span></div><div class="line">    …………</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在<code>fb_info</code>结构体中，<code>fb_fix_screeninfo</code>中记录用户不能修改的显示控制器的参数，如屏幕缓冲区的物理地址，长度。当对帧缓冲设备进行映射操作的时候，就是从<code>fb_fix_screeninfo</code>中取得缓冲区物理地址的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> fb_fix_screeninfo &#123;</div><div class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];        <span class="comment">/* identification string eg "TT Builtin" */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> smem_start;    <span class="comment">/* Start of frame buffer mem (physical address) */</span></div><div class="line">    __u32 smem_len;     <span class="comment">/* Length of frame buffer mem */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmio_start;    <span class="comment">/* Start of Mem Mapped I/O(physical address) */</span></div><div class="line">    __u32 mmio_len;      <span class="comment">/* Length of Memory Mapped I/O  */</span></div><div class="line">    …………</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>fb_info</code>还有一个很重要的域就是<code>fb_ops</code>。它是提供给底层设备驱动的一个接口。通常我们编写字符驱动的时候，要填写一个<code>file_operations</code>结构体，并使用<code>register_chrdev()</code>注册之，以告诉Linux如何操控驱动。当我们编写一个FrameBuffer的时候，就要依照Linux FrameBuffer编程的套路，填写<code>fb_ops</code>结构体。这个<code>fb_ops</code>也就相当于通常的<code>file_operations</code>结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> fb_ops &#123;</div><div class="line">    <span class="keyword">int</span> (*fb_open)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">int</span> user);</div><div class="line">    <span class="keyword">int</span> (*fb_release)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">int</span> user);</div><div class="line">    <span class="keyword">ssize_t</span> (*fb_read)(<span class="keyword">struct</span> file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</div><div class="line">    <span class="keyword">ssize_t</span> (*fb_write)(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</div><div class="line">    <span class="keyword">int</span> (*fb_set_par)(<span class="keyword">struct</span> fb_info *info);</div><div class="line">    <span class="keyword">int</span> (*fb_setcolreg)(<span class="keyword">unsigned</span> regno, <span class="keyword">unsigned</span> red, <span class="keyword">unsigned</span> green,</div><div class="line">        <span class="keyword">unsigned</span> blue, <span class="keyword">unsigned</span> transp, <span class="keyword">struct</span> fb_info *info);</div><div class="line">    <span class="keyword">int</span> (*fb_setcmap)(<span class="keyword">struct</span> fb_cmap *cmap, <span class="keyword">struct</span> fb_info *info)</div><div class="line">    <span class="keyword">int</span> (*fb_mmap)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> vm_area_struct *vma);</div><div class="line">    ……………</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的结构体，根据函数的名字就可以看出它的作用，这里不在一一说明。下图给出了Linux FrameBuffer的总体结构，作为这一部分的总结。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd11.jpg" alt="图2.2" title="图2.2">
<h5 id="S3C2410中LCD的数据结构"><a href="#S3C2410中LCD的数据结构" class="headerlink" title="S3C2410中LCD的数据结构"></a>S3C2410中LCD的数据结构</h5><p>在S3C2410的LCD设备驱动中，定义了<code>s3c2410fb_info</code>来标识一个LCD设备，结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s3c2410fb_info &#123;</div><div class="line">    <span class="keyword">struct</span> fb_info  *fb;</div><div class="line">    <span class="keyword">struct</span> device  *dev;</div><div class="line">    <span class="keyword">struct</span> s3c2410fb_mach_info *mach_info;</div><div class="line">    <span class="keyword">struct</span> s3c2410fb_hw regs;  <span class="comment">/* LCD Hardware Regs */</span></div><div class="line">    <span class="keyword">dma_addr_t</span>  map_dma;  <span class="comment">/* physical */</span></div><div class="line">    u_char *   map_cpu;   <span class="comment">/* virtual */</span></div><div class="line">    u_int   map_size;</div><div class="line">    <span class="comment">/* addresses of pieces placed in raw buffer */</span></div><div class="line">    u_char *   screen_cpu;  <span class="comment">/* virtual address of buffer */</span></div><div class="line">    <span class="keyword">dma_addr_t</span>  screen_dma; <span class="comment">/* physical address of buffer */</span></div><div class="line">    …………</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>成员变量fb指向我们上面所说明的<code>fb_info</code>结构体，代表了一个FrameBuffer。<code>dev</code>则表示了这个LCD设备。<code>map_dma</code>，<code>map_cpu</code>，<code>map_size</code>这三个域指向了开辟给LCD DMA使用的内存地址。<code>screen_cpu</code>，<code>screen_dma</code>指向了LCD控制器映射的内存地址。另外regs标识了LCD控制器的寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s3c2410fb_hw &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lcdcon1;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lcdcon2;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lcdcon3;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lcdcon4;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lcdcon5;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个寄存器和硬件的寄存器一一对应，主要作为实际寄存器的映像，以便程序使用。<br>这个<code>s3c2410fb_info</code>中还有一个<code>s3c2410fb_mach_info</code>成员域。它存放了和体系结构相关的一些信息，如时钟、LCD设备的GPIO口等等。这个结构体定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> s3c2410fb_mach_info &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fixed_syncs; <span class="comment">/* do not update sync/border */</span></div><div class="line">    <span class="keyword">int</span> type;      <span class="comment">/* LCD types */</span></div><div class="line">    <span class="keyword">int</span> width;     <span class="comment">/* Screen size */</span></div><div class="line">    <span class="keyword">int</span> height;</div><div class="line">    <span class="keyword">struct</span> s3c2410fb_val xres;  <span class="comment">/* Screen info */</span></div><div class="line">    <span class="keyword">struct</span> s3c2410fb_val yres;</div><div class="line">    <span class="keyword">struct</span> s3c2410fb_val bpp;</div><div class="line">    <span class="keyword">struct</span> s3c2410fb_hw  regs;  <span class="comment">/* lcd configuration registers */</span></div><div class="line">    <span class="comment">/* GPIOs */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> gpcup;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> gpcup_mask;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> gpccon;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> gpccon_mask;</div><div class="line">    …………</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd12.jpg" alt="图2.3" title="图2.3">
<p>上图表示了S3C2410驱动的整体结构，反映了结构体之间的相互关系</p>
<h4 id="主要代码结构以及关键代码分析"><a href="#主要代码结构以及关键代码分析" class="headerlink" title="主要代码结构以及关键代码分析"></a>主要代码结构以及关键代码分析</h4><h5 id="FrameBuffer驱动的统一管理"><a href="#FrameBuffer驱动的统一管理" class="headerlink" title="FrameBuffer驱动的统一管理"></a>FrameBuffer驱动的统一管理</h5><p><code>fbmem.c</code>实现了Linux FrameBuffer的中间层，任何一个FrameBuffer驱动，在系统初始化时，必须向<code>fbmem.c</code>注册，即需要调用<code>register_framebuffer()</code>函数，在这个过程中，设备驱动的信息将会存放入名称为<code>registered_fb</code>数组中，这个数组定义为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> fb_info *registered_fb[FB_MAX];</div><div class="line"><span class="keyword">int</span> num_registered_fb;</div></pre></td></tr></table></figure></p>
<p>它是类型为<code>fb_info</code>的数组，另外<code>num_register_fb</code>则存放了注册过的设备数量。<br>我们分析一下<code>register_framebuffer</code>的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_framebuffer</span><span class="params">(<span class="keyword">struct</span> fb_info *fb_info)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">struct</span> fb_event event;</div><div class="line">    <span class="keyword">struct</span> fb_videomode mode;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (num_registered_fb == FB_MAX) <span class="keyword">return</span> -ENXIO; <span class="comment">/* 超过最大数量 */</span></div><div class="line">    num_registered_fb++;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; FB_MAX; i++)</div><div class="line">        <span class="keyword">if</span> (!registered_fb[i]) <span class="keyword">break</span>;     <span class="comment">/* 找到空余的数组空间 */</span></div><div class="line">    fb_info-&gt;node = i;</div><div class="line"></div><div class="line">    fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,</div><div class="line">        MKDEV(FB_MAJOR, i), <span class="string">"fb%d"</span>, i);  <span class="comment">/* 为设备建立设备节点 */</span></div><div class="line">    <span class="keyword">if</span> (IS_ERR(fb_info-&gt;dev)) &#123;</div><div class="line">     …………</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fb_init_device(fb_info);      <span class="comment">/* 初始化改设备 */</span></div><div class="line">    &#125;</div><div class="line">    …………</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可知，当FrameBuffer驱动进行注册的时候，它将驱动的<code>fb_info</code>结构体记录到全局数组<code>registered_fb</code>中，并动态建立设备节点，进行设备的初始化。注意，这里建立的设备节点的次设备号就是该驱动信息在<code>registered_fb</code>存放的位置，即数组下标 <code>i</code>。在完成注册之后，<code>fbmem.c</code>就记录了驱动的<code>fb_info</code>。这样我们就有可能实现<code>fbmem.c</code>对全部FrameBuffer驱动的统一处理。</p>
<h5 id="实现消息的分派"><a href="#实现消息的分派" class="headerlink" title="实现消息的分派"></a>实现消息的分派</h5><p><code>fbmem.c</code>实现了对系统全部FrameBuffer设备的统一管理。当用户尝试使用一个特定的FrameBuffer时，<code>fbmem.c</code>怎么知道该调用哪个特定的设备驱动呢？<br>我们知道，Linux是通过主设备号和次设备号，对设备进行唯一标识。不同的FrameBuffer设备向<code>fbmem.c</code>注册时，程序分配给它们的主设备号是一样的，而次设备号是不一样的。于是我们就可以通过用户指明的次设备号，来决定具体该调用哪一个FrameBuffer驱动。下面通过分析<code>fbmem.c</code>的<code>fb_open()</code>函数来说明。（注：一般我们写FrameBuffer驱动不需要实现open函数，这里只是说明函数流程。）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fb_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> fbidx = iminor(inode);</div><div class="line">    <span class="keyword">struct</span> fb_info *info;</div><div class="line">    <span class="keyword">int</span> res;</div><div class="line">       <span class="comment">/* 得到真正驱动的函数指针 */</span></div><div class="line">    <span class="keyword">if</span> (!(info = registered_fb[fbidx])) <span class="keyword">return</span> -ENODEV; </div><div class="line">    <span class="keyword">if</span> (info-&gt;fbops-&gt;fb_open) &#123;</div><div class="line">        res = info-&gt;fbops-&gt;fb_open(info,<span class="number">1</span>); <span class="comment">//调用驱动的open()</span></div><div class="line">        <span class="keyword">if</span> (res)  module_put(info-&gt;fbops-&gt;owner);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当用户打开一个FrameBuffer设备的时，将调用这里的<code>fb_open()</code>函数。传进来的<code>inode</code>就是欲打开设备的设备号，包括主设备和次设备号。<code>fb_open</code>函数首先通过<code>iminor()</code>函数取得次设备号，然后查全局数组<code>registered_fb</code>得到设备的<code>fb_info</code>信息，而这里面存放了设备的操作函数集<code>fb_ops</code>。这样，我们就可以调用具体驱动的<code>fb_open()</code>函数，实现<code>open</code>的操作。下面给出了一个LCD驱动的<code>open()</code>函数的调用流程图，用以说明上面的步骤。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd13.jpg" alt="图2.4" title="图2.4">
<h5 id="开发板S3C2410-LCD驱动的流程"><a href="#开发板S3C2410-LCD驱动的流程" class="headerlink" title="开发板S3C2410 LCD驱动的流程"></a>开发板S3C2410 LCD驱动的流程</h5><p>（1）在<code>mach-smdk2410.c</code>中，定义了初始的LCD参数。注意这是个全局变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> s3c2410fb_mach_info smdk2410_lcd_cfg = &#123;</div><div class="line">    .regs= &#123;</div><div class="line">        .lcdcon1 = S3C2410_LCDCON1_TFT16BPP |</div><div class="line">            S3C2410_LCDCON1_TFT |</div><div class="line">            S3C2410_LCDCON1_CLKVAL(<span class="number">7</span>),</div><div class="line">            ......</div><div class="line">    &#125;,</div><div class="line">    .width  = <span class="number">240</span>,</div><div class="line">    .height = <span class="number">320</span>,</div><div class="line">    .xres = &#123;.min = <span class="number">240</span>, .max= <span class="number">240</span>, .defval = <span class="number">240</span>&#125;,</div><div class="line">    .bpp   = &#123;.min = <span class="number">16</span>, .max= <span class="number">16</span>, .defval = <span class="number">16</span>&#125;,</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>（2）内核初始化时候调用<code>s3c2410fb_probe</code>函数。下面分析这个函数的做的工作。首先先动态分配<code>s3c2410fb_info</code>空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fbinfo = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> s3c2410fb_info),&amp;pdev-&gt;dev);</div></pre></td></tr></table></figure></p>
<p>把域<code>mach_info</code>指向<code>mach-smdk2410.c</code>中的<code>smdk2410_lcd_cfg</code> 。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">info-&gt;mach_info = pdev-&gt;dev.platform_data;</div></pre></td></tr></table></figure></p>
<p>设置<code>fb_info</code>域的<code>fix</code>，<code>var</code>，<code>fops</code>字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fbinfo-&gt;fix.type  =  FB_TYPE_PACKED_PIXELS;</div><div class="line">fbinfo-&gt;fix.type_aux  = <span class="number">0</span>;</div><div class="line">fbinfo-&gt;fix.xpanstep  = <span class="number">0</span>;</div><div class="line"></div><div class="line">fbinfo-&gt;var.nonstd    = <span class="number">0</span>;</div><div class="line">fbinfo-&gt;var.activate  = FB_ACTIVATE_NOW;</div><div class="line">fbinfo-&gt;var.height    = mach_info-&gt;height;</div><div class="line">fbinfo-&gt;var.width     = mach_info-&gt;width;</div><div class="line"></div><div class="line">fbinfo-&gt;fbops  = &amp;s3c2410fb_ops;</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>该函数调用<code>s3c2410fb_map_video_memory()</code>申请DMA内存，即显存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fbi-&gt;map_size = PAGE_ALIGN(fbi-&gt;fb-&gt;fix.smem_len + PAGE_SIZE);</div><div class="line">fbi-&gt;map_cpu  = dma_alloc_writecombine(fbi-&gt;dev, fbi-&gt;map_size,</div><div class="line">          &amp;fbi-&gt;map_dma, GFP_KERNEL);</div><div class="line"></div><div class="line">fbi-&gt;map_size = fbi-&gt;fb-&gt;fix.smem_len;</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>设置控制寄存器，设置硬件寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">memcpy</span>(&amp;info-&gt;regs, &amp;mach_info-&gt;regs, <span class="keyword">sizeof</span>(info-&gt;regs));</div><div class="line">info-&gt;regs.lcdcon1 &amp;= ~S3C2410_LCDCON1_ENVID;</div><div class="line">………</div></pre></td></tr></table></figure></p>
<p>调用函数<code>s3c2410fb_init_registers()</code>，把初始值写入寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">writel(fbi-&gt;regs.lcdcon1, S3C2410_LCDCON1);</div><div class="line">writel(fbi-&gt;regs.lcdcon2, S3C2410_LCDCON2);</div></pre></td></tr></table></figure></p>
<p>（3）当用户调用<code>mmap()</code>映射内存的时候，<code>fbmem.c</code>把刚才设置好的显存区域映射给用户。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">start = info-&gt;fix.smem_start;</div><div class="line">len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.smem_len);</div><div class="line">io_remap_pfn_range(vma, vma-&gt;vm_start, off &gt;&gt; PAGE_SHIFT,</div><div class="line">    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)；</div><div class="line">……</div></pre></td></tr></table></figure></p>
<p>这样就完成了驱动初始化到用户调用的整个过程。</p>
<h3 id="BMP和JPEG图形显示程序"><a href="#BMP和JPEG图形显示程序" class="headerlink" title="BMP和JPEG图形显示程序"></a>BMP和JPEG图形显示程序</h3><h4 id="在LCD上显示BMP或JPEG图片的主流程图"><a href="#在LCD上显示BMP或JPEG图片的主流程图" class="headerlink" title="在LCD上显示BMP或JPEG图片的主流程图"></a>在LCD上显示BMP或JPEG图片的主流程图</h4><p>首先，在程序开始前。要在<code>nfs/dev</code>目录下创建LCD的设备结点，设备名<code>fb0</code>,设备类型为字符设备，主设备号为<code>29</code>，次设备号为<code>0</code>。命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mknod fb0 c 29 0</div></pre></td></tr></table></figure></p>
<p>在LCD上显示图象的主流程图如图3.1所示。程序一开始要调用<code>open</code>函数打开设备，然后调用<code>ioctl</code>获取设备相关信息，接下来就是读取图形文件数据，把图象的RGB值映射到显存中，这部分是图象显示的核心。对于JPEG格式的图片，要先经过JPEG解码才能得到RGB数据，本项目中直接采用现成的JPEG库进行解码。对于bmp格式的图片，则可以直接从文件里面提取其RGB数据。要从一个bmp文件里面把图片数据阵列提取出来，首先必须知道bmp文件的格式。下面来详细介绍bmp文件的格式。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd14.jpg" alt="图3.1" title="图3.1">
<h4 id="bmp位图格式分析"><a href="#bmp位图格式分析" class="headerlink" title="bmp位图格式分析"></a>bmp位图格式分析</h4><p>位图文件可看成由四个部分组成：位图文件头、位图信息头、彩色表和定义位图的字节阵列。如图3.2所示。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd15.jpg" alt="图3.2" title="图3.2">
<p>（1）文件头中各个段的地址及其内容如图3.3。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd16.jpg" alt="图3.3" title="图3.3">
<p>位图文件头数据结构包含BMP图象文件的类型，显示内容等信息。它的数据结构如下定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>  bfType；<span class="comment">//表明位图文件的类型，必须为BM</span></div><div class="line">    <span class="keyword">long</span> bfSize；<span class="comment">//表明位图文件的大小，以字节为单位</span></div><div class="line">    <span class="keyword">int</span>  bfReserved1；<span class="comment">//属于保留字，必须为本0</span></div><div class="line">    <span class="keyword">int</span>  bfReserved2；<span class="comment">//也是保留字，必须为本0</span></div><div class="line">    <span class="keyword">long</span> bfOffBits；<span class="comment">//位图阵列的起始位置，以字节为单位</span></div><div class="line">&#125; BITMAPFILEHEADER；</div></pre></td></tr></table></figure></p>
<p>（2）信息头中各个段的地址及其内容如图3.4所示。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd17.jpg" alt="图3.4" title="图3.4">
<p>位图信息头的数据结构包含了有关BMP图象的宽，高，压缩方法等信息，它的C语言数据结构如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">long</span>  biSize； <span class="comment">//指出本数据结构所需要的字节数</span></div><div class="line">    <span class="keyword">long</span>  biWidth；<span class="comment">//以象素为单位，给出BMP图象的宽度</span></div><div class="line">    <span class="keyword">long</span>  biHeight；<span class="comment">//以象素为单位，给出BMP图象的高度</span></div><div class="line">    <span class="keyword">int</span>   biPlanes；<span class="comment">//输出设备的位平面数，必须置为1</span></div><div class="line">    <span class="keyword">int</span>   biBitCount；<span class="comment">//给出每个象素的位数</span></div><div class="line">    <span class="keyword">long</span>  biCompress；<span class="comment">//给出位图的压缩类型</span></div><div class="line">    <span class="keyword">long</span>  biSizeImage；<span class="comment">//给出图象字节数的多少</span></div><div class="line">    <span class="keyword">long</span>  biXPelsPerMeter；<span class="comment">//图像的水平分辨率</span></div><div class="line">    <span class="keyword">long</span>  biYPelsPerMeter；<span class="comment">//图象的垂直分辨率</span></div><div class="line">    <span class="keyword">long</span>  biClrUsed；<span class="comment">//调色板中图象实际使用的颜色素数</span></div><div class="line">    <span class="keyword">long</span>  biClrImportant；<span class="comment">//给出重要颜色的索引值</span></div><div class="line">&#125; BITMAPINFOHEADER；</div></pre></td></tr></table></figure></p>
<p>（3）对于象素小于或等于16位的图片，都有一个颜色表用来给图象数据阵列提供颜色索引，其中的每块数据都以B、G、R的顺序排列，还有一个是<code>reserved</code>保留位。而在图形数据区域存放的是各个象素点的索引值。它的C语言数据结构如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> g;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reserved;</div><div class="line">&#125; ColorTable;</div></pre></td></tr></table></figure></p>
<p>4）对于24位和32位的图片，没有彩色表，它在图象数据区里直接存放图片的RGB数据，其中的每个象素点的数据都以B、G、R的顺序排列。每个象素点的数据结构如下所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> g;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> reserved;</div><div class="line">&#125; RGB;</div></pre></td></tr></table></figure></p>
<p>（5）由于图象数据阵列中的数据是从图片的最后一行开始往上存放的，因此在显示图象时，是从图象的左下角开始逐行扫描图象，即从左到右，从下到上。<br>（6）对S3C2410或PXA255开发板上的LCD来说，他们每个象素点所占的位数为16位，这16位按<code>B：G：R=5：6：5</code>的方式分，其中B在最高位，R在最低位。而从bmp图象得到的R、G、B数据则每个数据占8位，合起来一共24位，因此需要对该R、G、B数据进行移位组合成一个16位的数据。移位方法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b &gt;&gt;= <span class="number">3</span>; g &gt;&gt;= <span class="number">2</span>; r &gt;&gt;= <span class="number">3</span>;</div><div class="line">RGBValue = ( r&lt;&lt;<span class="number">11</span> | g &lt;&lt; <span class="number">5</span> | b);</div></pre></td></tr></table></figure></p>
<p>基于以上分析，提取各种类型的bmp图象的流程如图3.5所示</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd18.jpg" alt="图3.5" title="图3.5">
<h4 id="实现显示任意大小的图片"><a href="#实现显示任意大小的图片" class="headerlink" title="实现显示任意大小的图片"></a>实现显示任意大小的图片</h4><p>开发板上的LCD屏的大小是固定的，S3C2410上的LCD为：240<em>320，PXA255上的为：640</em>480。比屏幕小的图片在屏上显示当然没问题，但是如果图片比屏幕大呢？这就要求我们通过某种算法对图片进行缩放。<br>缩放的基本思想是将图片分成若干个方块，对每个方块中的R、G、B数据进行取平均，得到一个新的R、G、B值，这个值就作为该方块在LCD屏幕上的映射。<br>缩放的算法描述如下：<br>(1)、计算图片大小与LCD屏大小的比例，以及方块的大小。为了适应各种屏幕大小，这里并不直接给lcd_width和lcd_height赋值为240和320。而是调用标准的接口来获取有关屏幕的参数。具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get variable screen information</span></div><div class="line"><span class="keyword">if</span> (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Error reading variable information."</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lcd_width=vinfo.xres;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lcd_height=vinfo.yres;</div></pre></td></tr></table></figure></p>
<p>计算比例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">widthScale=bmpi-&gt;width/lcd_width;</div><div class="line">heightScale=bmpi-&gt;height/lcd_height;</div></pre></td></tr></table></figure></p>
<p>本程序中方块的大小以如下的方式确定：<br>注：以下两行代码原文内容已缺失，待补充。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> paneWidth= ;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> paneHeight= ;</div></pre></td></tr></table></figure></p>
<p>符号 代表向上取整。<br>(2)、从图片的左上角开始，以(<code>i * widthScale</code>，<code>j * heightScale</code>)位起始点，以宽<code>paneWidth</code>高<code>paneHeight</code>为一个小方块，对该方块的R、G、B数值分别取平均，得到映射点的R、G、B值，把该点作为要在LCD上显示的第（<code>i</code> , <code>j</code>）点存储起来。<br>这部分的程序如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//-------------取平均--------</span></div><div class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lcd_height; i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; lcd_width; j++)</div><div class="line">    &#123;</div><div class="line">        color_sum_r = <span class="number">0</span>;</div><div class="line">        color_sum_g = <span class="number">0</span>;</div><div class="line">        color_sum_b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(m = i*heightScale; m &lt; i*heightScale+paneHeight; m++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(n = j*widthScale; n &lt; j*widthScale+paneWidth; n++)</div><div class="line">            &#123;</div><div class="line">                color_sum_r += pointvalue[m][n].r;</div><div class="line">                color_sum_g += pointvalue[m][n].g;</div><div class="line">                color_sum_b += pointvalue[m][n].b;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         RGBvalue_256-&gt;r = div_round(color_sum_r, paneHeight*paneWidth);</div><div class="line">         RGBvalue_256-&gt;g = div_round(color_sum_g, paneHeight*paneWidth);</div><div class="line">         RGBvalue_256-&gt;b = div_round(color_sum_b, paneHeight*paneWidth);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="图片数据提取及显示的总流程"><a href="#图片数据提取及显示的总流程" class="headerlink" title="图片数据提取及显示的总流程"></a>图片数据提取及显示的总流程</h4><p>通过以上的分析，整个图片数据提取及显示的总流程如图3.6所示。</p>
<img src="/kernel/设备驱动/linux-lcd-driver/lcd19.jpg" alt="图3.6" title="图3.6">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UML 用例图总结]]></title>
      <url>https://jarsonfang.github.io/programming/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml-use-case-diagram/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/tianhai110/article/details/6369762" target="_blank" rel="external">http://blog.csdn.net/tianhai110/article/details/6369762</a></p>
<p><span style="color: red;">用例图主要用来描述 用户、需求、系统功能单元 之间的关系。</span>它展示了一个外部用户能够观察到的系统功能模型图。</p>
<p><span style="color: #00b050;">【用途】：帮助开发团队以一种可视化的方式理解系统的功能需求。</span><br><a id="more"></a></p>
<p>用例图所包含的元素如下：</p>
<h3 id="参与者-Actor"><a href="#参与者-Actor" class="headerlink" title="参与者(Actor)"></a>参与者(Actor)</h3><p>表示与您的应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。<br><img src="/programming/设计模式/uml-use-case-diagram/actor.png" alt="actor.png" title=""></p>
<h3 id="用例-Use-Case"><a href="#用例-Use-Case" class="headerlink" title="用例(Use Case)"></a>用例(Use Case)</h3><p>用例就是外部可见的系统功能，对系统提供的服务进行描述。 用椭圆表示<br><img src="/programming/设计模式/uml-use-case-diagram/use_case.png" alt="use_case.png" title=""></p>
<h3 id="子系统-Subsystem"><a href="#子系统-Subsystem" class="headerlink" title="子系统(Subsystem)"></a>子系统(Subsystem)</h3><p>用来展示系统的一部分功能，这部分功能联系紧密。<br><img src="/programming/设计模式/uml-use-case-diagram/subsys.png" alt="subsys.png" title=""></p>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>用例图中涉及的关系有：关联、泛化、包含、扩展，如下表所示：</p>
<table>
<thead>
<tr>
<th>关系类型</th>
<th>说明</th>
<th>表示符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>关联</td>
<td>参与者与用例间的关系</td>
<td><img src="/programming/设计模式/uml-use-case-diagram/associate.png" alt="associate.png" title=""></td>
</tr>
<tr>
<td>泛化</td>
<td>参与者之间或用例之间的关系</td>
<td><img src="/programming/设计模式/uml-use-case-diagram/generalization.png" alt="generalization.png" title=""></td>
</tr>
<tr>
<td>包含</td>
<td>用例之间的关系</td>
<td><img src="/programming/设计模式/uml-use-case-diagram/include.png" alt="include.png" title=""></td>
</tr>
<tr>
<td>扩展</td>
<td>用例之间的关系</td>
<td><img src="/programming/设计模式/uml-use-case-diagram/extend.png" alt="extend.png" title=""></td>
</tr>
</tbody>
</table>
<p><strong> a. 关联(Association)</strong></p>
<p>表示参与者与用例之间的通信，任何一方都可发送或接受消息。</p>
<p>【箭头指向】：指向消息接收方<br><img src="/programming/设计模式/uml-use-case-diagram/association.png" alt="association.png" title=""></p>
<p><strong>b. 泛化(Inheritance)</strong></p>
<p>就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。</p>
<p>【箭头指向】：指向父用例<br><img src="/programming/设计模式/uml-use-case-diagram/inheritance.png" alt="inheritance.png" title=""></p>
<p><strong>c. 包含(Include)</strong></p>
<p>包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤；</p>
<p>【箭头指向】：指向分解出来的功能用例<br><img src="/programming/设计模式/uml-use-case-diagram/include2.png" alt="include2.png" title=""></p>
<p><strong>d. 扩展(Extend)</strong></p>
<p>扩展关系是指 用例功能的延伸，相当于为基础用例提供一个附加功能。</p>
<p>【箭头指向】：指向基础用例<br><img src="/programming/设计模式/uml-use-case-diagram/extend2.png" alt="extend2.png" title=""></p>
<p><strong>e. 依赖(Dependency)</strong></p>
<p>以上4中关系，是UML定义的标准关系。 但VS2010的用例模型图中，添加了依赖关系，用带箭头的虚线表示</p>
<p>表示源用例依赖于目标用例；</p>
<p>【箭头指向】：指向被依赖项<br><img src="/programming/设计模式/uml-use-case-diagram/dependency.png" alt="dependency.png" title=""></p>
<h3 id="项目-Artifact"><a href="#项目-Artifact" class="headerlink" title="项目(Artifact)"></a>项目(Artifact)</h3><p>用例图虽然是用来帮助人们形象地理解功能需求，但却没多少人能够通看懂它。很多时候跟用户交流甚至用Excel都比用例图强，VS2010中引入了“项目”这样一个元素，以便让开发人员能够在用例图中链接一个普通文档。</p>
<p>用依赖关系把某个用例依赖到项目上<br><img src="/programming/设计模式/uml-use-case-diagram/artifact.png" alt="artifact.png" title=""><br>然后把项目-》属性 的Hyperlink 设置到你的文档上<br>这样当你在用例图上 双击项目时，就会打开相关联的文档。</p>
<h3 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释(Comment)"></a>注释(Comment)</h3><img src="/programming/设计模式/uml-use-case-diagram/comment.png" alt="comment.png" title="">
<h3 id="包含-include-、扩展-extend-、泛化-Inheritance-的区别"><a href="#包含-include-、扩展-extend-、泛化-Inheritance-的区别" class="headerlink" title="包含(include)、扩展(extend)、泛化(Inheritance) 的区别"></a>包含(include)、扩展(extend)、泛化(Inheritance) 的区别</h3><p><em>条件性</em>：泛化中的子用例和include中的被包含的用例会无条件发生，而extend中的延伸用例的发生是有条件的；<br><em>直接性</em>：泛化中的子用例和extend中的延伸用例为参与者提供直接服务，而include中被包含的用例为参与者提供间接服务。<br>对extend而言，延伸用例并不包含基础用例的内容，基础用例也不包含延伸用例的内容。<br>对Inheritance而言，子用例包含基础用例的所有内容及其和其他用例或参与者之间的关系；</p>
<h3 id="一个用例图示例"><a href="#一个用例图示例" class="headerlink" title="一个用例图示例"></a>一个用例图示例</h3><img src="/programming/设计模式/uml-use-case-diagram/example.png" alt="example.png" title="">
<h3 id="牢骚"><a href="#牢骚" class="headerlink" title="牢骚"></a>牢骚</h3><p>感觉用例图还不成熟，并不能很好地表达系统的需求， 没有UML背景的用户几乎不知道画的些什么。<br>其次，包含关系、扩展关系 的箭头符号竟然是同样的箭头，仅靠上方写个文字来加以区别，翻译成其他语言的话，几乎就不知道代表什么意思。  扩展关系的箭头朝向也很难理解，为何要指向基用例，而不指向扩展用例<br>VS2010添加的“项目”元素，是个很好的创新，能够在用例图中关联word,excel这些文档。但为什么不把这些功能直接集成到用例里面，双击用例就弹出一份文档岂不更容易理解，非要画蛇添足地加一个元件，仅仅为了提供个链接功能。</p>
<p><strong>用例描述表：</strong></p>
<p>鉴于用列图并不能清楚地表达功能需求，开发中大家通常用描述表来补充某些不易表达的用例，下图的表给大家提供一个参考：<br><img src="/programming/设计模式/uml-use-case-diagram/example2.png" alt="example2.png" title=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UML序列图总结]]></title>
      <url>https://jarsonfang.github.io/programming/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml-sequence-diagram/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/tianhai110/article/details/6361338" target="_blank" rel="external">http://blog.csdn.net/tianhai110/article/details/6361338</a></p>
<p><strong><span style="color: #984806;">序列图主要用于展示对象之间交互的顺序。</span></strong><br>序列图将交互关系表示为一个二维图。纵向是时间轴，时间沿竖线向下延伸。横向轴代表了在协作中各独立对象的类元角色。类元角色用生命线表示。当对象存在时，角色用一条虚线表示，当对象的过程处于激活状态时，生命线是一个双道线。<br>消息用从一个对象的生命线到另一个对象生命线的箭头表示。箭头以时间顺序在图中从上到下排列。<br><a id="more"></a></p>
<h2 id="序列图中涉及的元素"><a href="#序列图中涉及的元素" class="headerlink" title="序列图中涉及的元素"></a>序列图中涉及的元素</h2><h3 id="生命线"><a href="#生命线" class="headerlink" title="生命线"></a>生命线</h3><p>生命线名称可带下划线。当使用下划线时，意味着序列图中的生命线代表一个类的特定实体。<br><img src="/programming/设计模式/uml-sequence-diagram/life.png" alt="life.png" title=""></p>
<h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p>发送人在它继续之前，将等待同步消息响应<br><img src="/programming/设计模式/uml-sequence-diagram/sync.png" alt="sync.png" title=""></p>
<h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p>在发送方继续之前，无需等待响应的消息<br><img src="/programming/设计模式/uml-sequence-diagram/async.png" alt="async.png" title=""></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><img src="/programming/设计模式/uml-sequence-diagram/comment.png" alt="comment.png" title="">
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>约束的符号很简单；格式是: [Boolean Test]<br></p>
<h3 id="组合片段"><a href="#组合片段" class="headerlink" title="组合片段"></a>组合片段</h3><p><span style="color: #984806;"><em>组合片段</em> 用来解决交互执行的条件及方式。</span> 它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。</p>
<p>常用的组合片段有：</p>
<p><em>a. 抉择（Alt）</em></p>
<p><span style="color: blue;">抉择用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else..。</span></p>
<p>抉择在任何场合下只发生一个序列。可以在每个片段中设置一个临界来指示该片段可以运行的条件。else 的临界指示其他任何临界都不为 True 时应运行的片段。如果所有临界都为 False 并且没有 else，则不执行任何片段。<br><img src="/programming/设计模式/uml-sequence-diagram/alt.png" alt="alt.png" title=""></p>
<p><em>b. 选项（Opt）</em></p>
<p>包含一个可能发生或不发生的序列<br><img src="/programming/设计模式/uml-sequence-diagram/opt.png" alt="opt.png" title=""></p>
<p><em>c. 循环（Loop）</em></p>
<p>片段重复一定次数。 可以在临界中指示片段重复的条件。<br><img src="/programming/设计模式/uml-sequence-diagram/loop.png" alt="loop.png" title=""></p>
<p><em>d. 并行（Par）</em></p>
<img src="/programming/设计模式/uml-sequence-diagram/par.png" alt="par.png" title="">
<p><strong>下表列出了常用的组合片段：</strong></p>
<table>
<thead>
<tr>
<th>片段类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Opt</strong></td>
<td>选项</td>
<td>包含一个可能发生或可能不发生的序列。可以在临界中指定序列发生的条件。</td>
</tr>
<tr>
<td><strong>Alt</strong></td>
<td>抉择</td>
<td>包含一个片段列表，这些片段包含备选消息序列。在任何场合下只发生一个序列。<br>可以在每个片段中设置一个临界来指示该片段可以运行的条件。<strong>else</strong>的临界指示其他任何临界都不为 True 时应运行的片段。如果所有临界都为 False 并且没有 <strong>else</strong>，则不执行任何片段。</td>
</tr>
<tr>
<td><strong>Loop</strong></td>
<td>循环</td>
<td>片段重复一定次数。可以在临界中指示片段重复的条件。<br>Loop 组合片段具有<strong>“Min”</strong>和<strong>“Max”</strong>属性，它们指示片段可以重复的最小和最大次数。默认值是无限制。</td>
</tr>
<tr>
<td><strong>Break</strong></td>
<td>中断</td>
<td>如果执行此片段，则放弃序列的其余部分。可以使用临界来指示发生中断的条件。</td>
</tr>
<tr>
<td><strong>Par</strong></td>
<td>并行</td>
<td>并行处理。片段中的事件可以交错。</td>
</tr>
<tr>
<td><strong>Critical</strong></td>
<td>关键</td>
<td>用在 Par 或 Seq 片段中。指示此片段中的消息不得与其他消息交错。</td>
</tr>
<tr>
<td><strong>Seq</strong></td>
<td>弱顺序</td>
<td>有两个或更多操作数片段。涉及同一生命线的消息必须以片段的顺序发生。如果消息涉及的生命线不同，来自不同片段的消息可能会并行交错。</td>
</tr>
<tr>
<td><strong>Strict</strong></td>
<td>强顺序</td>
<td>有两个或更多操作数片段。这些片段必须按给定顺序发生。</td>
</tr>
</tbody>
</table>
<p><strong>有关如何解释序列的片段</strong></p>
<p>默认情况下，序列图表明可能发生的一系列消息。在运行的系统中，可能会出现您未选择显示在关系图上的其他消息。</p>
<p>以下片段类型可用于更改此释义：</p>
<table>
<thead>
<tr>
<th>片段类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Consider</strong></td>
<td>考虑</td>
<td>指定此片段描述的消息列表。其他消息可发生在运行的系统中，但对此描述来说意义不大。<br>在<strong>“Messages”</strong>属性中键入该列表。</td>
</tr>
<tr>
<td><strong>Ignore</strong></td>
<td>忽略</td>
<td>此片段未描述的消息列表。这些消息可发生在运行的系统中，但对此描述来说意义不大。<br>在<strong>“Messages”</strong>属性中键入该列表。</td>
</tr>
<tr>
<td><strong>Assert</strong></td>
<td>断言</td>
<td>操作数片段指定唯一有效的序列。通常用在 Consider 或 Ignore 片段中。</td>
</tr>
<tr>
<td><strong>Neg</strong></td>
<td>否定</td>
<td>此片段中显示的序列不得发生。通常用在 Consider 或 Ignore 片段中。</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UML类图几种关系的总结]]></title>
      <url>https://jarsonfang.github.io/programming/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/uml-class-diagram/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/tianhai110/article/details/6339565" target="_blank" rel="external">http://blog.csdn.net/tianhai110/article/details/6339565</a></p>
<p>在UML类图中，常见的有以下几种关系：泛化（Generalization），实现（Realization），关联（Association），聚合（Aggregation），组合（Composition），依赖（Dependency）。<br><a id="more"></a></p>
<h2 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h2><p><span style="color:red;">【泛化关系】：是一种继承关系，它指定了子类如何特化父类的所有特征和行为。</span>例如：老虎是动物的一种。</p>
<p>【箭头指向】：带三角箭头的实线，箭头指向父类。<br><img src="/programming/设计模式/uml-class-diagram/generalization.png" alt="generalization.png" title=""></p>
<h2 id="实现（Realization"><a href="#实现（Realization" class="headerlink" title="实现（Realization)"></a>实现（Realization)</h2><p><span style="color:red;">【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。</span></p>
<p>【箭头指向】：带三角箭头的虚线，箭头指向接口。<br><img src="/programming/设计模式/uml-class-diagram/realization.png" alt="realization.png" title=""></p>
<h2 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h2><p><span style="color:red;">【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法。</span>如：老师与学生、丈夫与妻子。</p>
<p>关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p>
<p><span style="color:green;">【代码体现】：成员变量。</span></p>
<p>【箭头及指向】：带普通箭头的实心线，指向被拥有者。<br><img src="/programming/设计模式/uml-class-diagram/association.png" alt="association.png" title=""><br>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西，它不拥有学生。<br><img src="/programming/设计模式/uml-class-diagram/association_self.png" alt="association_self.png" title=""><br>上图为自身关联。</p>
<h2 id="聚合（Aggregation）"><a href="#聚合（Aggregation）" class="headerlink" title="聚合（Aggregation）"></a>聚合（Aggregation）</h2><p><span style="color:red;">【聚合关系】：是整体与部分的关系。</span>如车和轮胎是整体和部分的关系。</p>
<p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p>
<p><span style="color:green;">【代码体现】：成员变量。</span></p>
<p>【箭头及指向】：带空心菱形的实心线，菱形指向整体。<br><img src="/programming/设计模式/uml-class-diagram/aggregation.png" alt="aggregation.png" title=""></p>
<h2 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h2><p><span style="color:red;">【组合关系】：是整体与部分的关系。</span>没有公司就不存在部门。</p>
<p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p>
<p><span style="color:green;">【代码体现】：成员变量。</span></p>
<p>【箭头及指向】：带实心菱形的实线，菱形指向整体。<br><img src="/programming/设计模式/uml-class-diagram/composition.png" alt="composition.png" title=""></p>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p><span style="color:red;">【依赖关系】：是一种使用的关系，所以要尽量不使用双向的互相依赖。</span></p>
<p><span style="color:green;">【代码表现】：局部变量、方法的参数或者对静态方法的调用。</span></p>
<p>【箭头及指向】：带箭头的虚线，指向被使用者。<br><img src="/programming/设计模式/uml-class-diagram/dependency.png" alt="dependency.png" title=""></p>
<h2 id="各种关系的强弱顺序"><a href="#各种关系的强弱顺序" class="headerlink" title="各种关系的强弱顺序"></a>各种关系的强弱顺序</h2><p><strong>泛化= 实现&gt; 组合&gt; 聚合&gt; 关联&gt; 依赖</strong></p>
<p>下面这张UML图，比较形象地展示了各种类图关系：<br><img src="/programming/设计模式/uml-class-diagram/summary.png" alt="summary.png" title=""></p>
<p>企鹅与气候的关系：关联 or 依赖？</p>
<blockquote>
<p>程杰&lt;&lt;大话设计模式&gt;&gt;P14页这样解释：”你看企鹅和气候两个类，企鹅是很特别的鸟，会游不会飞。更重要的是，它与气候有很大的关联。我们不去讨论为什么北极没有企鹅，为什么它们要每年长途跋涉。总之，企鹅需要‘知道’气候的变化，需要‘了解’气候规律。当一个类‘知道’另一个类时，可以用关联（association）。关联关系用实线箭头来表示。”</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开发者日常使用的 Git 命令]]></title>
      <url>https://jarsonfang.github.io/tools/VCS/everyday-git/</url>
      <content type="html"><![CDATA[<p>原文链接： <a href="https://www.kernel.org/pub/software/scm/git/docs/everyday.html" target="_blank" rel="external">Everyday GIT With 20 Commands Or So</a>   翻译： <a href="http://blog.jobbole.com" target="_blank" rel="external"> 伯乐在线 </a> - <a href="http://blog.jobbole.com/author/cjpan/" target="_blank" rel="external">cjpan</a><br>译文链接： <a href="http://blog.jobbole.com/54184/" target="_blank" rel="external">http://blog.jobbole.com/54184/</a> （下文在原译文基础上有修正补充）</p>
<p><span style="color:red;">原文（英）最后更新时间：Last updated 2013-02-15 15:53:17 UTC</span></p>
<p>这些命令分四种类型：①不需要和其他开发者协作的独立开发者，会经常用到 <code>git init</code>、<code>git show branch</code>、<code>git commit</code> 等命令；②需要和其他人协作的开发者，会常用到 <code>git clone</code>、<code>git push</code>、<code>git pull</code>、<code>git format patch</code>；③在项目中负责接收其他开发者发来更新的核心开发者，会常用到 <code>git am</code>、<code>git pull</code>、<code>git format patch</code>、<code>git revert</code>、<code>git push</code>；④ 代码仓库管理员常用 <code>git daemon</code>、<code>git shell</code> ……</p>
<p>对于任何想做提交的人来说，甚至对于某位单独工作的人来说，【个人开发者（单独开发）】部分命令都是必不可少的。如果你和别人一起工作，你也会需要【个人开发者（参与者）】部分列出的命令。</p>
<p>除了上述的部分，担当【集成人员】角色的人需要知道更多命令。【代码库管理】命令帮助系统管理员负责管理，以及向git代码库提交内容。<br><a id="more"></a></p>
<h2 id="个人开发者（单独开发）Individual-Developer-Standalone"><a href="#个人开发者（单独开发）Individual-Developer-Standalone" class="headerlink" title="个人开发者（单独开发）Individual Developer (Standalone)"></a>个人开发者（单独开发）Individual Developer (Standalone)</h2><p>单独的个人开发者不会与他人交换修补程序，只用到下列命令，独自在单独的代码库上工作：</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-init.html" target="_blank" rel="external">git-init(1)</a> 创建新代码库。to create a new repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-show-branch.html" target="_blank" rel="external">git-show-branch(1)</a> 查看你在哪里。to see where you are.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-log.html" target="_blank" rel="external">git-log(1)</a> 查看发生过什么。to see what happened.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-branch.html" target="_blank" rel="external">git-branch(1)</a> 切换分支。to switch branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-add.html" target="_blank" rel="external">git-add(1)</a> 管理索引文件。to manage the index file.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-diff.html" target="_blank" rel="external">git-diff(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-status.html" target="_blank" rel="external">git-status(1)</a> 查看你正在做什么。to see what you are in the middle of doing.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html" target="_blank" rel="external">git-commit(1)</a> 将推进当前分支。to advance the current branch.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-reset.html" target="_blank" rel="external">git-reset(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a> （带路径名参数）放弃（撤销）修改。to undo changes.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-merge.html" target="_blank" rel="external">git-merge(1)</a> 合并本地分支。to merge between local branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" target="_blank" rel="external">git-rebase(1)</a> 维护主题分支。to maintain topic branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-tag.html" target="_blank" rel="external">git-tag(1)</a> 给已知点打标签。to mark known point.</li>
</ul>
<h3 id="实例-Examples"><a href="#实例-Examples" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>用Tar包作为一个新代码库的起始点</strong><br>Use a tarball as a starting point for a new repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tar zxf frotz.tar.gz</div><div class="line">$ <span class="built_in">cd</span> frotz</div><div class="line">$ git init</div><div class="line">$ git add . &lt;1&gt;</div><div class="line">$ git commit -m <span class="string">"import of frotz source tree."</span></div><div class="line">$ git tag v2.43 &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>添加现目录下的所有文件。</li>
<li>打一个轻量的无注释的标签。</li>
</ol>
<p><strong>创建一个主题分支并开发</strong><br>Create a topic branch and develop.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b alsa-audio &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git checkout -- curses/ux_audio_oss.c &lt;2&gt;</div><div class="line">$ git add curses/ux_audio_alsa.c &lt;3&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff HEAD &lt;4&gt;</div><div class="line">$ git commit <span class="_">-a</span> <span class="_">-s</span> &lt;5&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git reset --soft HEAD^ &lt;6&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff ORIG_HEAD &lt;7&gt;</div><div class="line">$ git commit <span class="_">-a</span> -c ORIG_HEAD &lt;8&gt;</div><div class="line">$ git checkout master &lt;9&gt;</div><div class="line">$ git merge alsa-audio &lt;10&gt;</div><div class="line">$ git <span class="built_in">log</span> --since=<span class="string">'3 days ago'</span> &lt;11&gt;</div><div class="line">$ git <span class="built_in">log</span> v2.43.. curses/ &lt;12&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建(create)一个主题分支。</li>
<li>还原(revert)你在<code>curses/ux_audio_oss.c</code>文件里搞砸了的修改。</li>
<li>如果你添加一个新文件，你需要告诉git；之后，如果你使用<em><code>git commit -a</code></em>， 删除和修改就会被(git)捕获。</li>
<li>查看你正在提交什么修改。</li>
<li>提交所有的你已测试文件，包括你的签名。</li>
<li>撤回最后一次提交，保留工作区（working tree）内容。</li>
<li>查看自从上一个不成熟提交后的修改。</li>
<li>沿用原先写过的（注释）信息，重做在之前步骤中撤销了的提交。</li>
<li>切换到主干（master）分支。</li>
<li>合并一个主题分支到主分支。</li>
<li>回顾提交记录；其他限制输出的形式也可以合并包含（combined and include）： <em><code>--max-count=10</code></em>(显示10个提交)，<em><code>--until=2005-12-10</code></em> 等。</li>
<li>只查看从<em><code>v2.43</code></em>标签开始以来影响到<em><code>curses/</code></em>目录的修改。</li>
</ol>
<h2 id="个人开发者（参与开发）Individual-Developer-Participant"><a href="#个人开发者（参与开发）Individual-Developer-Participant" class="headerlink" title="个人开发者（参与开发）Individual Developer (Participant)"></a>个人开发者（参与开发）Individual Developer (Participant)</h2><p>作为一个团体项目里的参与角色，开发人员需要学习如何与他人沟通，除了那些单独开发者需要掌握的命令以外，还要使用这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-clone.html" target="_blank" rel="external">git-clone(1)</a> 从上游代码库填充你的本地代码库。<br>from the upstream to prime your local repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-fetch.html" target="_blank" rel="external">git-fetch(1)</a> 从“origin”得到最新的上游代码库。<br>from “origin” to keep up-to-date with the upstream.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 共享代码库，如果你采用cvs风格的代码库工作流的话。<br>to shared repository, if you adopt CVS style shared repository workflow.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备e-mail提交，如果你使用Linux内核风格的公共论坛工作流的话。<br>to prepare e-mail submission, if you adopt Linux kernel-style public forum workflow.</li>
</ul>
<h3 id="实例-Examples-1"><a href="#实例-Examples-1" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>复制上游代码库并在其上工作，提交修改到上游代码库。</strong><br>Clone the upstream and work on it. Feed changes to upstream.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6</div><div class="line">$ <span class="built_in">cd</span> my2.6</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span> <span class="_">-s</span> &lt;1&gt;</div><div class="line">$ git format-patch origin &lt;2&gt;</div><div class="line">$ git pull &lt;3&gt;</div><div class="line">$ git <span class="built_in">log</span> -p ORIG_HEAD.. arch/i386 include/asm-i386 &lt;4&gt;</div><div class="line">$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL &lt;5&gt;</div><div class="line">$ git reset --hard ORIG_HEAD &lt;6&gt;</div><div class="line">$ git gc &lt;7&gt;</div><div class="line">$ git fetch --tags &lt;8&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>按需重复。(repeat as needed)</li>
<li>从你的分支中提取补丁文件，用于电子邮件提交。</li>
<li><em><code>git pull</code></em>命令默认从“<em><code>origin</code></em>”里取得内容并合并到当前的分支中去。</li>
<li>在<code>pull</code>之后，立即查看在上游仓库中自上次检出之后提交的修改（日志），仅查看关注的部分。</li>
<li>从一个指定代码库的一个指定分支获取内容并合并。</li>
<li>撤销（revert）<code>pull</code>操作。</li>
<li>从撤销的<code>pull</code>操作中回收残存的对象。（代码库清理）</li>
<li>不时地，从<em><code>origin</code></em>中获取官方的标签，并保存于<em><code>.git/refs/tags/</code></em>。</li>
</ol>
<p><strong>推送到另一个代码库</strong><br>Push into another repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">satellite$ git <span class="built_in">clone</span> mothership:frotz frotz &lt;1&gt;</div><div class="line">satellite$ <span class="built_in">cd</span> frotz</div><div class="line">satellite$ git config --get-regexp <span class="string">'^(remote|branch)\.'</span> &lt;2&gt;</div><div class="line">remote.origin.url mothership:frotz</div><div class="line">remote.origin.fetch refs/heads/*:refs/remotes/origin/*</div><div class="line">branch.master.remote origin</div><div class="line">branch.master.merge refs/heads/master</div><div class="line">satellite$ git config remote.origin.push \</div><div class="line">           master:refs/remotes/satellite/master &lt;3&gt;</div><div class="line">satellite$ edit/compile/<span class="built_in">test</span>/commit</div><div class="line">satellite$ git push origin &lt;4&gt;</div><div class="line"></div><div class="line">mothership$ <span class="built_in">cd</span> frotz</div><div class="line">mothership$ git checkout master</div><div class="line">mothership$ git merge satellite/master &lt;5&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>mothership</code>机器的<code>home</code>目录下有一个<code>frotz</code>代码库；复制它（clone from it）以在<code>satellite</code>机器上开始一个代码库。</li>
<li>复制（<code>clone</code>）操作默认设定这些配置变量。它安排<em><code>git pull</code></em>去抓取并保存<code>mothership</code>机器上的分支到本地的<em><code>remotes/origin/*</code></em> 跟踪分支。</li>
<li>安排<em><code>git push</code></em>去推送本地的主（<em><code>master</code></em>）分支到<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>分支</li>
<li><code>push</code>操作会在<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>的远程跟踪分支上存储我们的工作。你可以用此作为一个备份方法。</li>
<li>在<code>mothership</code>机器上，将<code>satellite</code>机器上已完成的工作合并到<code>master</code>分支中。</li>
</ol>
<p><strong>分支的特定标签</strong><br>Branch off of a specific tag.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b private2.6.14 v2.6.14 &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span></div><div class="line">$ git checkout master</div><div class="line">$ git format-patch -k -m --stdout v2.6.14..private2.6.14 |</div><div class="line">  git am -3 -k &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建一个私有分支，基于熟知（但稍许过时的）标签。</li>
<li>在还没有正式“合并（merging）”的情况下，向前移植<code>private2.6.14</code>分支所有的修改到<code>master</code>分支上。</li>
</ol>
<h2 id="集成人员-Integrator"><a href="#集成人员-Integrator" class="headerlink" title="集成人员 Integrator"></a>集成人员 Integrator</h2><p>在一个团队项目中担任集成者的是一名相当重要的人员，他/她接收其他人的修改，评审并集成然后发布最终结果供其他人使用；除了参与者需要的那些命令之外，还需要使用以下这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-am.html" target="_blank" rel="external">git-am(1)</a> 采用你的贡献者邮寄过来的补丁文件。<br>to apply patches e-mailed in from your contributors.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a> 从你的可信任的助手处合并内容。<br>to merge from your trusted lieutenants.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备并向你的贡献者发送建议选项。<br>to prepare and send suggested alternative to contributors.<em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-revert.html" target="_blank" rel="external">git-revert(1)</a> 撤销不好的提交。<br>to undo botched commits.</em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 发布最新的内容。<br>to publish the bleeding edge.</li>
</ul>
<h3 id="实例-Examples-2"><a href="#实例-Examples-2" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我典型的GIT一天</strong><br>My typical GIT day.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ git status &lt;1&gt;</div><div class="line">$ git show-branch &lt;2&gt;</div><div class="line">$ mailx &lt;3&gt;</div><div class="line">&amp; s 2 3 4 5 ./+to-apply</div><div class="line">&amp; s 7 8 ./+hold-linus</div><div class="line">&amp; q</div><div class="line">$ git checkout -b topic/one master</div><div class="line">$ git am -3 -i <span class="_">-s</span> -u ./+to-apply &lt;4&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git checkout -b hold/linus &amp;&amp; git am -3 -i <span class="_">-s</span> -u ./+hold-linus &lt;5&gt;</div><div class="line">$ git checkout topic/one &amp;&amp; git rebase master &lt;6&gt;</div><div class="line">$ git checkout pu &amp;&amp; git reset --hard next &lt;7&gt;</div><div class="line">$ git merge topic/one topic/two &amp;&amp; git merge hold/linus &lt;8&gt;</div><div class="line">$ git checkout maint</div><div class="line">$ git cherry-pick master~4 &lt;9&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git tag <span class="_">-s</span> -m <span class="string">"GIT 0.99.9x"</span> v0.99.9x &lt;10&gt;</div><div class="line">$ git fetch ko &amp;&amp; git show-branch master maint <span class="string">'tags/ko-*'</span> &lt;11&gt;</div><div class="line">$ git push ko &lt;12&gt;</div><div class="line">$ git push ko v0.99.9x &lt;13&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>查看我正在做什么，如果有的话。</li>
<li>查看我拥有的主题分支，并考虑它们的完成度。</li>
<li>读邮件，保存合适的，并且保存那些尚未完成的。</li>
<li>采用它们，交互式地，带着我的签名。</li>
<li>按需创建主题分支，还是由我签名采用。</li>
<li>为内部的还未合并到主分支，也没有作为稳定分支的一部分公开的主题分支重定基线。</li>
<li>从接下来开始，每次都重置<em>pu</em>。</li>
<li>合并仍然在料理中的主题分支</li>
<li>向后移植（backport）极其重要的修正。</li>
<li>创建一个签名的标签。</li>
<li>确保我不会意外将主分支回滚到我已经推出来的内容。简写的<em><code>ko</code></em>指向我在kernel.org上已有的代码库里，看起来像这样：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .git/remotes/ko</div><div class="line">URL: kernel.org:/pub/scm/git/git.git</div><div class="line">Pull: master:refs/tags/ko-master</div><div class="line">Pull: next:refs/tags/ko-next</div><div class="line">Pull: maint:refs/tags/ko-maint</div><div class="line">Push: master</div><div class="line">Push: next</div><div class="line">Push: +pu</div><div class="line">Push: maint</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在从<em><code>git show-branch</code></em>的输出里，主分支（<em><code>master</code></em>）应该包含<em><code>ko-master</code></em>所有的内容，并且<em><code>next</code></em>应该包含<em><code>ko-next</code></em>所有的内容。<br>12.  推送最新内容<br>13.  推送标签</p>
<h2 id="代码库管理-Repository-Administration"><a href="#代码库管理-Repository-Administration" class="headerlink" title="代码库管理 Repository Administration"></a>代码库管理 Repository Administration</h2><p>代码库管理员使用下列工具来设置及维护开发者对代码库的访问。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-daemon.html" target="_blank" rel="external">git-daemon(1)</a> 允许匿名者从代码库下载。<br>to allow anonymous download from repository.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-shell.html" target="_blank" rel="external">git-shell(1)</a> 可以被用作为限制登录shell，用于共享中央代码库的用户。<br>can be used as a <em>restricted login shell</em> for shared central repository users.<br><a href="https://www.kernel.org/pub/software/scm/git/docs/howto/update-hook-example.txt" target="_blank" rel="external">update hook howto</a> 有一个很好的管理共享中央代码库的实例。</li>
</ul>
<h3 id="实例-Examples-3"><a href="#实例-Examples-3" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我们假设下面的内容均在/etc/services目录下</strong><br>We assume the following in /etc/services<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep 9418 /etc/services</div><div class="line">git             9418/tcp                <span class="comment"># Git Version Control System</span></div></pre></td></tr></table></figure></p>
<p><strong>从inetd中运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from inetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/inetd.conf</div><div class="line">git     stream  tcp     nowait  nobody \</div><div class="line">  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm</div></pre></td></tr></table></figure></p>
<p>实际的配置应该在1行里。</p>
<p><strong>从xinetd运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from xinetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/xinetd.d/git-daemon</div><div class="line"><span class="comment"># default: off</span></div><div class="line"><span class="comment"># description: The git server offers access to git repositories</span></div><div class="line">service git</div><div class="line">&#123;</div><div class="line">        <span class="built_in">disable</span> = no</div><div class="line">        <span class="built_in">type</span>            = UNLISTED</div><div class="line">        port            = 9418</div><div class="line">        socket_type     = stream</div><div class="line">        <span class="built_in">wait</span>            = no</div><div class="line">        user            = nobody</div><div class="line">        server          = /usr/bin/git-daemon</div><div class="line">        server_args     = --inetd --export-all --base-path=/pub/scm</div><div class="line">        log_on_failure  += USERID</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查<code>xinetd(8)</code>文档并设置，这个文档来自于Fedora系统。其他也许会不一样。</p>
<p><strong>授予开发者只推/拉访问操作权限</strong><br>Give push/pull only access to developers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/passwd &lt;1&gt;</div><div class="line">alice:x:1000:1000::/home/alice:/usr/bin/git-shell</div><div class="line">bob:x:1001:1001::/home/bob:/usr/bin/git-shell</div><div class="line">cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell</div><div class="line">david:x:1003:1003::/home/david:/usr/bin/git-shell</div><div class="line">$ grep git /etc/shells &lt;2&gt;</div><div class="line">/usr/bin/git-shell</div></pre></td></tr></table></figure></p>
<ol>
<li>登录<code>shell</code>被设置到<code>/usr/bin/git-shell</code>, 不允许<em><code>git push</code></em>和<em><code>git pull</code></em>以外的任何操作。用户需要获得一个访问此机器的<code>ssh</code>权限。</li>
<li>在许多发布版本中，<code>/etc/shells</code>需要列出作为一个登录<code>shell</code>所使用的程序。</li>
</ol>
<p><strong>CVS风格的共享代码库</strong><br>CVS-style shared repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/group &lt;1&gt;</div><div class="line">git:x:9418:alice,bob,cindy,david</div><div class="line">$ <span class="built_in">cd</span> /home/devo.git</div><div class="line">$ ls <span class="_">-l</span> &lt;2&gt;</div><div class="line">  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -&gt; refs/heads/master</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches</div><div class="line">  -rw-rw-r--   1 david git    84 Dec  4 22:40 config</div><div class="line">  -rw-rw-r--   1 david git    58 Dec  4 22:40 description</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks</div><div class="line">  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info</div><div class="line">  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects</div><div class="line">  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes</div><div class="line">$ ls <span class="_">-l</span> hooks/update &lt;3&gt;</div><div class="line">  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update</div><div class="line">$ cat info/allowed-users &lt;4&gt;</div><div class="line">refs/heads/master       alice\|cindy</div><div class="line">refs/heads/doc-update   bob</div><div class="line">refs/tags/v[0-9]*       david</div></pre></td></tr></table></figure></p>
<ol>
<li>把开发者置于同一<code>git</code>组中。</li>
<li>将共享代码库配为组可写。</li>
<li>使用 Documentation/howto/ 中Carl的<code>update-hook</code>实例作为分支策略控制。</li>
<li>alice和cindy可以推送到主分支（master），只有bob可以推送进<code>doc-update</code>。david是发布经理，并且是唯一可以创建并推送版本标签的人。</li>
</ol>
<p><strong>支持dumb协议传送的HTTP服务器</strong><br>HTTP server to support dumb protocol transfer.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dev$ git update-server-info &lt;1&gt;</div><div class="line">dev$ ftp user@isp.example.com &lt;2&gt;</div><div class="line">ftp&gt; cp -r .git /home/user/myproject.git</div></pre></td></tr></table></figure></p>
<ol>
<li>确保你的 <code>info/refs</code> 和 <code>objects/info/packs</code> 是最新的。</li>
<li>上传到由你的ISP托管的公共HTTP服务器。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>https://jarsonfang.github.io/tools/VCS/git-in-common/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html" target="_blank" rel="external">http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html</a></p>
<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。</p>
<img src="/tools/VCS/git-in-common/git_commands.png" alt="common git commands" title="common git commands">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sparse 简介]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/sparse/</url>
      <content type="html"><![CDATA[<p>参考：<br><a href="http://www.cnblogs.com/wang_yb/p/3575039.html" target="_blank" rel="external">内核工具 – Sparse 简介</a><br><a href="http://en.wikipedia.org/wiki/Sparse" target="_blank" rel="external">http://en.wikipedia.org/wiki/Sparse</a></p>
<p>Sparse (Semantic Parser) 是内核代码静态分析工具, 能够帮助我们找出代码中的隐患.<br><a id="more"></a></p>
<h2 id="Sparse-介绍"><a href="#Sparse-介绍" class="headerlink" title="Sparse 介绍"></a>Sparse 介绍</h2><p>Sparse 诞生于 2004 年, 是由linux之父开发的, 目的就是提供一个静态检查代码的工具, 从而减少linux内核的隐患.</p>
<p>其实在Sparse之前, 已经有了一个不错的代码静态检查工具(“SWAT”), 只不过这个工具不是免费软件, 使用上有一些限制。所以 linus 还是自己开发了一个静态检查工具.</p>
<p>具体可以参考这篇文章(2004年的文章了):<a href="http://lwn.net/Articles/87538/" target="_blank" rel="external">Finding kernel problems automatically</a></p>
<p>内核代码中还有一个简略的关于Sparse的说明文件: <span style="color:red;"><em>Documentation/sparse.txt</em></span></p>
<p>Sparse通过 gcc 的扩展属性 <code>__attribute__</code> 以及sparse定义的 <code>__context__</code> 来对代码进行静态检查.</p>
<p>这些属性如下(尽量整理的,可能还有些不全的地方):</p>
<table>
<thead>
<tr>
<th>宏名称</th>
<th>宏定义</th>
<th>检查点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__bitwise</code></td>
<td><code>__attribute__((bitwise))</code></td>
<td>确保变量是相同的位方式(比如 <code>big-endian</code>, <code>little-endia</code>等)</td>
</tr>
<tr>
<td><code>__user</code></td>
<td><code>__attribute__((noderef, address_space(1)))</code></td>
<td>指针地址必须在用户地址空间</td>
</tr>
<tr>
<td><code>__kernel</code></td>
<td><code>__attribute__((noderef, address_space(0)))</code></td>
<td>指针地址必须在内核地址空间</td>
</tr>
<tr>
<td><code>__iomem</code></td>
<td><code>__attribute__((noderef, address_space(2)))</code></td>
<td>指针地址必须在设备地址空间</td>
</tr>
<tr>
<td><code>__safe</code></td>
<td><code>__attribute__((safe))</code></td>
<td>变量可以为空</td>
</tr>
<tr>
<td><code>__force</code></td>
<td><code>__attribute__((force))</code></td>
<td>变量可以进行强制转换</td>
</tr>
<tr>
<td><code>__nocast</code></td>
<td><code>__attribute__((nocast))</code></td>
<td>参数类型与实际参数类型必须一致</td>
</tr>
<tr>
<td><code>__acquires(x)</code></td>
<td><code>__attribute__((context(x, 0, 1)))</code></td>
<td>参数x 在执行前引用计数必须是0,执行后,引用计数必须为1</td>
</tr>
<tr>
<td><code>__releases(x)</code></td>
<td><code>__attribute__((context(x, 1, 0)))</code></td>
<td>与 <code>__acquires(x)</code> 相反</td>
</tr>
<tr>
<td><code>__acquire(x)</code></td>
<td><code>__context__(x, 1)</code></td>
<td>参数x的引用计数 + 1</td>
</tr>
<tr>
<td><code>__release(x)</code></td>
<td><code>__context__(x, -1)</code></td>
<td>与 <code>__acquire(x)</code> 相反</td>
</tr>
<tr>
<td><code>__cond_lock(x,c)</code></td>
<td><code>((c) ? ({ __acquire(x); 1; }) : 0)</code></td>
<td>参数<code>c</code>不为0时,引用计数 + 1, 并返回1</td>
</tr>
</tbody>
</table>
<p>其中 <code>__acquires(x)</code> 和 <code>__releases(x)</code>, <code>__acquire(x)</code> 和 <code>__release(x)</code> 必须配对使用, 否则 Sparse 会给出警告。</p>
<p>修饰符 <code>__attribute__((context(...)))</code> 可由Sparse宏 <code>__context__(...)</code>替代，<code>context(...</code> 原型为：<code>context(expression,in_context,out_context)</code></p>
<h2 id="Linux-内核中的定义"><a href="#Linux-内核中的定义" class="headerlink" title="Linux 内核中的定义"></a>Linux 内核中的定义</h2><p>Linux内核在 <span style="color:red;"><em>linux/compiler.h</em></span> 和 <span style="color:red;"><em>linux/types.h</em></span> 文件中定义了如下简短形式的预编译宏(如果编译的时候不使用 <code>__CHECKER__</code> 标记, 代码中所有的这些注记将被删除):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CHECKER__</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __user		__attribute__((noderef, address_space(1)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __kernel	__attribute__((address_space(0)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __iomem	__attribute__((noderef, address_space(2)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __safe		__attribute__((safe))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __force	__attribute__((force))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __nocast	__attribute__((nocast))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __must_hold(x)	__attribute__((context(x,1,1)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquires(x)	__attribute__((context(x,0,1)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __releases(x)	__attribute__((context(x,1,0)))</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquire(x)	__context__(x,1)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __release(x)	__context__(x,-1)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __cond_lock(x,c)	((c) ? (&#123; __acquire(x); 1; &#125;) : 0)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __percpu	__attribute__((noderef, address_space(3)))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SPARSE_RCU_POINTER</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu		__attribute__((noderef, address_space(4)))</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __chk_user_ptr(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __user *);</div><div class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __chk_io_ptr(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __user</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __kernel</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __iomem</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __safe</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __force</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __nocast</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __chk_user_ptr(x) (void)0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __chk_io_ptr(x) (void)0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __builtin_warning(x, y...) (1)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __must_hold(x)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquires(x)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __releases(x)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __acquire(x) (void)0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __release(x) (void)0</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __cond_lock(x,c) (c)</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __percpu</span></div><div class="line"><span class="meta"># <span class="meta-keyword">define</span> __rcu</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">[/cc]</div><div class="line">[cc lang=<span class="string">"c"</span>]</div><div class="line">#ifdef __CHECKER__</div><div class="line"># define __bitwise__    __attribute__((bitwise))</div><div class="line">#<span class="keyword">else</span></div><div class="line"># define __bitwise__</div><div class="line">#endif</div><div class="line"></div><div class="line">#ifdef __CHECK_ENDIAN__</div><div class="line"># define __bitwise      __bitwise__</div><div class="line">#<span class="keyword">else</span></div><div class="line"># define __bitwise</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> __u32 __bitwise    __le32;</div><div class="line"><span class="keyword">typedef</span> __u32 __bitwise    __be32;</div></pre></td></tr></table></figure></p>
<p>类型 <code>__le32</code> 和 <code>__be32</code> 代表不同字节顺序的32位整数类型。然而，C 语言并未指定这些类型的变量不应混合在一起。按位(bitwise)属性是用来标记这些类型的限制，所以，如果这些类型或其他整型变量混合在一起，Sparse将给出警告信息。<br>为了标记(mark)限制类型( restricted types)之间的有效转换，使用强制(force)属性的以避免Sparse给予警告。</p>
<p><strong>Using sparse for lock checking</strong></p>
<p>The following macros are undefined for gcc and defined during a sparse run to use the “context” tracking feature of sparse, applied to locking. These annotations tell sparse when a lock is held, with regard to the annotated function’s entry and exit.</p>
<blockquote>
<p><code>__must_hold</code> - The specified lock is held on function entry and exit.<br><code>__acquires</code> - The specified lock is held on function exit, but not entry.<br><code>__releases</code> - The specified lock is held on function entry, but not exit.</p>
</blockquote>
<p>If the function enters and exits without the lock held, acquiring and releasing the lock inside the function in a balanced way, noannotation is needed. The tree annotations above are for cases where sparse would otherwise report a context imbalance.</p>
<h2 id="Sparse-在编译内核中的使用"><a href="#Sparse-在编译内核中的使用" class="headerlink" title="Sparse 在编译内核中的使用"></a>Sparse 在编译内核中的使用</h2><p>用 Sparse 对内核进行静态分析非常简单.</p>
<blockquote>
<p># 检查所有内核代码<br>make C=1 检查所有重新编译的代码<br>make C=2 检查所有代码, 不管是不是被重新编译</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标准I/O库]]></title>
      <url>https://jarsonfang.github.io/programming/APUE/std-io-lib/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://www.cnblogs.com/CoreyGao/archive/2013/04/23/3038490.html" target="_blank" rel="external">APUE读书笔记 之 标准I/O库</a></p>
<p>本章以stream(区别开STREAMS)为中心，讲解了UNIX的标准I/O库。</p>
<p>stream的核心是<code>FILE</code>结构。打开一个stream时，<code>fopen</code>返回一个<code>FILE</code>对象指针。该<code>FILE</code>结构包括：用于实际I/O的文件描述符，指向该流缓冲区的指针，缓冲区的长度，当前缓冲区的字符，以及出错标志等等。</p>
<p><code>FILE</code>结构定义在<code>/usr/include/stdio.h</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IO_FILE FILE;</div></pre></td></tr></table></figure></p>
<p><code>_IO_FILE</code>结构定义在<code>/usr/include/libio.h</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> _IO_FILE &#123;</div><div class="line"><span class="keyword">int</span> _flags; <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></div><div class="line"></div><div class="line"><span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></div><div class="line"><span class="comment">/* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></div><div class="line"><span class="keyword">char</span>* _IO_read_ptr; <span class="comment">/* Current read pointer */</span></div><div class="line"><span class="keyword">char</span>* _IO_read_end; <span class="comment">/* End of get area. */</span></div><div class="line"><span class="keyword">char</span>* _IO_read_base; <span class="comment">/* Start of putback+get area. */</span></div><div class="line"><span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></div><div class="line"><span class="keyword">char</span>* _IO_write_ptr; <span class="comment">/* Current put pointer. */</span></div><div class="line"><span class="keyword">char</span>* _IO_write_end; <span class="comment">/* End of put area. */</span></div><div class="line"><span class="keyword">char</span>* _IO_buf_base; <span class="comment">/* Start of reserve area. */</span></div><div class="line"><span class="keyword">char</span>* _IO_buf_end; <span class="comment">/* End of reserve area. */</span></div><div class="line"><span class="comment">/* The following fields are used to support backing up and undo. */</span></div><div class="line"><span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></div><div class="line"><span class="keyword">char</span> *_IO_backup_base; <span class="comment">/* Pointer to first valid character of backup area */</span></div><div class="line"><span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> _IO_marker *_markers;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> _IO_FILE *_chain;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _fileno;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></div><div class="line"><span class="keyword">int</span> _blksize;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">int</span> _flags2;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">_IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small. */</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></div><div class="line"><span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</div><div class="line"><span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</div><div class="line"><span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="comment">/* char* _save_gptr; char* _save_egptr; */</span></div><div class="line"></div><div class="line">_IO_lock_t *_lock;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>本章主要内容总结如下图：<br><img src="/programming/APUE/std-io-lib/stdio.png" alt="stdio.png" title=""></p>
<h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>文件I/O函数都是针对文件描述符操作的。当打开一个文件时，则返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作则是围绕流(stream)进行的。当用标准I/O库打开或创建一个文件时，则使一个流与一个文件相关联。</p>
<p>对于ASCII字符集，一个字符用一个字节表示。对于Unicode字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节（“宽”）字符集。<em>流的定向</em>（stream’s orientation）决定了所读、写的字符是单字节还是多字节。当一个流最初被创建时，它并没有定向。</p>
<ul>
<li>若在未定向的流上使用一个多字节I/O函数（见&lt;wchar.h&gt;），则将该流的定向设置为宽定向的。</li>
<li>若在未定向的流上使用一个单字节I/O函数，则将该流的定向设置为字节定向的。</li>
</ul>
<p>只有两个函数可以改变流的定向：<code>freopen</code>函数清除一个流的定向；<code>fwide</code>函数设置流的定向。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *fp, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line">    Returns: positive <span class="keyword">if</span> stream is wide-oriented,</div><div class="line">        negative <span class="keyword">if</span> stream is byte-oriented,</div><div class="line">          or <span class="number">0</span> <span class="keyword">if</span> stream has no orientation</div></pre></td></tr></table></figure></p>
<p>根据<code>mode</code>参数的不同值，<code>fwide</code>函数执行不同的操作：</p>
<ul>
<li>若<code>mode</code>参数值为负，<code>fwide</code>将试图设置指定的流为字节定向。</li>
<li>若<code>mode</code>参数值为正，<code>fwide</code>将试图设置指定的流为宽定向。</li>
<li>若<code>mode</code>参数值为0，<code>fwide</code>将不设置流的定向，而是返回标识该流定向的值。</li>
</ul>
<p>注意，<code>fwide</code>并不改变已定向流的定向。</p>
<p>当打开一个流时，标准I/O函数<code>fopen</code>返回一个指向<code>FILE</code>对象的指针。该对象通常是一个结构，它包含了标准I/O库为管理该流所需要的所有信息，包括：用于实际I/O的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等等。为引用一个流，需将<code>FILE</code>指针作为参数传递给每个标准I/O函数。<code>FILE</code>对象指针（类型为<code>FILE *</code>）也称为<span style="color: red;"><em>文件指针</em></span>。</p>
<p><strong>标准输入、标准输出和标准错误</strong></p>
<p>对一个进程预定义了三个流，并且这三个流可以自动的被进程使用，它们是：标准输入、标准输出和标准错误。这些流引用的文件与文件描述符<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code> 和 <code>STDERR_FILENO</code> 所引用的文件相同。<br>这三个标准I/O流通过预定义文件指针<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 加以引用。这三个文件指针同样定义在头文件&lt;stdio.h&gt;中。</p>
<h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准I/O库提供缓冲的目的是尽可能减少使用<code>read</code>和<code>write</code>调用的次数。它也对每个I/O流自动进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。不幸的是，标准I/O库最令人迷惑的也是它的缓冲。<br>标准I/O提供了三种类型的缓冲：<br>（1）全缓冲。这种情况下，在<span style="color: red;">填满标准I/O缓冲区</span>后才进行实际I/O操作。对于驻留在磁盘上的文件，通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用<code>malloc</code>获得需要使用的缓冲区。<br>（2）行缓冲。这种情况下，当在输入或输出中<span style="color: red;">遇到换行符</span>时，标准I/O库执行实际I/O操作。当流涉及一个终端时（例如标准输入和标准输出），通常使用行缓冲。<br>（3）不带缓冲。标准I/O库不对字符进行缓冲存储。调用标准I/O函数的每一次读写都会进行实际的I/O操作。标准错误流<code>stderr</code>通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它是否含有一个换行符。<br>术语 <em>冲洗</em>（flush）说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动冲洗（例如当填满一个缓冲区时），或者可以调用<code>fflush</code>冲洗一个流。值得注意的是，在UNIX环境中，flush有两种意思：在标准I/O库方面，flush（冲洗）表示将缓冲区中的内容写到磁盘上（该缓冲区可能未填满）；而在终端驱动程序方面（例如<code>tcflush</code>函数），flush（刷清）表示丢弃已存储在缓冲区中的数据。</p>
<p>对于行缓冲，有两个限制。<br>第一，因为标准I/O库用来收集每一行字符的缓冲区长度是固定的，所以只要填满了缓冲区，即使还没有写入一个换行符，也进行I/O操作。<br>第二，任何时候只要通过标准I/O库从（a）一个不带缓冲的流，或者（b）一个行缓冲的流（它需要向内核请求数据）输入数据，则会冲洗所有行缓冲输出流。</p>
<p>对任何一个给定的流，可调用下列两个函数中的任一个更改缓冲类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *<span class="keyword">restrict</span> fp, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, nonzero on error</div></pre></td></tr></table></figure></p>
<p>这些函数一定要在流已被打开后调用（这是十分明显的，因为每个函数都要求一个有效的文件指针作为它的第一个参数），而且也应该在对该流执行任何一个其他操作之前调用。</p>
<p>可以使用<code>setbuf</code>函数打开或关闭缓冲机制。为了带缓冲进行I/O，参数buf必须指向一个长度为BUFSIZ的缓冲区（该常量定义在&lt;stdio.h&gt;中）。通常在此之后该流就是全缓冲的，但如果该流与一个终端设备关联，那么某些系统也可将其设置为行缓冲。为了关闭缓冲，将buf设置为NULL。</p>
<p>使用setvbuf，可以精确的指定所需的缓冲类型。这是用mode参数实现的：</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_IOFBF</code></td>
<td>全缓冲（fully buffered）</td>
</tr>
<tr>
<td><code>_IOLBF</code></td>
<td>行缓冲（line buffered）</td>
</tr>
<tr>
<td><code>_IONBF</code></td>
<td>不带缓冲（unbuffered）</td>
</tr>
</tbody>
</table>
<ul>
<li>如果指定一个不带缓冲的流，则忽略<code>buf</code>和<code>size</code>参数。</li>
<li>如果指定全缓冲或行缓冲，则<code>buf</code>和<code>size</code>可选择地指定一个缓冲区及其长度。</li>
<li>如果该流是带缓冲的，而<code>buf</code>是<code>NULL</code>，则标准I/O库将自动的为该流分配适当长度的缓冲区。适当长度指的是由常量<code>BUFSIZ</code>所指定的值。</li>
</ul>
<blockquote>
<p>某些C函数库实现使用<code>stat</code>结构中的成员<code>st_blksize</code>所指定的值决定最佳I/O缓冲区长度，GNU C函数库就使用这种方法。</p>
</blockquote>
<p>如果在一个函数内分配一个自动变量类型的标准I/O缓冲区，则从该函数返回之前，必须关闭流（因为函数返回后，自动变量内存被自动释放）。另外，有些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于<code>size</code>。一般而言，应由系统选择缓冲区的长度，并自动分配缓冲区，在这种情况下关闭该流时，标准I/O库将自动释放缓冲区。</p>
<p>在任何时候，都可以强制冲洗一个流。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, EOF on error</div></pre></td></tr></table></figure></p>
<p>此函数使所指定流中所有未写的数据都被传送至内核。作为一个特例，如若<code>fp</code>为<code>NULL</code>，则此函数将导致所有输出流被冲洗。</p>
<h2 id="流-stream-I-O"><a href="#流-stream-I-O" class="headerlink" title="流(stream) I/O"></a>流(stream) I/O</h2><h3 id="打开和关闭流"><a href="#打开和关闭流" class="headerlink" title="打开和关闭流"></a>打开和关闭流</h3><p>下列三个函数打开一个标准I/O流：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type)</span></span>;</div><div class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> type,</span></span></div><div class="line">              FILE *<span class="keyword">restrict</span> fp);</div><div class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</div><div class="line"></div><div class="line">    All three <span class="keyword">return</span>: file pointer <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</div></pre></td></tr></table></figure></p>
<p>这三个函数的区别是：<br>（1）<code>fopen</code>打开一个指定的文件。<br>（2）<code>freopen</code>在一个指定的流上打开一个指定的文件。</p>
<ul>
<li>如果该流已经打开，则先关闭该流；</li>
<li>如果该流已经定向，则<code>freopen</code>清除该定向。</li>
</ul>
<p>此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出和标准错误。<br>（3）<code>fdopen</code>获取一个现有的文件描述符，并关联一个标准的I/O流到该文件描述符。此函数常用于由创建管道或网络通信通道的函数返回的描述符（可由<code>open</code>、<code>dup</code>、<code>dup2</code>、<code>fcntl</code>、<code>pipe</code>、<code>socket</code>、<code>socketpair</code>或<code>accept</code>函数获得），因为这些特殊类型的文件不能用标准I/O<code>fopen</code>函数打开，所以必须先调用设备专用函数获得一个文件描述符，然后用<code>fdopen</code>关联一个标准I/O流到该描述符。</p>
<blockquote>
<p><code>fopen</code>和<code>freopen</code>是ISO C的组成部分，而<code>fdopen</code>是POSIX.1的组成部分，因为ISO C并不涉及文件描述符。</p>
</blockquote>
<p><code>type</code>参数指定对I/O流的读、写方式，ISO C规定<code>type</code>参数有15种不同的值，如下表5-2所示。</p>
<p>Figure 5.2. The type argument for opening a standard I/O stream</p>
<table>
<thead>
<tr>
<th>type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>r or rb</td>
<td>open for reading</td>
</tr>
<tr>
<td>w or wb</td>
<td>truncate to 0 length or create for writing</td>
</tr>
<tr>
<td>a or ab</td>
<td>append; open for writing at end of file, or create for writing</td>
</tr>
<tr>
<td>r+ or r+b or rb+</td>
<td>open for reading and writing</td>
</tr>
<tr>
<td>w+ or w+b or wb+</td>
<td>truncate to 0 length or create for reading and writing</td>
</tr>
<tr>
<td>a+ or a+b or ab+</td>
<td>open or create for reading and writing at end of file</td>
</tr>
</tbody>
</table>
<p>使用字符 <code>b</code> 作为<code>type</code>的一部分，这使得标准I/O系统可以区分文本文件和二进制文件。因为UNIX内核并不区分这两种文件，所以在UNIX系统环境下指定字符 <code>b</code> 作为<code>type</code>的一部分，实际上并无作用。</p>
<p>对于<code>fdopen</code>，<code>type</code>参数的意义稍有区别。因为该描述符已被打开，所以<code>fdopen</code>为写而打开（opening for write）并不截短（truncate）该文件。另外，标准I/O添写方式(append mode)也不能用于创建该文件（如果一个描述符引用一个文件，则该文件一定已经存在）。</p>
<p>当用添写方式打开一个文件，则每次写都将数据写到文件的当前尾端处。如果有多个进程用标准I/O添写方式打开同一个文件，来自每个进程的数据都将正确地被写到文件中。</p>
<p>当以读和写方式打开一个文件时（<code>type</code>中的 <code>+</code> 符号），具有下列限制：</p>
<ul>
<li>如果中间没有<code>fflush</code>、<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，则在输出的后面不能直接跟随输入。</li>
<li>如果中间没有<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。</li>
</ul>
<p>在指定 <code>w</code> 或 <code>a</code> 方式创建一个新文件时，无法说明该文件的访问权限位（<code>open</code>函数和<code>creat</code>函数则能做到这一点）。</p>
<p>除非流引用终端设备，否则按系统默认的情况，流被打开时是全缓冲的。若流引用终端设备，则该流是行缓冲的。流一旦被打开，在对该流执行任何操作之前，如果希望，则可以使用前述的 <code>setbuf</code> 和 <code>setvbuf</code> 改变缓冲的类型。</p>
<p>调用<code>fclose</code>关闭一个打开的流。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, EOF on error</div></pre></td></tr></table></figure></p>
<p>在该文件被关闭之前，冲洗缓冲区中的输出数据，丢弃缓冲区中的输入数据。如果标准I/O库已经为该流自动分配了一个缓冲区，则释放该缓冲区。</p>
<p>当一个进程正常终止时（直接调用<code>exit</code>函数，或从<code>main</code>函数返回），则所有未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭。</p>
<h3 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h3><p>一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择，对其进行读、写操作：</p>
<ul>
<li>每次一个字符 I/O（Character-at-a-time I/O）。一次读或写一个字符，如果流是带缓冲的，则标准I/O函数会处理所有缓冲。</li>
<li>每次一行 I/O（Line-at-a-time I/O）。如果想要一次读或写一行，则使用<code>fgets</code>和<code>fputs</code>。每行都以一个换行符终止。</li>
<li>直接 I/O（Direct I/O）。<code>fread</code>和<code>fwrite</code>函数支持这种类型的I/O。每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。</li>
</ul>
<blockquote>
<p>直接I/O这个术语来自ISO C标准，有时也称为二进制I/O、一次一个对象I/O、面向记录的I/O或面向结构的I/O。</p>
</blockquote>
<h4 id="每次一个字符-I-O"><a href="#每次一个字符-I-O" class="headerlink" title="每次一个字符 I/O"></a>每次一个字符 I/O</h4><p><strong>1、输入函数</strong></p>
<p>以下三个函数可用于一次读入一个字符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"></div><div class="line">    All three <span class="keyword">return</span>: next character <span class="keyword">if</span> OK, EOF on end of file or error</div></pre></td></tr></table></figure></p>
<p>函数<code>getchar</code>等价于<code>getc(stdin)</code>。前两个函数的区别是，<code>getc</code>可被实现为宏，而<code>fgetc</code>则不能实现为宏。这意味着：</p>
<ul>
<li><code>getc</code>的参数不应当是具有副作用的表达式。</li>
<li>因为<code>fgetc</code>一定是一个函数，所以可以得到其地址。这就允许将<code>fgetc</code>的地址作为一个参数传送给另一个函数。</li>
<li>调用<code>fgetc</code>所需时间可能长于调用<code>getc</code>，因为调用函数通常所需的时间长于调用宏。</li>
</ul>
<p>这三个函数在返回下一个字符时，会将其<code>unsigned char</code>类型转换为<code>int</code>类型。声明为不带符号的理由是，如果最高位为1也不会使返回值为负。要求整型返回值的理由是，这样就可以返回所有可能的字符值，再加上一个已出错或已到达文件尾端的指示值。在&lt;stdio.h&gt;中的常量<code>EOF</code>被要求是一个负值，其值经常是<code>-1</code>。这就意味着不能将这三个函数的返回值存放在一个字符变量中，以后还要将这些函数的返回值与常量<code>EOF</code>相比较。</p>
<p>注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值<code>EOF</code>。为了区分这两种不同的情况，必须调用<code>ferror</code>或<code>feof</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: nonzero (<span class="literal">true</span>) <span class="keyword">if</span> condition is <span class="literal">true</span>, <span class="number">0</span> (<span class="literal">false</span>) otherwise</div><div class="line"></div><div class="line"><span class="keyword">void</span> clearerr(FILE *fp);</div></pre></td></tr></table></figure></p>
<p>在大多数实现中，为每个流在<code>FILE</code>对象中维持两个标志：</p>
<ul>
<li>出错标志。</li>
<li>文件结束标志</li>
</ul>
<p>调用<code>clearerr</code>则清除这两个标志。</p>
<p>从流中读取数据以后，可以调用ungetc将字符再压送回流中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"></div><div class="line">    Returns: c <span class="keyword">if</span> OK, EOF on error</div></pre></td></tr></table></figure></p>
<p>压送回流中的字符以后又可以从流中读出，但读出字符的顺序与压送回的顺序相反。虽然ISO C允许实现支持任何次数的回送，但是它要求实现提供一次只回送一个字符，不能一次回送多个字符。</p>
<p>回送的字符不必一定是上一次读到的字符。不能回送<code>EOF</code>（<code>EOF</code>并非文件中的数据，而是文件到达尾端时的指示值），但是当已经到达文件尾端时，仍可以回送一个字符。下次读将返回该字符，再次读则返回<code>EOF</code>。之所以能这样做的原因是，一次成功的<code>ungetc</code>调用会清除该流的文件结束标志。</p>
<p>Pushback is often used when we’re reading an input stream and breaking the input into words or tokens of some form.<br>当正在读一个输入流，并进行某种形式的分字或分记号操作时，会经常用到回送字符的操作。</p>
<p>有时需要先看一看下一个字符，以决定如何处理当前字符。因此需要方便地将刚查看的字符送回，以便下一次调用<code>getc</code>时返回该字符。如果标准I/O库不提供回送功能，就需要将该字符存放到一个变量中，并设置一个标志以便判别在下一次需要一个字符时是调用<code>getc</code>，还是从变量中读取。</p>
<blockquote>
<p>用<code>ungetc</code>压送回字符时，并没有将它们写到文件中或设备上，只是将它们写回标准I/O库的流缓冲区。</p>
</blockquote>
<p><strong>2、输出函数</strong></p>
<p>对应于上面所述的每个输入函数，都有一个输出函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</div><div class="line"></div><div class="line">    All three <span class="keyword">return</span>: c <span class="keyword">if</span> OK, EOF on error</div></pre></td></tr></table></figure></p>
<p>与输入函数一样，<code>putchar(c)</code>等效于<code>putc(c, stdout)</code>，<code>putc</code>可实现为宏，而<code>fputc</code>则不能实现为宏。</p>
<h4 id="每次一行-I-O"><a href="#每次一行-I-O" class="headerlink" title="每次一行 I/O"></a>每次一行 I/O</h4><p>下面两个函数提供每次输入一行的功能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: buf <span class="keyword">if</span> OK, <span class="literal">NULL</span> on end of file or error</div></pre></td></tr></table></figure></p>
<p>这两个函数都指定了缓冲区的地址，并将读入的行送入其中。<code>gets</code>从标准输入读，而<code>fgets</code>则从指定的流读。</p>
<p>对于<code>fgets</code>，必须指定缓冲区的长度<code>n</code>。此函数从流中读取字符，直到遇到一个换行符（包含该换行符）为止，但是不超过<code>n-1</code>个字符。读入的字符被送入缓冲区，该缓冲区以<code>null</code>字符结尾。如果该行（包括最后的换行符）的字符超过<code>n-1</code>，则<code>fgets</code>返回一个不完整的行，但缓冲区总会以<code>null</code>字符结尾，对<code>fgets</code>的下一次调用会继续读取该行剩下的数据。</p>
<p><code>gets</code>是一个不推荐使用的函数。其问题在于调用者在使用<code>gets</code>时不能指定缓冲区的长度，这样就可能造成缓冲区溢出（如果该行长于缓冲区长度），写到缓冲区之后的存储空间，从而产生不可预料的后果。<span style="color:red;"><code>gets</code>与<code>fgets</code>的另一个区别是，<code>gets</code>并不将换行符存入缓冲区中。</span></p>
<p>即使ISO C要求实现提供<code>gets</code>，但请使用<code>fgets</code>，而不要使用<code>gets</code>。</p>
<p><code>fputs</code> 和 <code>puts</code> 提供每次输出一行的功能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> str, FILE *<span class="keyword">restrict</span> fp)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: non-negative value <span class="keyword">if</span> OK, EOF on error</div></pre></td></tr></table></figure></p>
<p>函数<code>fputs</code>将一个<span style="color:red;">以<code>null</code>字符终止的字符串</span>写到指定的流，<span style="color:red;">尾端的终止符<code>null</code>不写出</span>。注意，这并不一定是每次输出一行，因为它并不要求在<code>null</code>字符之前一定是换行符。通常，在<code>null</code>字符之前是一个换行符，但并不要求总是如此。</p>
<p><code>puts</code>将一个以<code>null</code>字符终止的字符串写到标准输出，终止符不写出。<span style="color:red;">但是，<code>puts</code>然后又将一个换行符写到标准输出。</span></p>
<p><code>puts</code>并不像它所对应的<code>gets</code>那样不安全，但还是要避免使用它，以免需要记住它在最后是否添加了一个换行符。如果总是使用<code>fgets</code>和<code>fputs</code>，那么就会熟知在每行终止处必须自己处理换行符。</p>
<h4 id="二进制-I-O"><a href="#二进制-I-O" class="headerlink" title="二进制 I/O"></a>二进制 I/O</h4><p>二进制 I/O，通常是一次读或写一整个结构体。下列两个函数执行二进制I/O操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">             FILE *<span class="keyword">restrict</span> fp);</div><div class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *<span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj,</div><div class="line">              FILE *<span class="keyword">restrict</span> fp);</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: number of objects read or written</div></pre></td></tr></table></figure></p>
<p>这些函数的两种常见的用法：<br>（1）读或写一个二进制数组。例如，将一个浮点数组的第2～5个元素写至一个文件上，可编写如下程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> data[<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (fwrite(&amp;data[<span class="number">2</span>], <span class="keyword">sizeof</span>(<span class="keyword">float</span>), <span class="number">4</span>, fp) != <span class="number">4</span>)</div><div class="line">    err_sys(<span class="string">"fwrite error"</span>);</div></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为每个数组元素的长度，<code>nobj</code>为欲写的元素数。</p>
<p>（2）读或写一个结构。例如，可编写如下程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line">  <span class="keyword">short</span>   count;</div><div class="line">  <span class="keyword">long</span>    total;</div><div class="line">  <span class="keyword">char</span>    name[NAMESIZE];</div><div class="line">&#125; item;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (fwrite(&amp;item, <span class="keyword">sizeof</span>(item), <span class="number">1</span>, fp) != <span class="number">1</span>)</div><div class="line">    err_sys(<span class="string">"fwrite error"</span>);</div></pre></td></tr></table></figure></p>
<p>其中，指定<code>size</code>为结构的长度，<code>nobj</code>为1（要写的对象数）。</p>
<p>将这两个例子结合起来就可读或写一个结构数组。为了做到这点，<code>size</code>应当是该结构的<code>sizeof</code>，<code>nobj</code>应是该数组中的元素个数。</p>
<p><code>fread</code>和<code>fwrite</code>返回读或写的对象数。</p>
<ul>
<li>对于读，如果出错或到达文件尾端，则返回值可以小于<code>nobj</code>。这种情况下，应调用<code>ferror</code>或<code>feof</code>以判断究竟属于哪一种情况。</li>
<li>对于写，如果返回值小于所要求的<code>nobj</code>，则出错。</li>
</ul>
<p>使用二进制I/O的基本问题是，它只能用于读在同一系统上已写的数据。其原因是：<br>（1）在一个结构中，同一成员的偏移量可能因编译器和系统而异（不同的对齐要求）。<br>（2）用来存储多字节整数和浮点值的二进制格式在不同的机器体系结构间也可能不同。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核参数简介]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/linux-kernel-parameters/</url>
      <content type="html"><![CDATA[<p>参考：<br><a href="http://works.jinbuguo.com/kernel/boot_parameters.html" target="_blank" rel="external">Linux 内核引导参数简介</a><br>内核文档 Documentation/kernel-parameters.txt</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>内核引导参数大体上可以分为两类：一类与设备无关，另一类与设备有关。与设备有关的引导参数多如牛毛，需要阅读内核中的相应驱动程序源码以获取其能够接受的引导参数。比如，如果想知道可以向 AHA1542 SCSI 驱动程序传递哪些引导参数，那么就查看 drivers/scsi/aha1542.c 文件，一般在前面 100 行注释里就可以找到所接受的引导参数说明。大多数参数是通过”<code>__setup(... , ...)</code>“函数设置的，少部分是通过”<code>early_param(... , ...)</code>“函数设置的，逗号前的部分就是引导参数的名称，后面的部分就是处理这些参数的函数名。<br><a id="more"></a><br>[提示]你可以在源码树的根目录下试一试下面两个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grep -r <span class="string">'\b__setup *('</span> *</div><div class="line">grep -r <span class="string">'\bearly_param *('</span> *</div></pre></td></tr></table></figure></p>
<p>格式上，多个参数之间用空格分隔，参数值是一个逗号分隔的列表，并且参数值中不能包含空白。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">正确：ether=9,0x300,0xd0000,0xd4000,eth0  root=/dev/sda2</div><div class="line">错误：ether = 9, 0x300, 0xd0000, 0xd4000, eth0  root = /dev/sda2</div></pre></td></tr></table></figure></p>
<p>注意，所有引导参数都是大小写敏感的！</p>
<p>在内核运行起来之后，可以通过 cat /proc/cmdline 命令查看当初使用的引导参数以及相应的值。</p>
<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><p>对于模块而言，引导参数只能用于直接编译到核心中的模块，格式是”<code>模块名.参数=值</code>“，比如”<code>usbcore.blinkenlights=1</code>“。动态加载的模块则可以在<code>modprobe</code> 命令行上指定相应的参数值，比如”<code>modprobe usbcore blinkenlights=1</code>“。</p>
<p>可以使用”<code>modinfo -p ${modulename}</code>“命令显示可加载模块的所有可用参数。已经加载到内核中的模块会在<code>/sys/module/${modulename}/parameters/</code>中显示出其参数，并且某些参数的值还可以在运行时通过”<code>echo -n ${value} &gt; /sys/module/${modulename}/parameters/${parm}</code>“进行修改。</p>
<h3 id="内核如何处理引导参数"><a href="#内核如何处理引导参数" class="headerlink" title="内核如何处理引导参数"></a>内核如何处理引导参数</h3><p>绝大部分的内核引导参数的格式如下(每个参数的值列表中最多只能有十项)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name[=value_1][,value_2]...[,value_10]</div></pre></td></tr></table></figure></p>
<p>如果”<code>name</code>“不能被识别并且满足”<code>name=value</code>“的格式，那么将被解译为一个环境变量(比如”<code>TERM=linux</code>“或”<code>BOOT_IMAGE=vmlinuz.bak</code>“)，否则将被原封不动的传递给<code>init</code>程序(比如”single”)。</p>
<p>内核可以接受的参数个数没有限制，但是整个命令行的总长度(参数/值/空格全部包含在内)却是有限制的，定义在 include/asm/setup.h 中的 <code>COMMAND_LINE_SIZE</code> 宏中(对于X86_64而言是2048)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二分法与printk()]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/binary-search-and-printk/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/fudan_abc/article/details/5543647" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（21）——二分法与printk() </a></p>
<p>人生就是一个茶几，上面摆满了杯具。内核也是一个大茶几，不过它上面的杯具是一个个的bug。确定bug什么时候被引入是一个很关键的步骤，在这个定位bug的过程中，不论有意或无意，都会很自然地用到二分查找的方法。<br><a id="more"></a></p>
<h2 id="二分查找法的基本原理"><a href="#二分查找法的基本原理" class="headerlink" title="二分查找法的基本原理"></a>二分查找法的基本原理</h2><p>对于二分查找法，我们不会也不应该会感到陌生。作为一种高效的查找算法，它曾出现在我们的数据结构课堂里，出现在一次又一次的面试里，更是会频繁地应用在我们的代码里。在我们所接触到的各种算法里，它可以说是最为大众化、最充满生活智慧的一个，很多人并不知道二分查找法的概念，却能够在生活中熟练的去应用。</p>
<p>比如，一个工人要维修一条10km长的电话线，首先他需要定位出故障所在，如果沿着线路一小段一小段地查找，显然非常得困难，每查一个点都要爬一次电线杆，10km长的距离会有大约200多根电线杆。假设电线两端分别为A、B，这时他会很自然地首先从中间的C开始查起，用话机向两端测试时，发现AC段正常，故而断定故障在BC段，再到BC段的中点D，如果发现BD段正常，则故障在CD段，然后再到CD的中间点E查找，这样每查一次，就可以把待查线路的长度缩减一半，因而经过7次查找，就可以将故障发生的范围缩小到50～100m左右，即在一两根电线杆附近。如此一来要节省很多的精力与时间。</p>
<p>这是二分查找法在生活中的一个典型应用，实际上，查找内核的bug与查找电话线的故障相比，本质上都是相同的，并没有高深到哪里去，都是首先要定位出故障的位置，然后去解决它。</p>
<p>比如你在使用某个版本的内核时，发现了一个内核bug，这时你需要知道它究竟是在应用哪个补丁时被引入的，如果一个一个的去还原那些补丁，每还原一个补丁就要测试一次内核，那么必然会浪费过多的时间，而应用二分查找法，首先确定一个肯定没有出现该bug的内核版本，然后去测试位于这两个版本中间的那个版本，这样重复筛选，就能够很容易的定位出是从哪个版本开始出现了这个bug。</p>
<h2 id="printk"><a href="#printk" class="headerlink" title="printk()"></a>printk()</h2><p>printk()应该是每一个驱动开发者最为亲密的伙伴了，我们常常将它与二分查找法结合在一起寻找代码中发生问题的位置。</p>
<p>通常情况下，对于代码中的两个printk()语句，如果一个正常执行，而另一个没有被执行，就说明问题发生在这两个printk()之间，接下来就可以在这个范围内应用二分查找法定位有问题的代码。</p>
<h3 id="printk-与printf"><a href="#printk-与printf" class="headerlink" title="printk()与printf()"></a>printk()与printf()</h3><p>用户空间有printf()，内核空间有printk()，它们就如代表善与恶的命运双生子，即使长相功能如何的接近，都不能在代码中共存。</p>
<p>对于我们来说，最容易犯的错误是，在需要printk()的地方误用了printf()，而在需要printf()的地方却又误用了printk()，通常这都不会是因为不知道它们的区别，而只是习惯使然。民间流传有这样的说法：当你在编写用户空间应用程序的时候，下意识写出的都是printk()，那么就说明你是个标准的内核开发者了。</p>
<h3 id="printk-的消息级别"><a href="#printk-的消息级别" class="headerlink" title="printk()的消息级别"></a>printk()的消息级别</h3><p>printk()与printf()的一个重要区别就是前者可以指定消息的打印级别，内核根据这个指定的级别来决定是否将消息打印到终端上。如下表所示，printk()共有8个级别。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>KERN_EMERG</td>
<td>紧急情况，系统可能会崩溃</td>
</tr>
<tr>
<td>KERN_ALERT</td>
<td>必须立即响应</td>
</tr>
<tr>
<td>KERN_CRIT</td>
<td>临界情况</td>
</tr>
<tr>
<td>KERN_ERR</td>
<td>错误信息</td>
</tr>
<tr>
<td>KERN_WARNING</td>
<td>警告信息</td>
</tr>
<tr>
<td>KERN_NOTICE</td>
<td>普通的但可能需要注意的信息</td>
</tr>
<tr>
<td>KERN_INFO</td>
<td>提示性信息</td>
</tr>
<tr>
<td>KERN_DEBUG</td>
<td>调试信息</td>
</tr>
</tbody>
</table>
<p>如果没有指定消息的级别，printk()会使用默认的DEFAULT_MESSAGE_LOGLEVEL（通常是KERN_WARNING）。</p>
<h3 id="控制台的日志级别（console-loglevel）"><a href="#控制台的日志级别（console-loglevel）" class="headerlink" title="控制台的日志级别（console_loglevel）"></a>控制台的日志级别（console_loglevel）</h3><p>当printk指定的消息级别小于指定的控制台日志级别时，消息的内容就会显示在该控制台上。控制台的日志级别定义在include/linux/kernel.h文件中，默认为DEFAULT_CONSOLE_LOGLEVEL（值等于7），也就是说默认情况下，比KERN_DEBUG级别高的printk()消息内容都可以在控制台上显示。</p>
<p>我们可以执行下面的命令使任何级别的printk()消息都被打印在终端上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> 8 &gt; /proc/sys/kernel/printk</div></pre></td></tr></table></figure></p>
<h3 id="printk-的变体"><a href="#printk-的变体" class="headerlink" title="printk()的变体"></a>printk()的变体</h3><p>内核在include/linux/kernel.h文件中提供了两个printk()的变体pr_debug和pr_info，它们的定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></div><div class="line"><span class="comment">/* If you are writing a driver, please use dev_dbg instead */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_debug(fmt,arg...) \</span></div><div class="line">        printk(KERN_DEBUG fmt,##arg)</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __attribute__ ((format (<span class="built_in">printf</span>, <span class="number">1</span>, <span class="number">2</span>))) pr_debug(<span class="keyword">const</span> <span class="keyword">char</span> * fmt, ...)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_info(fmt,arg...) \</span></div><div class="line">        printk(KERN_INFO fmt,##arg)</div></pre></td></tr></table></figure></p>
<h3 id="printk-不是万能的"><a href="#printk-不是万能的" class="headerlink" title="printk()不是万能的"></a>printk()不是万能的</h3><p>printk()虽然很好用，但它并不是万能的，在系统启动时，终端还没有初始化之前，它并不能被使用，不过如果不是在调试系统的启动过程的话，这并不能算是个问题。</p>
<p>其实内核提供了一个printk()的变体early_printk()，专门用于在系统启动的初期在终端上打印消息，它与printk()的区别仅仅在于名字的不同以及它能够更早地工作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[不稳定的内核API]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/unstable-kernel-api/</url>
      <content type="html"><![CDATA[<p>原文参考：<a href="http://blog.csdn.net/fudan_abc/article/details/5517845" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（19）——不稳定的内核API </a><br>linux内核文档：Documentation/stable_api_nonsense.txt</p>
<p>开源社区正以极快的速度向内核中添加新功能，同时又在努力让修补bug的步伐跟上去，放慢开发速度看上去是不太可能的：首先Linux不能在技术上落后，否则就会失去要求越来越苛刻的商业用户；其次是因为Linux需要推动开发者社区的发展，不断增加新功能可以使开发者不感到厌倦，否则他们就可能转移到其它项目，另外也能在现有开发者年老或退出的时候吸引新人才。</p>
<p>在这样的快节奏下，内核开发人员一旦在当前的接口中找到bug，或者更好的实现方式，他们就会很快的去修改当前的接口，这就意味着，函数名可能会改变，结构体可能被扩充或者删减，函数的参数也可能发生改变。一旦接口被修改，内核中使用这些接口的地方需要同时得到修正，这样才能保证所有的部分继续正常工作。<br><a id="more"></a><br>比如，内核中的USB接口到目前为止至少经历了三次重写，解决了下面的问题：</p>
<ul>
<li>把数据流从同步模式改成异步模式，这就减少了许多驱动程序的复杂度，提高了所有USB驱动程序的吞吐量（throughput），结果就是几乎所有的USB设备都能以最大速率工作了。</li>
<li>修改了从USB Core中分配数据包内存的方式，以至于为了修正许多死锁问题，所有驱动都必须提供更多的参数给USB Core代码<br>这和一些封闭源代码的操作系统形成鲜明的对比，在那些操作系统上，不得不额外的维护旧的USB接口。这就导致了一个可能性，新的开发者依然会不小心使用旧的接口，以不恰当的方式编写代码，进而影响到操作系统的稳定性。</li>
</ul>
<p>在上面的例子中，所有的开发者都同意这些改动是重要的不得不进行的，在这样的情况下修改代价很低。如果Linux保持一个稳定的内核接口，那么就不得不创建一个新的接口，同时旧的有问题的接口也必须一直维护，这就会给USB开发者带来额外的工作。既然所有的USB开发者都是利用自己的时间工作，那么要求他们去做这些毫无意义的免费的额外工作，是不可能的。</p>
<p>安全问题对Linux来说是十分重要的，一个安全问题被发现，就会在非常短的时间内得到修复。在很多情况下，这将导致内核中的一些接口被重写，以从根本上避免安全问题的发生。一旦内核接口被重写，所有使用这些接口的驱动程序，必须同时得到修正，以确定安全问题已经得到修复并且不可能在未来还有同样的安全问题。如果内核内部接口不允许改变，那么就不可能修复这样的安全问题，也不可能确认这样的安全问题以后不会发生。</p>
<p>开发者一直在清理内核接口。如果一个接口没有人在使用了，它就会被删除。这样可以确保内核尽可能的小，而且所有潜在的接口都会得到尽可能完整的测试（没有人使用的接口是不可能得到良好的测试的）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动开发三宝：spec、datasheet与内核源码]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/spec-datasheet-and-kernel-source/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/fudan_abc/article/details/5426161" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（13）——驱动开发三件宝：spec、datasheet与内核源码 </a></p>
<p>设备模型之外，对于驱动程序的开发者来说，有三样东西是不可缺少的：第一是协议或标准的spec，也就是规范，比如usb协议规范；第二是硬件的datasheet，即你的驱动要支持的硬件的手册；第三就是内核里类似驱动的源代码，比如你要写触摸屏驱动的话，就可以参考内核里已经有的一些触摸屏驱动。<br><a id="more"></a><br>spec、datasheet、内核源代码这三样东西对于每个开发设备驱动的人来说都是再寻常不过了，但正是因为它们的普通，所以在很多人眼里都被归为被忽视的群体。于是大家开发驱动的过程中，遇到问题的时候首先想到的可能还是“问问牛人怎么解决吧”、“旁边要是有个牛人该多好”，因为牛人的稀有，所以知道牛人的价值，而又因为spec、datasheet和内核源代码的唾手可得，所以常常体会不到它们在解决问题时的重要性。</p>
<p>当然我并不是贬低牛人的价值，宣扬依赖牛人不好，如果你很幸运身边真就有牛人这种稀缺资源的话，自然是要好好利用，也可以少走很多弯路，节省很多摸索的时间。只是人生不如意十之八九，多数人还是没有这份幸运的，所以与其遍寻牛人讨教，不如多依赖依赖自己，多利用利用自己身边有的资源去寻找解决问题的途径。</p>
<p>对这三样看似普通的东西，关键在于很好的去利用，而不是拥有。就说USB吧，USB驱动和USB设备如何进行交流，交流的方式，交流过程中出现了什么问题是什么引起的等等，都在USB spec里有描述，而你的USB设备支持多少种配置包含多少端点，只有设备的datasheet才知道。协议的spec和设备的datasheet是最好的参考资料，驱动开发调试中出现的问题绝大部分都能在它们的某个角落里找到答案。而内核中类似设备的驱动源代码是最好的模版，对很多硬件设备，你都可以在内核找到同种设备的驱动代码进行参考实现，甚至于可以拷贝或共享大部分的代码，只进行局部的修改，比如说位于drivers/input/touchscreen目录下的各个触摸屏驱动，它们之间的代码很多都是类似的甚至是相同的。</p>
<p>如果你不仅仅是打算写驱动，而是还想阅读内核中实现某种总线、设备的源代码，钻研它们的实现机制，那协议的spec就犹为重要，它们在代码里的体现无处不在，你需要在阅读代码前就对协议规范有个整体的理解。形象点说，spec是理论基础，内核代码是具体实现，理论懂了，看代码就和看故事会差不多了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux设备模型]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/linux-driver-model/</url>
      <content type="html"><![CDATA[<p>参考原文：<br><a href="http://blog.csdn.net/fudan_abc/article/details/5410486" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（11）——设备模型（上） </a><br><a href="http://blog.csdn.net/fudan_abc/article/details/5417879" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（12）——设备模型（下） </a></p>
<p>对于驱动开发来说，设备模型的理解是根本，毫不夸张得说，理解了设备模型，再去看那些五花八门的驱动程序，你会发现自己站在了另一个高度，从而有了一种俯视的感觉。<br>顾名而思义，设备模型是关于设备的模型，对咱们写驱动的和不写驱动的人来说，设备的概念就是总线和与其相连的各种设备。电脑城的IT工作者都会知道设备是通过总线连到计算机上的，而且还需要对应的驱动才能用，可是总线是如何发现设备的，设备又是如何和驱动对应起来的，它们经过怎样的艰辛才找到命里注定的那个他，它们的关系如何，白头偕老型的还是朝三暮四型的，这些问题就不是他们关心的了，而是咱们需要关心的。这些疑问的中心思想中心词汇就是总线、设备和驱动，没错，它们就是咱们这里要聊的Linux设备模型的名角。<br><a id="more"></a><br>总线、设备、驱动，也就是bus、device、driver，既然是名角，在内核里都会有它们自己专属的结构，在include/linux/device.h里定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bus_type &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>              * name;</div><div class="line">    <span class="keyword">struct</span> <span class="keyword">module</span>           * owner;</div><div class="line"></div><div class="line">     <span class="keyword">struct</span> kset             subsys;</div><div class="line">     <span class="keyword">struct</span> kset             drivers;</div><div class="line">     <span class="keyword">struct</span> kset             devices;</div><div class="line">     <span class="keyword">struct</span> klist            klist_devices;</div><div class="line">     <span class="keyword">struct</span> klist            klist_drivers;</div><div class="line"></div><div class="line">     <span class="keyword">struct</span> blocking_notifier_head bus_notifier;</div><div class="line"></div><div class="line">     <span class="keyword">struct</span> bus_attribute    * bus_attrs;</div><div class="line">     <span class="keyword">struct</span> device_attribute * dev_attrs;</div><div class="line">     <span class="keyword">struct</span> driver_attribute * drv_attrs;</div><div class="line">     <span class="keyword">struct</span> bus_attribute drivers_autoprobe_attr;</div><div class="line">     <span class="keyword">struct</span> bus_attribute drivers_probe_attr;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> (*match)(<span class="keyword">struct</span> device * dev, <span class="keyword">struct</span> device_driver * drv);</div><div class="line">     <span class="keyword">int</span> (*uevent)(<span class="keyword">struct</span> device *dev, <span class="keyword">char</span> **envp,</div><div class="line">     <span class="keyword">int</span> num_envp, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> buffer_size);</div><div class="line">     <span class="keyword">int</span>             (*probe)(<span class="keyword">struct</span> device * dev);</div><div class="line">     <span class="keyword">int</span>             (*remove)(<span class="keyword">struct</span> device * dev);</div><div class="line">     <span class="keyword">void</span>            (*shutdown)(<span class="keyword">struct</span> device * dev);</div><div class="line"></div><div class="line">     <span class="keyword">int</span> (*suspend)(<span class="keyword">struct</span> device * dev, <span class="keyword">pm_message_t</span> state);</div><div class="line">     <span class="keyword">int</span> (*suspend_late)(<span class="keyword">struct</span> device * dev, <span class="keyword">pm_message_t</span> state);</div><div class="line">     <span class="keyword">int</span> (*resume_early)(<span class="keyword">struct</span> device * dev);</div><div class="line">     <span class="keyword">int</span> (*resume)(<span class="keyword">struct</span> device * dev);</div><div class="line"></div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> drivers_autoprobe:<span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> device_driver &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>              * name;</div><div class="line">     <span class="keyword">struct</span> bus_type         * bus;</div><div class="line"></div><div class="line">     <span class="keyword">struct</span> kobject          kobj;</div><div class="line">     <span class="keyword">struct</span> klist            klist_devices;</div><div class="line">     <span class="keyword">struct</span> klist_node       knode_bus;</div><div class="line"></div><div class="line">     <span class="keyword">struct</span> <span class="keyword">module</span>           * owner;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span>              * mod_name;  <span class="comment">/* used for built-in modules */</span></div><div class="line">     <span class="keyword">struct</span> module_kobject   * mkobj;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>     (*probe)        (<span class="keyword">struct</span> device * dev);</div><div class="line">    <span class="keyword">int</span>     (*remove)       (<span class="keyword">struct</span> device * dev);</div><div class="line">    <span class="keyword">void</span>    (*shutdown)     (<span class="keyword">struct</span> device * dev);</div><div class="line">    <span class="keyword">int</span>     (*suspend)      (<span class="keyword">struct</span> device * dev, <span class="keyword">pm_message_t</span> state);</div><div class="line">    <span class="keyword">int</span>     (*resume)       (<span class="keyword">struct</span> device * dev);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> device &#123;</div><div class="line">  <span class="keyword">struct</span> klist  klist_children;</div><div class="line">  <span class="keyword">struct</span> klist_node knode_parent;  <span class="comment">/* node in sibling list */</span></div><div class="line">  <span class="keyword">struct</span> klist_node knode_driver;</div><div class="line">  <span class="keyword">struct</span> klist_node knode_bus;</div><div class="line">  <span class="keyword">struct</span> device  *parent;</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> kobject kobj;</div><div class="line">  <span class="keyword">char</span> bus_id[BUS_ID_SIZE]; <span class="comment">/* position on parent bus */</span></div><div class="line">  <span class="keyword">struct</span> device_type *type;</div><div class="line">  <span class="keyword">unsigned</span>  is_registered:<span class="number">1</span>;</div><div class="line">  <span class="keyword">unsigned</span>  uevent_suppress:<span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> semaphore sem; <span class="comment">/* semaphore to synchronize calls to</span></div><div class="line">        * its driver.</div><div class="line">        */</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> bus_type * bus;  <span class="comment">/* type of bus device is on */</span></div><div class="line">  <span class="keyword">struct</span> device_driver *driver; <span class="comment">/* which driver has allocated this</span></div><div class="line">         device */</div><div class="line">  <span class="keyword">void</span>  *driver_data; <span class="comment">/* data private to the driver */</span></div><div class="line">  <span class="keyword">void</span>  *platform_data; <span class="comment">/* Platform specific data, device</span></div><div class="line">         core doesn't touch it */</div><div class="line">  <span class="keyword">struct</span> dev_pm_info power;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></div><div class="line">  <span class="keyword">int</span>  numa_node; <span class="comment">/* NUMA node this device is close to */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  u64  *dma_mask; <span class="comment">/* dma mask (if dma'able device) */</span></div><div class="line">  u64  coherent_dma_mask;<span class="comment">/* Like dma_mask, but for</span></div><div class="line">           alloc_coherent mappings as</div><div class="line">           not all hardware supports</div><div class="line">           64 bit addresses for consistent</div><div class="line">           allocations such descriptors. */</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> list_head dma_pools; <span class="comment">/* dma pools (if dma'ble) */</span></div><div class="line"></div><div class="line">  <span class="keyword">struct</span> dma_coherent_mem *dma_mem; <span class="comment">/* internal for coherent mem</span></div><div class="line">           override */</div><div class="line">  <span class="comment">/* arch specific additions */</span></div><div class="line">  <span class="keyword">struct</span> dev_archdata archdata;</div><div class="line"></div><div class="line">  <span class="keyword">spinlock_t</span>  devres_lock;</div><div class="line">  <span class="keyword">struct</span> list_head devres_head;</div><div class="line"></div><div class="line">  <span class="comment">/* class_device migration path */</span></div><div class="line">  <span class="keyword">struct</span> list_head node;</div><div class="line">  <span class="keyword">struct</span> <span class="keyword">class</span>  *<span class="keyword">class</span>;</div><div class="line">  <span class="keyword">dev_t</span>   devt;  <span class="comment">/* dev_t, creates the sysfs "dev" */</span></div><div class="line">  <span class="keyword">struct</span> attribute_group **groups; <span class="comment">/* optional groups */</span></div><div class="line"></div><div class="line">  <span class="keyword">void</span> (*release)(<span class="keyword">struct</span> device * dev);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我知道进入了21世纪，最缺的就是耐性，房价股价都让咱们没有耐性，内核的代码也让人没有耐性。不过做为最没有耐性的一代人，还是要平心静气的扫一下上面的结构，我们会发现，<code>struct bus_type</code>中有成员<code>struct kset drivers</code>和<code>struct kset devices</code>，同时<code>struct device</code>中有两个成员<code>struct bus_type * bus</code>和<code>struct device_driver *driver</code>，<code>struct device_driver</code>中有两个成员<code>struct bus_type * bus</code>和<code>struct klist klist_devices</code>。先不说什么是<code>klist</code>、<code>kset</code>，光从成员的名字看，它们就是一个完美的三角关系。我们每个人心中是不是都有两个她？一个梦中的她，一个现实中的她。</p>
<p>凭一个男人的直觉，我们可以知道，<code>struct device</code>中的<code>bus</code>表示这个设备连到哪个总线上，<code>driver</code>表示这个设备的驱动是什么，<code>struct device_driver</code>中的<code>bus</code>表示这个驱动属于哪个总线，<code>klist_devices</code>表示这个驱动都支持哪些设备，因为这里<code>device</code>是复数，又是<code>list</code>，更因为一个驱动可以支持多个设备，而一个设备只能绑定一个驱动。当然，<code>struct
bus_type</code>中的<code>drivers</code>和<code>devices</code>分别表示了这个总线拥有哪些设备和哪些驱动。</p>
<p>单凭直觉，张钰红不了。我们还需要看看什么是<code>klist</code>、<code>kset</code>。还有上面<code>device</code>和<code>driver</code>结构里出现的<code>kobject</code>结构是什么？作为一个五星红旗下长大的孩子，我可以肯定的告诉你，<code>kobject</code>和<code>kset</code>都是Linux设备模型中最基本的元素，总线、设备、驱动是西瓜，<code>kobjcet</code>、<code>kset</code>是种瓜的人，没有幕后种瓜人的汗水不会有清爽解渴的西瓜，我们不能光知道西瓜的的甜，还要知道种瓜人的辛苦。<code>kobject</code>和<code>kset</code>不会在意自己的得失，它们存在的意义在于把总线、设备和驱动这样的对象连接到设备模型上。种瓜的人也不会在意自己的汗水，在意的只是能不能送出甜蜜的西瓜。</p>
<p>一般来说应该这么理解，整个Linux的设备模型是一个OO的体系结构，总线、设备和驱动都是其中鲜活存在的对象，<code>kobject</code>是它们的基类，所实现的只是一些公共的接口，<code>kset</code>是同种类型<code>kobject</code>对象的集合，也可以说是对象的容器。只是因为C里不可能会有C++里类的class继承、组合等的概念，只有通过<code>kobject</code>嵌入到对象结构里来实现。这样，内核使用<code>kobject</code>将各个对象连接起来组成了一个分层的结构体系，就好像马列主义将我们13亿人也连接成了一个分层的社会体系一样。<code>kobject</code>结构里包含了<code>parent</code>成员，指向了另一个<code>kobject</code>结构，也就是这个分层结构的上一层结点。而<code>kset</code>是通过链表来实现的，这样就可以明白，<code>struct bus_type</code>结构中的成员<code>drivers</code>和<code>devices</code>表示了一条总线拥有两条链表，一条是设备链表，一条是驱动链表。我们知道了总线对应的数据结构，就可以找到这条总线关联了多少设备，又有哪些驱动来支持这类设备。</p>
<p>那么<code>klist</code>呢？其实它就包含了一个链表和一个自旋锁，我们暂且把它看成链表也无妨，本来在2.6.11内核里，<code>struct device_driver</code>结构的<code>devices</code>成员就是一个链表类型。这么一说，咱们上面的直觉都是正确的，如果买股票，摸彩票时直觉都这么管用，就不会有咱们这被压扁的一代了。</p>
<p>现在的人都知道，三角关系很难处。那么总线、设备和驱动之间是如何和谐共处那？先说说总线中的那两条链表是怎么形成的。内核要求每次出现一个设备就要向总线汇报，或者说注册，每次出现一个驱动，也要向总线汇报，或者说注册。比如系统初始化的时候，会扫描连接了哪些设备，并为每一个设备建立起一个<code>struct device</code>的变量，每一次有一个驱动程序，就要准备一个<code>struct device_driver</code>结构的变量。把这些变量统统加入相应的链表，<code>device</code>插入<code>devices</code>链表，<code>driver</code>插入<code>drivers</code>链表。这样通过总线就能找到每一个设备，每一个驱动。然而，假如计算机里只有设备却没有对应的驱动，那么设备无法工作。反过来，倘若只有驱动却没有设备，驱动也起不了任何作用。在他们遇见彼此之前，双方都如同路埂的野草，一个飘啊飘，一个摇啊摇，谁也不知道未来在哪里，只能在生命的风里飘摇。于是总线上的两张表里慢慢的就挂上了那许多孤单的灵魂。<code>devices</code>开始多了，<code>drivers</code>开始多了，他们像是来自两个世界，<code>devices</code>们彼此取暖，<code>drivers</code>们一起狂欢，但他们有一点是相同的，都只是在等待属于自己的那个另一半。</p>
<p>现在，总线上的两条链表已经有了，这个三角关系三个边已经有了两个，剩下的那个呢？链表里的设备和驱动又是如何联系呢？先有设备还是先有驱动？很久很久以前，在那激情燃烧的岁月里，先有的是设备，每一个要用的设备在计算机启动之前就已经插好了，插放在它应该在的位置上，然后计算机启动，然后操作系统开始初始化，总线开始扫描设备，每找到一个设备，就为其申请一个<code>struct device</code>结构，并且挂入总线中的<code>devices</code>链表中来，然后每一个驱动程序开始初始化，开始注册其<code>struct device_driver</code>结构，然后它去总线的<code>devices</code>链表中去寻找(遍历)，去寻找每一个还没有绑定驱动的设备，即<code>struct device</code>中的<code>struct device_driver</code>指针仍为空的设备，然后它会去观察这种设备的特征，看是否是他所支持的设备，如果是，那么调用一个叫做<code>device_bind_driver</code>的函数，然后他们就结为了秦晋之好。换句话说，把<code>struct device</code>中的<code>struct device_driver driver</code>指向这个驱动，而<code>struct device_driver driver</code>把<code>struct device</code>加入他的那张<code>struct klist klist_devices</code>链表中来。就这样，<code>bus</code>、<code>device</code>和<code>driver</code>，这三者之间或者说他们中的两两之间，就给联系上了。知道其中之一，就能找到另外两个。一荣俱荣，一损俱损。</p>
<p>但现在情况变了，在这红莲绽放的日子里，在这樱花伤逝的日子里，出现了一种新的名词，叫热插拔。设备可以在计算机启动以后在插入或者拔出计算机了。因此，很难再说是先有设备还是先有驱动了。因为都有可能。设备可以在任何时刻出现，而驱动也可以在任何时刻被加载，所以，出现的情况就是，每当一个<code>struct device</code>诞生，它就会去<code>bus</code>的<code>drivers</code>链表中寻找自己的另一半，反之，每当一个<code>struct device_driver</code>诞生，它就去<code>bus</code>的<code>devices</code>链表中寻找它的那些设备。如果找到了合适的，那么OK，和之前那种情况一样，调用<code>device_bind_driver</code>绑定好。如果找不到，没有关系，等待吧，等到昙花再开，等到风景看透，心中相信，这世界上总有一个人是你所等的，只是还没有遇到而已。</p>
<p>设备模型拍得再玄幻，它也只是个模型，必须得落实在具体的子系统，否则就只能抱着个最佳技术奖空遗恨。既然前面已经以USB子系统的实现分析示例了分析内核源码应该如何入手，那么这里就仍然以USB子系统为例，看看设备模型是如何软着陆的。</p>
<h2 id="内核中USB子系统的结构"><a href="#内核中USB子系统的结构" class="headerlink" title="内核中USB子系统的结构"></a>内核中USB子系统的结构</h2><p>我们已经知道了USB子系统的代码都位于drivers/usb目录下面，也认识了一个很重要的目录——core子目录。现在，我们再来看一个很重要的模块 —— usbcore。</p>
<p>core就是核心，基本上你要在你的电脑里用USB设备，那么两个模块是必须的：一个是usbcore，这就是核心模块；另一个是主机控制器的驱动程序，比如ehci_hcd和uhci_hcd。你的USB设备要工作，合适的USB主机控制器模块也是必不可少的。</p>
<p>usbcore负责实现一些核心的功能，为别的设备驱动程序提供服务，提供一个用于访问和控制USB硬件的接口，而不用去考虑系统当前存在哪种主机控制器。至于core、主机控制器和USB驱动三者之间的关系，如下图所示。</p>
<img src="/kernel/内核修炼之道/linux-driver-model/usb_subsystem.png" alt="usb_subsystem.png" title="">
<p>USB驱动和主机控制器就像core的两个保镖，协议里也说了，主机控制器的驱动（HCD）必须位于USB软件的最下一层。HCD提供主机控制器硬件的抽象，隐藏硬件的细节，在主机控制器之下是物理的USB及所有与之连接的USB设备。而HCD只有一个客户，对一个人负责，就是usbcore。usbcore将用户的请求映射到相关的HCD，用户不能直接访问HCD。</p>
<p>core为咱们完成了大部分的工作，因此咱们写USB驱动的时候，只能调用core的接口，core会将咱们的请求发送给相应的HCD。</p>
<h2 id="USB子系统与设备模型"><a href="#USB子系统与设备模型" class="headerlink" title="USB子系统与设备模型"></a>USB子系统与设备模型</h2><p>关于设备模型，最主要的问题就是，bus、device、driver是如何建立联系的？换言之，这三个数据结构中的指针是如何被赋值的？绝对不可能发生的事情是，一旦为一条总线申请了一个<code>struct bus_type</code>的数据结构之后，它就知道它的<code>devices</code>链表和<code>drivers</code>链表会包含哪些东西，这些东西一定不会是先天就有的，只能是后天填进来的。</p>
<p>具体到USB子系统，完成这个工作的就是USB core。USB core的代码会进行整个USB系统的初始化，比如申请<code>struct bus_type usb_bus_type</code>，然后会扫描USB总线，看线上连接了哪些USB设备，或者说Root Hub上连了哪些USB设备，比如说连了一个USB键盘，那么就为它准备一个<code>struct device</code>，根据它的实际情况，为这个<code>struct device</code>赋值，并插入<code>devices</code>链表中来。</p>
<p>又比如Root Hub上连了一个普通的Hub，那么除了要为这个Hub本身准备一个<code>struct device</code>以外，还得继续扫描看这个Hub上是否又连了别的设备，有的话继续重复之前的事情，这样一直进行下去，直到完成整个扫描，最终就把<code>usb_bus_type</code>中的<code>devices</code>链表给建立了起来。</p>
<p>那么<code>drivers</code>链表呢？这个就不用bus方面主动了，而该由每一个driver本身去bus上面登记，或者说挂牌。具体到USB子系统，每一个USB设备的驱动程序都会对应一个<code>struct usb_driver</code>结构，其中有一个<code>struct device_driver driver</code>成员，USB core为每一个设备驱动准备了一个函数，让它把自己的这个<code>struct device_driver driver</code>插入到<code>usb_bus_type</code>中的<code>drivers</code>链表中去。而这个函数正是我们此前看到的<code>usb_registeri</code>。而与之对应的<code>usb_deregister</code>所从事的正是与之相反的工作，把这个结构体从<code>drivers</code>链表中删除。</p>
<p>而<code>struct bus_type</code>结构的match函数在USB子系统里就是<code>usb_device_match</code>函数，它充当了一个红娘的角色，在USB总线的USB设备和USB驱动之间牵线搭桥，类似于交大BBS上的鹊桥版，虽然它们上面的条件都琳琅满目的，但明显这里match的条件不是那么的苛刻，要更为实际些。</p>
<p>可以说，USB core的确是用心良苦，为每一个USB设备驱动做足了功课，正因为如此，作为一个实际的USB设备驱动，它在初始化阶段所要做的事情就很少、很简单了，直接调用<code>usb_register</code>即可。事实上，没有人是理所当然应该为你做什么的，但USB core这么做了。所以每一个写USB设备驱动的人应该铭记，USB设备驱动绝不是一个人在工作，在他身后，是USB core所提供的默默无闻又不可或缺的支持。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分析内核源码如何入手（下）]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/how-to-analysis-kernel-source-2/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/fudan_abc/article/details/5355062" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（7）——分析内核源码如何入手？（下） </a></p>
<h2 id="从初始化函数开始"><a href="#从初始化函数开始" class="headerlink" title="从初始化函数开始"></a>从初始化函数开始</h2><p>有了地图Kconfig和Makefile，我们可以在庞大复杂的内核代码中定位以及缩小了目标代码的范围。那么现在，为了研究内核对USB子系统的实现，我们还需要在目标代码中找到一个突破口，这个突破口就是USB子系统的初始化代码。<br><a id="more"></a><br>针对某个子系统或某个驱动，内核使用<code>subsys_initcall</code>或<code>module_init</code>宏指定初始化函数。在drivers/usb/core/usb.c文件中，我们可以发现下面的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subsys_initcall(usb_init);</div><div class="line">module_exit(usb_exit);</div></pre></td></tr></table></figure></p>
<p>我们看到一个<code>subsys_initcall</code>，它也是一个宏，我们可以把它理解为<code>module_init</code>，只不过因为这部分代码比较核心，开发者们把它看作一个子系统，而不仅仅是一个模块。这也很好理解，usbcore这个模块它代表的不是某一个设备，而是所有USB设备赖以生存的模块，Linux中，像这样一个类别的设备驱动被归结为一个子系统。比如PCI子系统，比如SCSI子系统，基本上，drivers/目录下面第一层的每个目录都算一个子系统，因为它们代表了一类设备。</p>
<p><code>subsys_initcall(usb_init)</code>的意思就是告诉我们<code>usb_init</code>是USB子系统真正的初始化函数，而<code>usb_exit()</code>将是整个USB子系统的结束时的清理函数。于是为了研究USB子系统在内核中的实现，我们需要从<code>usb_init</code>函数开始看起。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">usb_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> retval;</div><div class="line">    <span class="keyword">if</span> (nousb) &#123;</div><div class="line">        pr_info(<span class="string">"%s: USB support disabled/n"</span>, usbcore_name);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    retval = ksuspend_usb_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line">    retval = bus_register(&amp;usb_bus_type);</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> bus_register_failed;</div><div class="line">    retval = usb_host_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> host_init_failed;</div><div class="line">    retval = usb_major_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> major_init_failed;</div><div class="line">    retval = usb_register(&amp;usbfs_driver);</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> driver_register_failed;</div><div class="line">    retval = usb_devio_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> usb_devio_init_failed;</div><div class="line">    retval = usbfs_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> fs_init_failed;</div><div class="line">    retval = usb_hub_init();</div><div class="line">    <span class="keyword">if</span> (retval)</div><div class="line">        <span class="keyword">goto</span> hub_init_failed;</div><div class="line">    retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</div><div class="line">    <span class="keyword">if</span> (!retval)</div><div class="line">        <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    usb_hub_cleanup();</div><div class="line">hub_init_failed:</div><div class="line">    usbfs_cleanup();</div><div class="line">fs_init_failed:</div><div class="line">    usb_devio_cleanup();</div><div class="line">usb_devio_init_failed:</div><div class="line">    usb_deregister(&amp;usbfs_driver);</div><div class="line">driver_register_failed:</div><div class="line">    usb_major_cleanup();</div><div class="line">major_init_failed:</div><div class="line">    usb_host_cleanup();</div><div class="line">host_init_failed:</div><div class="line">    bus_unregister(&amp;usb_bus_type);</div><div class="line">bus_register_failed:</div><div class="line">    ksuspend_usb_cleanup();</div><div class="line">out:</div><div class="line">    <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="init标记"><a href="#init标记" class="headerlink" title="__init标记"></a>__init标记</h3><p>关于<code>usb_init</code>，第一个问题是，<code>__init</code>标记具有什么意义？</p>
<p>写过驱动的应该不会陌生，它对内核来说就是一种暗示，表明这个函数仅在初始化期间使用，在模块被装载之后，它占用的资源就会释放掉用作它处。它的暗示你懂，可你的暗示，她却不懂或者懂装不懂，多么让人感伤。它在自己短暂的一生中一直从事繁重的工作，吃的是草吐出的是牛奶，留下的是整个USB子系统的繁荣。</p>
<p>受这种精神所感染，我觉得有必要为它说的更多些。<code>__init</code>的定义在include/linux/init.h文件里<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __init    __attribute__ ((__section__ (<span class="meta-string">".init.text"</span>)))</span></div></pre></td></tr></table></figure></p>
<p>好像这里引出了更多的疑问，<code>__attribute__</code>是什么？Linux内核代码使用了大量的GNU C扩展，以至于GNU C成为能够编译内核的唯一编译器，GNU C的这些扩展对代码优化、目标代码布局、安全检查等方面也提供了很强的支持。而<code>__attribute__</code>就是这些扩展中的一个，它主要被用来声明一些特殊的属性，这些属性主要被用来指示编译器进行特定方面的优化和更仔细的代码检查。GNU C支持十几个属性，<code>section</code>是其中的一个，我们查看GCC的手册可以看到下面的描述：</p>
<blockquote>
<p>‘section (“section-name”)’</p>
<p>　　 Normally, the compiler places the code it generates in the `text’</p>
<p>　　 section.　Sometimes, however, you need additional sections, or you</p>
<p>　　 need certain particular functions to appear in special sections.</p>
<p>　　 The `section’ attribute specifies that a function lives in a</p>
<p>　　 particular section.　For example, the declaration:</p>
<p>　　　　　extern void foobar (void) <strong>attribute</strong> ((section (“bar”)));</p>
<p>　　 puts the function ‘foobar’ in the ‘bar’ section.</p>
<p>　　 Some file formats do not support arbitrary sections so the</p>
<p>　　 ‘section’ attribute is not available on all platforms.　If you</p>
<p>　　 need to map the entire contents of a module to a particular</p>
<p>　　 section, consider using the facilities of the linker instead.<br>通常编译器将函数放在<code>.text</code>节，变量放在<code>.data</code>或<code>.bss</code>节，使用<code>section</code>属性，可以让编译器将函数或变量放在指定的节中。那么前面对<code>__init</code>的定义便表示将它修饰的代码放在<code>.init.text</code>节。链接器可以把相同节的代码或数据安排在一起，比如<code>__init</code>修饰的所有代码都会被放在<code>.init.text</code>节里，初始化结束后就可以释放这部分内存。</p>
</blockquote>
<p>问题可以到此为止，也可以更深入，即<span style="color:red;">内核又是如何调用到这些<code>__init</code>修饰的初始化函数？</span>要回答这个问题，还需要回顾一下<code>subsys_initcall</code>宏，它也在include/linux/init.h里定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn)    __define_initcall(<span class="meta-string">"4"</span>,fn,4)</span></div></pre></td></tr></table></figure></p>
<p>这里又出现了一个宏<code>__define_initcall</code>，它用于将指定的函数指针<code>fn</code>放到<code>.initcall.init</code>节里 而对于具体的<code>subsys_initcall</code>宏，则是把<code>fn</code>放到<code>.initcall.init</code>的子节<code>.initcall4.init</code>里。要弄清楚<code>.initcall.init</code>、<code>.init.text</code>和<code>.initcall4.init</code>这样的东东，我们还需要了解一点内核可执行文件相关的概念。</p>
<p>内核可执行文件由许多链接在一起的对象文件组成。对象文件有许多节，如文本、数据、init数据、bss等等。这些对象文件都是由一个称为链接器脚本的文件链接并装入的。这个链接器脚本的功能是将输入对象文件的各节映射到输出文件中；换句话说，它将所有输入对象文件都链接到单一的可执行文件中，将该可执行文件的各节装入到指定地址处。vmlinux.lds是存在于arch/&lt;target&gt;/ 目录中的内核链接器脚本，它负责链接内核的各个节并将它们装入内存中特定偏移量处。</p>
<p>我可以负责任的告诉你，要看懂vmlinux.lds这个文件是需要一番功夫的，不过大家都是聪明人，聪明人做聪明事，所以你需要做的只是搜索initcall.init，然后便会看到似曾相识的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__inicall_start = .;</div><div class="line">.initcall.init : AT(ADDR(.initcall.init) – 0xC0000000) &#123;</div><div class="line">*(.initcall1.init)</div><div class="line">*(.initcall2.init)</div><div class="line">*(.initcall3.init)</div><div class="line">*(.initcall4.init)</div><div class="line">*(.initcall5.init)</div><div class="line">*(.initcall6.init)</div><div class="line">*(.initcall7.init)</div><div class="line">&#125;</div><div class="line">__initcall_end = .;</div></pre></td></tr></table></figure></p>
<p>这里的<code>__initcall_start</code>指向<code>.initcall.init</code>节的开始，<code>__initcall_end</code>指向它的结尾。而<code>.initcall.init</code>节又被分为了7个子节，分别是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.initcall1.init</div><div class="line">.initcall2.init</div><div class="line">.initcall3.init</div><div class="line">.initcall4.init</div><div class="line">.initcall5.init</div><div class="line">.initcall6.init</div><div class="line">.initcall7.init</div></pre></td></tr></table></figure></p>
<p>我们的<code>subsys_initcall</code>宏便是将指定的函数指针放在了<code>.initcall4.init</code>子节。其它的比如<code>core_initcall</code>将函数指针放在<code>.initcall1.init</code>子节，<code>device_initcall</code>将函数指针放在了<code>.initcall6.init</code>子节等等，都可以从include/linux/init.h文件找到它们的定义。<span style="color:red;">各个子节的顺序是确定的，即先调用<code>.initcall1.init</code>中的函数指针，再调用<code>.initcall2.init</code>中的函数指针，等等。<code>__init</code>修饰的初始化函数在内核初始化过程中调用的顺序和<code>.initcall.init</code>节里函数指针的顺序有关，不同的初始化函数被放在不同的子节中，因此也就决定了它们的调用顺序。</span></p>
<p>至于实际执行函数调用的地方，就在/init/main.c文件里，内核的初始化么，不在那里还能在哪里，里面的<code>do_initcalls</code>函数会直接用到这里的<code>__initcall_start</code>、<code>__initcall_end</code>来进行判断。</p>
<p>相关宏定义(include/linux/init.h)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* initcalls are now grouped by functionality into separate</span></div><div class="line"> * subsections. Ordering inside the subsections is determined</div><div class="line"> * by link order.</div><div class="line"> * For backwards compatibility, initcall() puts the call in</div><div class="line"> * the device init subsection.</div><div class="line"> *</div><div class="line"> * The `id' arg to __define_initcall() is needed so that multiple initcalls</div><div class="line"> * can point at the same handler without causing duplicate-symbol build errors.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __define_initcall(level,fn,id) \</span></div><div class="line">        static initcall_t __initcall_##fn##id __attribute_used__ \</div><div class="line">        __attribute__((__section__(<span class="meta-string">".initcall"</span> level <span class="meta-string">".init"</span>))) = fn</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * A "pure" initcall has no dependencies on anything else, and purely</div><div class="line"> * initializes variables that couldn't be statically initialized.</div><div class="line"> *</div><div class="line"> * This only exists for built-in code, not for modules.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn)               __define_initcall(<span class="meta-string">"0"</span>,fn,1)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn)               __define_initcall(<span class="meta-string">"1"</span>,fn,1)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn)          __define_initcall(<span class="meta-string">"1s"</span>,fn,1s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn)           __define_initcall(<span class="meta-string">"2"</span>,fn,2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn)      __define_initcall(<span class="meta-string">"2s"</span>,fn,2s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn)               __define_initcall(<span class="meta-string">"3"</span>,fn,3)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn)          __define_initcall(<span class="meta-string">"3s"</span>,fn,3s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn)             __define_initcall(<span class="meta-string">"4"</span>,fn,4)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn)        __define_initcall(<span class="meta-string">"4s"</span>,fn,4s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn)                 __define_initcall(<span class="meta-string">"5"</span>,fn,5)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn)            __define_initcall(<span class="meta-string">"5s"</span>,fn,5s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn)             __define_initcall(<span class="meta-string">"rootfs"</span>,fn,rootfs)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn)             __define_initcall(<span class="meta-string">"6"</span>,fn,6)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn)        __define_initcall(<span class="meta-string">"6s"</span>,fn,6s)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn)               __define_initcall(<span class="meta-string">"7"</span>,fn,7)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn)          __define_initcall(<span class="meta-string">"7s"</span>,fn,7s)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __initcall(fn) device_initcall(fn)</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * module_init() - driver initialization entry point</div><div class="line"> * @x: function to be run at kernel boot time or module insertion</div><div class="line"> *</div><div class="line"> * module_init() will either be called during do_initcalls() (if</div><div class="line"> * builtin) or at module insertion time (if a module).  There can only</div><div class="line"> * be one per module.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> module_init(x)  __initcall(x);</span></div></pre></td></tr></table></figure></p>
<h3 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h3><p>关于<code>usb_init</code>函数，第二个问题是，<code>nousb</code>表示什么？</p>
<p>知道C语言的人都会知道<code>nousb</code>是一个标志，只是不同的标志有不一样的精彩，这里的<code>nousb</code>是用来让我们在启动内核的时候通过内核参数去掉USB子系统的，Linux社会是一个很人性化的世界，它不会去逼迫我们接受USB，一切都只关乎我们自己的需要。不过我想我们一般来说是不会去指定<code>nousb</code>的吧。如果你真的指定了<code>nousb</code>，那它就只会幽怨的说一句“USB support disabled”，然后退出<code>usb_init</code>。</p>
<p>nousb在drivers/usb/core/usb.c文件中定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> nousb; <span class="comment">/* Disable USB when built into kernel image */</span></div><div class="line"><span class="comment">/* format to disable USB on kernel command line is: nousb */</span></div><div class="line">__module_param_call(<span class="string">""</span>, nousb, param_set_bool, param_get_bool, &amp;nousb, <span class="number">0444</span>);</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> usb_autosuspend_delay = <span class="number">2</span>;           <span class="comment">/* Default delay value, in seconds */</span></div><div class="line">module_param_named(autosuspend, usb_autosuspend_delay, uint, <span class="number">0644</span>);</div><div class="line">MODULE_PARM_DESC(autosuspend, <span class="string">"default autosuspend delay"</span>);</div></pre></td></tr></table></figure></p>
<p>从中可知<code>nousb</code>是个模块参数。关于模块参数，我们都知道可以在加载模块的时候可以指定，但是如何在内核启动的时候指定？<br>打开系统的grub文件，然后找到kernel行，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kernel  /boot/vmlinuz-2.6.18-kdb root=/dev/sda1 ro splash=silent vga=0x314</div></pre></td></tr></table></figure></p>
<p>其中的<code>ro</code>，<code>splash</code>，<code>vga</code>等都表示内核参数。当某一模块被编译进内核的时候，它的模块参数便需要在kernel行来指定，格式为“<span style="color:red;">模块名.参数=值</span>”，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">modprobe usbcore autosuspend=2</div></pre></td></tr></table></figure></p>
<p>对应到kernel行，即为 ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usbcore.autosuspend=2</div></pre></td></tr></table></figure></p>
<p>通过命令<code>modinfo -p ${modulename}</code>可以得知一个模块有哪些参数可以使用。同时，对于已经加载到内核里的模块，它们的模块参数会列举在<code>/sys/module/${modulename}/parameters/</code>目录下面，可以使用<code>echo -n ${value} &gt; /sys/module/${modulename}/parameters/${parm}</code>这样的命令去修改。</p>
<h3 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h3><p>关于<code>usb_init</code>函数，第三个问题是，<code>pr_info</code>如何实现与使用？</p>
<p><code>pr_info</code>只是一个打印信息的可辨参数宏，<code>printk</code>的变体，在include/linux/kernel.h里定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_info(fmt,arg...) /</span></div><div class="line">        printk(KERN_INFO fmt,##arg)</div></pre></td></tr></table></figure></p>
<p>99年的ISO C标准里规定了可变参数宏，和函数语法类似，比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(format, ...) fprintf (stderr, format, __VA_ARGS__)</span></div></pre></td></tr></table></figure></p>
<p>里面的“<code>…</code>”就表示可变参数，调用时，它们就会替代宏体里的<code>__VA_ARGS__</code>。GCC总是会显得特立独行一些，它支持更复杂的形式，可以给可变参数取个名字，比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(format, args...) fprintf (stderr, format, args)</span></div></pre></td></tr></table></figure></p>
<p>有了名字总是会容易交流一些。是不是与<code>pr_info</code>比较接近了？除了‘<code>##</code>’，它主要是针对空参数的情况。既然说是可变参数，那传递空参数也总是可以的，空即是多，多即是空，股市里的哲理这里同样也是适合的。如果没有‘<code>##</code>’，传递空参数的时候，比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">debug (<span class="string">"A message"</span>);</div></pre></td></tr></table></figure></p>
<p>展开后，里面的字符串后面会多个多余的逗号。这个逗号你应该不会喜欢，而‘<code>##</code>’则会使预处理器去掉这个多余的逗号。</p>
<p>关于<code>usb_init</code>函数，上面的三个问题之外，余下的代码分别完成usb各部分的初始化，接下来就需要围绕它们分别进行深入分析。这里只是演示如何入手分析，所以就不做深入分析了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分析内核源码如何入手（上）]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/how-to-analysis-kernel-source-1/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/fudan_abc/article/details/5347687" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（6）——分析内核源码如何入手？（上） </a></p>
<p>透过现象看本质，兽兽门无非就是一些人体艺术展示。同样往本质里看过去，学习内核，就是学习内核的源代码，任何内核有关的书籍都是基于内核，而又不高于内核的。</p>
<p>既然要学习内核源码，就要经常对内核代码进行分析，而内核代码千千万，还前仆后继的不断往里加，这就让大部分人都有种雾里看花花不见的无助感。不过不要怕，孔老夫子早就留给我们了应对之策：敏于事而慎于言，就有道而正焉，可谓好学也已。这就是说，做事要踏实才是好学生好同志，要遵循严谨的态度，去理解每一段代码的实现，多问多想多记。如果抱着走马观花，得过且过的态度，结果极有可能就是一边看一边丢，没有多大的收获<br><a id="more"></a><br>下面就以USB子系统的实现分析为标本看看分析内核源码应该如何入手。</p>
<h2 id="分析README"><a href="#分析README" class="headerlink" title="分析README"></a>分析README</h2><p>内核中USB子系统的代码位于目录drivers/usb，进入到该目录，执行命令ls，结果显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">atm  class  core  gadget  host  image  misc  mon  serial  storage Kconfig</div><div class="line">Makefile  README usb-skeleton.c</div></pre></td></tr></table></figure></p>
<p>目录drivers/usb共包含有10个子目录和4个文件，usb-skeleton.c是一个简单的USB driver的框架，感兴趣的可以去看看，目前来说，它还吸引不了我们的眼球。那么首先应该关注什么？如果迎面走来一个ppmm，你会首先看脸、脚还是其它？当然答案依据每个人的癖好会有所不同。不过这里的问题应该只有一个答案，那就是Kconfig、Makefile、README。</p>
<p>README里有关于这个目录下内容的一般性描述，它不是关键，只是帮助你了解。再说了，面对“read我吧read我吧”这么热情奔放的呼唤，善良的我们是不可能无动于衷的，所以先来看看里面都有些什么内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Here is a list of what each subdirectory here is, and what is contained in</div><div class="line">them.</div><div class="line"></div><div class="line">core/        - This is for the core USB host code, including the</div><div class="line">            usbfs files and the hub class driver (&quot;khubd&quot;).</div><div class="line"></div><div class="line">host/        - This is for USB host controller drivers.  This</div><div class="line">            includes UHCI, OHCI, EHCI, and others that might</div><div class="line">            be used with more specialized &quot;embedded&quot; systems.</div><div class="line"></div><div class="line">gadget/        - This is for USB peripheral controller drivers and</div><div class="line">            the various gadget drivers which talk to them.</div><div class="line"></div><div class="line"></div><div class="line">Individual USB driver directories.  A new driver should be added to the</div><div class="line">first subdirectory in the list below that it fits into.</div><div class="line"></div><div class="line">image/        - This is for still image drivers, like scanners or</div><div class="line">            digital cameras.</div><div class="line">input/        - This is for any driver that uses the input subsystem,</div><div class="line">            like keyboard, mice, touchscreens, tablets, etc.</div><div class="line">media/        - This is for multimedia drivers, like video cameras,</div><div class="line">            radios, and any other drivers that talk to the v4l</div><div class="line">            subsystem.</div><div class="line">net/        - This is for network drivers.</div><div class="line">serial/        - This is for USB to serial drivers.</div><div class="line">storage/    - This is for USB mass-storage drivers.</div><div class="line">class/        - This is for all USB device drivers that do not fit</div><div class="line">            into any of the above categories, and work for a range</div><div class="line">            of USB Class specified devices.</div><div class="line">misc/        - This is for all USB device drivers that do not fit</div><div class="line">            into any of the above categories.</div></pre></td></tr></table></figure></p>
<p>这个README文件描述了前边使用ls命令列出的那10个文件夹的用途。那么什么是USB Core？Linux内核开发者们，专门写了一些代码，负责实现一些核心的功能，为别的设备驱动程序提供服务，比如申请内存，比如实现一些所有的设备都会需要的公共的函数，并美其名曰USB Core。</p>
<p>时代总在发展，当年胖杨贵妃照样迷死唐明皇，而如今人们欣赏的则是林志玲这样的魔鬼身材。同样，早期的Linux内核，其结构并不是如今天这般有层次感，远不像今天这般错落有致，那时候drivers/usb/这个目录下边放了很多很多文件，USB Core与其他各种设备的驱动程序的代码都堆砌在这里，后来，怎奈世间万千的变幻，总爱把有情的人分两端。于是在drivers/usb/目录下面出来了一个core目录，就专门放一些核心的代码，比如初始化整个USB系统，初始化Root Hub，初始化主机控制器的代码，再后来甚至把主机控制器相关的代码也单独建了一个目录，叫host目录，这是因为USB主机控制器随着时代的发展，也开始有了好几种，不再像刚开始那样只有一种，所以呢，设计者们把一些主机控制器公共的代码仍然留在core目录下，而一些各主机控制器单独的代码则移到host目录下面让负责各种主机控制器的人去维护。</p>
<p>那么USB gadget那？gadget白了说就是配件的意思，主要就是一些内部运行Linux的嵌入式设备，比如PDA，设备本身有USB设备控制器（USB Device Controller），可以将PC，也就是我们的主机作为master端，将这样的设备作为slave端和主机通过USB进行通信。从主机的观点来看，主机系统的USB驱动程序控制插入其中的USB设备，而USB gadget的驱动程序控制外围设备如何作为一个USB设备和主机通信。比如，我们的嵌入式板子上支持SD卡，如果我们希望在将板子通过USB连接到PC之后，这个SD卡被模拟成U盘，那么就要通过USB gadget架构的驱动。</p>
<p>剩下的几个目录分门别类的放了各种USB设备的驱动，比如U盘的驱动在storage目录下，触摸屏和USB键盘鼠标的驱动在input目录下，等等。</p>
<p>我们响应了README的热情呼唤，它便给予了我们想要的，通过它我们了解了USB目录里的那些文件夹都有着什么样的角色。到现在为止，就只剩下内核的地图——Kconfig与Makefile两个文件了。有地图在手，对于在内核中游荡的我们来说，是件很愉悦的事情，不过，因为我们的目的是研究内核对USB子系统的实现，而不是特定设备或host controller的驱动，所以这里的定位很明显，USB Core就是我们需要关注的对象，那么接下来就是要对core目录中的内容进行定位了。</p>
<h2 id="分析Kconfig和Makefile"><a href="#分析Kconfig和Makefile" class="headerlink" title="分析Kconfig和Makefile"></a>分析Kconfig和Makefile</h2><p>进入到drivers/usb/core目录，执行命令ls，结果显示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Kconfig  Makefile  buffer.c  config.c  devices.c  devio.c  driver.c</div><div class="line">endpoint.c  file.c  generic.c  hcd-pci.c  hcd.c  hcd.h  hub.c  hub.h</div><div class="line">inode.c  message.c  notify.c  otg_whitelist.h  quirks.c  sysfs.c  urb.c</div><div class="line">usb.c  usb.h</div></pre></td></tr></table></figure></p>
<p>然后执行wc命令，如下所示。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># wc –l ./*</span></div><div class="line">   148 buffer.c</div><div class="line">   607 config.c</div><div class="line">   706 devices.c</div><div class="line">  1677 devio.c</div><div class="line">  1569 driver.c</div><div class="line">   357 endpoint.c</div><div class="line">   248 file.c</div><div class="line">   238 generic.c</div><div class="line">  1759 hcd.c</div><div class="line">   458 hcd.h</div><div class="line">   433 hcd-pci.c</div><div class="line">  3046 hub.c</div><div class="line">   195 hub.h</div><div class="line">   758 inode.c</div><div class="line">   144 Kconfig</div><div class="line">    21 Makefile</div><div class="line">  1732 message.c</div><div class="line">    68 notify.c</div><div class="line">   112 otg_whitelist.h</div><div class="line">   161 quirks.c</div><div class="line">   710 sysfs.c</div><div class="line">   589 urb.c</div><div class="line">   984 usb.c</div><div class="line">   160 usb.h</div><div class="line"> 16880 total</div></pre></td></tr></table></figure></p>
<p>drivers/usb/core目录共包括24个文件，16880行代码。core不愧是core，为大家默默的做这么多事。不过这么多文件里不一定都是我们所需要关注的，先拿咱们的地图来看看接下来该怎么走。先看看Kconfig文件，可以看到下面的选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">config USB_DEVICEFS</div><div class="line">        bool &quot;USB device filesystem&quot;</div><div class="line">        depends on USB</div><div class="line">        ---help---</div><div class="line">          If you say Y here (and to &quot;/proc file system support&quot; in the &quot;File</div><div class="line">          systems&quot; section, above), you will get a file /proc/bus/usb/devices</div><div class="line">          which lists the devices currently connected to your USB bus or</div><div class="line">          busses, and for every connected device a file named</div><div class="line">          &quot;/proc/bus/usb/xxx/yyy&quot;, where xxx is the bus number and yyy the</div><div class="line">          device number; the latter files can be used by user space programs</div><div class="line">          to talk directly to the device. These files are &quot;virtual&quot;, meaning</div><div class="line">          they are generated on the fly and not stored on the hard drive.</div><div class="line"></div><div class="line">          You may need to mount the usbfs file system to see the files, use</div><div class="line">          mount -t usbfs none /proc/bus/usb</div><div class="line"></div><div class="line">          For the format of the various /proc/bus/usb/ files, please read</div><div class="line">          &lt;file:Documentation/usb/proc_usb_info.txt&gt;.</div><div class="line"></div><div class="line">          Usbfs files can&apos;t handle Access Control Lists (ACL), which are the</div><div class="line">          default way to grant access to USB devices for untrusted users of a</div><div class="line">          desktop system. The usbfs functionality is replaced by real</div><div class="line">          device-nodes managed by udev. These nodes live in /dev/bus/usb and</div><div class="line">          are used by libusb.</div></pre></td></tr></table></figure></p>
<p>选项USB_DEVICEFS与usbfs文件系统有关。usbfs文件系统挂载在/proc/bus/usb目录，显示了当前连接的所有USB设备及总线的各种信息，每个连接的USB设备在其中都会有一个对应的文件进行描述。比如文件/proc/bus/usb/xxx/yyy，xxx表示总线的序号，yyy表示设备所在总线的地址。不过不能够依赖它们来稳定地访问设备，因为同一设备两次连接对应的描述文件可能会不同，比如，第一次连接一个设备时，它可能是002/027，一段时间后再次连接，它可能就已经改变为002/048。</p>
<p>就好比好不容易你暗恋的mm今天见你的时候对你抛了个媚眼，你心花怒放，赶快去买了100块彩票庆祝，到第二天再见到她的时候，她对你说你是谁啊，你悲痛欲绝的刮开那100块彩票，上面清一色的谢谢你。</p>
<p>因为usbfs文件系统并不属于USB子系统实现的核心部分，与之相关的代码我们可以不必关注。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">74 config USB_SUSPEND</div><div class="line">75       bool &quot;USB selective suspend/resume and wakeup (EXPERIMENTAL)&quot;</div><div class="line">76       depends on USB &amp;&amp; PM &amp;&amp; EXPERIMENTAL</div><div class="line">77       help</div><div class="line">78         If you say Y here, you can use driver calls or the sysfs</div><div class="line">79         &quot;power/state&quot; file to suspend or resume individual USB</div><div class="line">80         peripherals.</div><div class="line">81</div><div class="line">82         Also, USB &quot;remote wakeup&quot; signaling is supported, whereby some</div><div class="line">83         USB devices (like keyboards and network adapters) can wake up</div><div class="line">84         their parent hub.  That wakeup cascades up the USB tree, and</div><div class="line">85         could wake the system from states like suspend-to-RAM.</div><div class="line">86</div><div class="line">87         If you are unsure about this, say N here.</div></pre></td></tr></table></figure></p>
<p>这一项是有关USB设备的挂起和恢复。开发USB的人都是节电节能的好孩子，所以协议里就规定了，所有的设备都必须支持挂起状态，就是说为了达到节电的目的，当设备在指定的时间内，如果没有发生总线传输，就要进入挂起状态。当它收到一个non-idle的信号时，就会被唤醒。节约用电从USB做起。不过这个与主题也没太大关系，相关代码也可以不用关注了。</p>
<p>剩下的还有几项，不过似乎与咱们关系也不大，还是去看看Makefile。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">usbcore-objs    := usb.o hub.o hcd.o urb.o message.o driver.o /</div><div class="line">                        config.o file.o buffer.o sysfs.o endpoint.o /</div><div class="line">                        devio.o notify.o generic.o quirks.o</div><div class="line"></div><div class="line">ifeq ($(CONFIG_PCI),y)</div><div class="line">         usbcore-objs    += hcd-pci.o</div><div class="line"> endif</div><div class="line"></div><div class="line"> ifeq ($(CONFIG_USB_DEVICEFS),y)</div><div class="line">         usbcore-objs    += inode.o devices.o</div><div class="line"> endif</div><div class="line"></div><div class="line"> obj-$(CONFIG_USB)       += usbcore.o</div><div class="line"></div><div class="line"> ifeq ($(CONFIG_USB_DEBUG),y)</div><div class="line"> EXTRA_CFLAGS += -DDEBUG</div><div class="line"> endif</div></pre></td></tr></table></figure></p>
<p>Makefile可比Kconfig简略多了，所以看起来也更亲切点，咱们总是拿的money越多越好，看的代码越少越好。这里之所以会出现CONFIG_PCI，是因为通常USB的Root Hub包含在一个PCI设备中。hcd-pci和hcd顾名而思义就知道是说主机控制器的，它们实现了主机控制器公共部分，按协议里的说法它们就是HCDI（HCD的公共接口），host目录下则实现了各种不同的主机控制器。</p>
<p>CONFIG_USB_DEVICEFS前面的Kconfig文件里也见到了，关于usbfs的，与咱们的主题无关，inode.c和devices.c两个文件也可以不用管了。</p>
<p>那么我们可以得出结论，为了理解内核对USB子系统的实现，我们需要研究buffer.c、config.c、driver.c、endpoint.c、file.c、generic.c、hcd.c  hcd.h、hub.c、message.c、notify.c、otg_whitelist.h、quirks.c、sysfs.c、urb.c 和usb.c文件。这么看来，好像大都需要关注的样子，没有减轻多少压力，不过这里本身就是USB Core部分，是要做很多的事为咱们分忧的，所以多点也是可以理解的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Kernel地图：Kconfig与Makefile]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/kconfig-and-makefile/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/fudan_abc/article/details/5340408" target="_blank" rel="external">《Linux内核修炼之道》精华分享与讨论（5）——Kernel地图：Kconfig与Makefile </a></p>
<p>Kconfig和Makefile就是Linux Kernel迷宫里的地图。地图引导我们去认识一个城市，而Kconfig和Makefile则可以让我们了解一个Kernel目录下面的结构。我们每次浏览kernel寻找属于自己的那一段代码时，都应该首先看看目录下的这两个文件。<br><a id="more"></a></p>
<h2 id="利用Kconfig和Makefile寻找目标代码"><a href="#利用Kconfig和Makefile寻找目标代码" class="headerlink" title="利用Kconfig和Makefile寻找目标代码"></a>利用Kconfig和Makefile寻找目标代码</h2><p>就像利用地图寻找目的地一样，我们需要利用Kconfig和Makefile来寻找所要研究的目标代码。</p>
<p>比如我们打算研究U盘驱动的实现，因为U盘是一种storage设备，所以我们应该先进入到drivers/usb/storage/目录。但是该目录下的文件很多，那么究竟哪些文件才是我们需要关注的？这时就有必要先去阅读Kconfig和Makefile文件。</p>
<p>对于Kconfig文件，我们可以看到下面的选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">config USB_STORAGE_DATAFAB</div><div class="line">        bool &quot;Datafab Compact Flash Reader support (EXPERIMENTAL)&quot;</div><div class="line">       depends on USB_STORAGE &amp;&amp; EXPERIMENTAL</div><div class="line">       help</div><div class="line">         Support for certain Datafab CompactFlash readers.</div><div class="line">         Datafab has a web page at &lt;http://www.datafabusa.com/&gt;.</div></pre></td></tr></table></figure></p>
<p>显然，这个选项和我们的目的没有关系。首先它专门针对Datafab公司的产品，其次虽然CompactFlash reader是一种flash设备，但显然不是U盘。因为drivers/usb/storage目录下的代码是针对usb mass storage这一类设备，而不是针对某一种特定的设备。U盘只是usb mass storage设备中的一种。再比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">config USB_STORAGE_SDDR55</div><div class="line">        bool &quot;SanDisk SDDR-55 SmartMedia support (EXPERIMENTAL)&quot;</div><div class="line">        depends on USB_STORAGE &amp;&amp; EXPERIMENTAL</div><div class="line">        help</div><div class="line">            Say Y here to include additional code to support the Sandisk SDDR-55</div><div class="line">            SmartMedia reader in the USB Mass Storage driver.</div></pre></td></tr></table></figure></p>
<p>很显然这个选项是有关SanDisk产品的，并且针对的是SM卡，同样不是U盘，所以我们也不需要去关注。</p>
<p>事实上，很容易确定，只有选项CONFIG_USB_STORAGE才是我们真正需要关注的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">config USB_STORAGE</div><div class="line">      tristate &quot;USB Mass Storage support&quot;</div><div class="line">       depends on USB &amp;&amp; SCSI</div><div class="line">      ---help---</div><div class="line">        Say Y here if you want to connect USB mass storage devices to your</div><div class="line">        computer&apos;s USB port. This is the driver you need for USB</div><div class="line">        floppy drives, USB hard disks, USB tape drives, USB CD-ROMs,</div><div class="line">        USB flash devices, and memory sticks, along with</div><div class="line">        similar devices. This driver may also be used for some cameras</div><div class="line">        and card readers.</div><div class="line"></div><div class="line">        This option depends on &apos;SCSI&apos; support being enabled, but you</div><div class="line">          probably also need &apos;SCSI device support: SCSI disk support&apos;</div><div class="line">        (BLK_DEV_SD) for most USB storage devices.</div><div class="line"></div><div class="line">        To compile this driver as a module, choose M here: the</div><div class="line">        module will be called usb-storage.</div></pre></td></tr></table></figure></p>
<p>接下来阅读Makefile文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#</div><div class="line"># Makefile for the USB Mass Storage device drivers.</div><div class="line">#</div><div class="line"># 15 Aug 2000, Christoph Hellwig</div><div class="line"># Rewritten to use lists instead of if-statements.</div><div class="line">#</div><div class="line"></div><div class="line">EXTRA_CFLAGS    := -Idrivers/scsi</div><div class="line"></div><div class="line">obj-$(CONFIG_USB_STORAGE)    += usb-storage.o</div><div class="line"></div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_DEBUG)    += debug.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_USBAT)    += shuttle_usbat.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR09)    += sddr09.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_SDDR55)    += sddr55.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_FREECOM)    += freecom.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_DPCM)    += dpcm.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_ISD200)    += isd200.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_DATAFAB)    += datafab.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_JUMPSHOT)    += jumpshot.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_ALAUDA)    += alauda.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_ONETOUCH)    += onetouch.o</div><div class="line"> usb-storage-obj-$(CONFIG_USB_STORAGE_KARMA)    += karma.o</div><div class="line"></div><div class="line"> usb-storage-objs :=    scsiglue.o protocol.o transport.o usb.o /</div><div class="line">              initializers.o $(usb-storage-obj-y)</div><div class="line"></div><div class="line"> ifneq ($(CONFIG_USB_LIBUSUAL),)</div><div class="line">      obj-$(CONFIG_USB)    += libusual.o</div><div class="line"> endif</div></pre></td></tr></table></figure></p>
<p>前面通过Kconfig文件的分析，我们确定了只需要去关注CONFIG_USB_STORAGE选项。在Makefile文件里查找CONFIG_USB_STORAGE，从第9行得知，该选项对应的模块为usb-storage。</p>
<p>因为Kconfig文件里的其他选项我们都不需要关注，所以Makefile的11~22行可以忽略。第24行意味着我们只需要关注scsiglue.c、protocol.c、transport.c、usb.c、initializers.c以及它们同名的.h头文件。</p>
<p>Kconfig和Makefile很好的帮助我们定位到了所要关注的目标，就像我们到一个陌生的地方要随身携带地图，当我们学习Linux内核时，也要谨记寻求Kconfig和Makefile的帮助。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文件和目录]]></title>
      <url>https://jarsonfang.github.io/programming/APUE/files-and-directories/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://www.cnblogs.com/CoreyGao/archive/2013/04/21/3034745.html" target="_blank" rel="external">APUE读书笔记 之 文件和目录</a></p>
<p>描述文件系统的特征和文件的性质。</p>
<p>UNIX用户层的文件系统主要包括两部分：</p>
<ol>
<li>文件的<code>stat</code>属性。</li>
<li>由文件的某些属性与进程的属性相结合衍生出的权限控制系统。</li>
</ol>
<p>本章还初步介绍了UFS（UNIX FIle System)软件层的基本结构。<br><a id="more"></a></p>
<p>文件基本属性如图1:</p>
<img src="/programming/APUE/files-and-directories/ufs.png" alt="图1 文件基本属性" title="图1 文件基本属性">
<p>文件的权限控制如图2:</p>
<img src="/programming/APUE/files-and-directories/file_permission.png" alt="图2 权限控制系统" title="图2 权限控制系统">
<h2 id="stat、fstat-和-lstat-函数"><a href="#stat、fstat-和-lstat-函数" class="headerlink" title="stat、fstat 和 lstat 函数"></a>stat、fstat 和 lstat 函数</h2><p>本章讨论的中心是三个<code>stat</code>函数以及它们所返回的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">struct</span> stat *<span class="keyword">restrict</span> buf)</span></span>;</div><div class="line"></div><div class="line">    All three <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure>
<p>一旦给出<code>pathname</code>，<code>stat</code>函数就返回与此命名文件有关的信息结构。<code>fstat</code>函数获取已在描述符<code>filedes</code>上打开文件的有关信息。<code>lstat</code>函数类似与<code>stat</code>，但是当命名文件是一个符号链接时，<code>lstat</code>返回该符号链接的有关信息，而不是由该符号链接引用文件的信息。</p>
<p>第二个参数<code>buf</code>是指针，它指向一个必须提供的结构，这些函数填写由<code>buf</code>指向的结构。该结构的实际定义可能随实现有所不同，但其基本形式是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> stat &#123;</div><div class="line">    <span class="keyword">mode_t</span>    st_mode;      <span class="comment">/* file type &amp; mode (permissions) */</span></div><div class="line">    <span class="keyword">ino_t</span>     st_ino;       <span class="comment">/* i-node number (serial number) */</span></div><div class="line">    <span class="keyword">dev_t</span>     st_dev;       <span class="comment">/* device number (file system) */</span></div><div class="line">    <span class="keyword">dev_t</span>     st_rdev;      <span class="comment">/* device number for special files */</span></div><div class="line">    <span class="keyword">nlink_t</span>   st_nlink;     <span class="comment">/* number of links */</span></div><div class="line">    <span class="keyword">uid_t</span>     st_uid;       <span class="comment">/* user ID of owner */</span></div><div class="line">    <span class="keyword">gid_t</span>     st_gid;       <span class="comment">/* group ID of owner */</span></div><div class="line">    <span class="keyword">off_t</span>     st_size;      <span class="comment">/* size in bytes, for regular files */</span></div><div class="line">    <span class="keyword">time_t</span>    st_atime;     <span class="comment">/* time of last access */</span></div><div class="line">    <span class="keyword">time_t</span>    st_mtime;     <span class="comment">/* time of last modification */</span></div><div class="line">    <span class="keyword">time_t</span>    st_ctime;     <span class="comment">/* time of last file status change */</span></div><div class="line">    <span class="keyword">blksize_t</span> st_blksize;   <span class="comment">/* best I/O block size */</span></div><div class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;    <span class="comment">/* number of disk blocks allocated */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>关于 restrict 修饰符：<br>C99 中新增加了 <code>restrict</code> 修饰的指针： 由 <code>restrict</code> 修饰的指针是最初唯一对指针所指向的对象进行存取的方法，仅当第二个指针基于第一个时，才能对对象进行存取。对对象的存取都限定于基于由 <code>restrict</code> 修饰的指针表达式中。<br>由 <code>restrict</code> 修饰的指针主要用于函数形参，或指向由 <code>malloc()</code> 分配的内存空间。<code>restrict</code> 数据类型不改变程序的语义。编译器能通过作出 <code>restrict</code> 修饰的指针是存取对象的唯一方法的假设，更好地优化某些类型的例程。</p>
</blockquote>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>文件类型信息包含在<code>stat</code>结构的<code>st_mode</code>成员中，可以用表4-1中的宏确定文件类型，这些宏的参数都是<code>stat</code>结构中的<code>st_mode</code>成员。</p>
<p>表4-1 &lt;sys/stat.h&gt;中的文件类型宏</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_ISREG()</td>
<td>普通文件</td>
</tr>
<tr>
<td>S_ISDIR()</td>
<td>目录文件</td>
</tr>
<tr>
<td>S_ISCHR()</td>
<td>字符特殊文件</td>
</tr>
<tr>
<td>S_ISBLK()</td>
<td>块特殊文件</td>
</tr>
<tr>
<td>S_ISFIFO()</td>
<td>管道或FIFO</td>
</tr>
<tr>
<td>S_ISLNK()</td>
<td>符号链接</td>
</tr>
<tr>
<td>S_ISSOCK()</td>
<td>套接字</td>
</tr>
</tbody>
</table>
<p>下面的程序代码对每个命令行参数打印其文件类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>         i;</div><div class="line">    <span class="keyword">struct</span> stat buf;</div><div class="line">    <span class="keyword">char</span>        *ptr;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[i]);</div><div class="line">        <span class="keyword">if</span> (lstat(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</div><div class="line">            err_ret(<span class="string">"lstat error"</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (S_ISREG(buf.st_mode))</div><div class="line">            ptr = <span class="string">"regular"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(buf.st_mode))</div><div class="line">            ptr = <span class="string">"directory"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISCHR(buf.st_mode))</div><div class="line">            ptr = <span class="string">"character special"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(buf.st_mode))</div><div class="line">            ptr = <span class="string">"block special"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(buf.st_mode))</div><div class="line">            ptr = <span class="string">"fifo"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(buf.st_mode))</div><div class="line">            ptr = <span class="string">"symbolic link"</span>;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(buf.st_mode))</div><div class="line">            ptr = <span class="string">"socket"</span>;</div><div class="line">         <span class="keyword">else</span></div><div class="line">            ptr = <span class="string">"** unknown mode **"</span>;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</div><div class="line">  &#125;</div><div class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>早前的UNIX系统版本并不提供<code>S_ISXXX</code>宏，于是就需要将<code>st_mode</code>与屏蔽字<code>S_IFMT</code>进行逻辑“与”运算，然后与名为<code>S_IFXXX</code>的常量相比较。大多数系统在文件&lt;sys/stat.h&gt;中定义了此屏蔽字和相关的常量。如若查看此文件，则可找到<code>S_ISDIR</code>宏定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(mode) (((mode) &amp; S_IFMT) == S_IFDIR)</span></div></pre></td></tr></table></figure></p>
<h2 id="设置用户ID（Set-User-ID）和设置组ID（Set-Group-ID）"><a href="#设置用户ID（Set-User-ID）和设置组ID（Set-Group-ID）" class="headerlink" title="设置用户ID（Set-User-ID）和设置组ID（Set-Group-ID）"></a>设置用户ID（Set-User-ID）和设置组ID（Set-Group-ID）</h2><p><strong>进程相关ID</strong></p>
<p>与一个进程相关联的ID有6个或更多，如表4-4所示：</p>
<p>表4-4 与每个进程相关联的用户ID和组ID</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>实际用户ID（real user ID）<br>实际组ID（real group ID）</td>
<td>我们实际上是谁</td>
</tr>
<tr>
<td>有效用户ID（effective user ID）<br>有效组ID（effective group ID）<br>附加组ID（supplementary group IDs）</td>
<td>用于文件访问权限检查</td>
</tr>
<tr>
<td>保存的设置用户ID（saved set-user-ID ）<br>保存的设置组ID（saved set-group-ID）</td>
<td>由exec函数保存</td>
</tr>
</tbody>
</table>
<ul>
<li>实际用户ID和实际组ID标识我们究竟是谁。这两个字段在用户登录时取自口令文件中的登录项。通常，在一个登录会话期间这些值并不改变，但是超级用户进程有方法改变它们。</li>
<li>有效用户ID、有效组ID以及附加组ID决定了我们的文件访问权限。</li>
<li>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效组ID的副本。<br>通常，有效用户ID等于实际用户ID、有效组ID等于实际组ID。</li>
</ul>
<p><strong>文件相关ID</strong></p>
<p>每个文件都有一个所有者和组所有者，所有者由<code>stat</code>结构中的<code>st_uid</code>成员表示，组所有者则由<code>st_gid</code>成员表示。</p>
<p>当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常是实际组ID。但是可以在文件模式字（<code>st_mode</code>）中设置一个特殊标志，其含义是“<span style="color:red;">当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID（st_uid）</span>”。与此相类似，在文件模式字中可以设置另一位，它使得<span style="color:red;">将执行此文件的进程的有效组ID设置为文件的组所有者ID（<code>st_gid</code>）</span>。在文件模式字中的这两位被称为 <em>设置用户ID</em>（<code>set-user-ID</code>）位和 <em>设置组ID</em>（<code>set-group-ID</code>）位。</p>
<p>再返回到<code>stat</code>函数，设置用户ID位和设置组ID位都包含在<code>st_mode</code>值中，这两位可用常量 <code>S_ISUID</code> 和 <code>S_ISGID</code> 测试。</p>
<h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p><code>st_mode</code>值也包含了针对文件的访问权限位。所有文件类型（目录文件、字符特殊文件等）都有访问权限（access permission）。<br>每个文件有9个访问权限位，可将它们分成三类（读、写及执行），如表4-5所示：</p>
<p><a name="file_permission">表4-5</a> 9个文件访问权限位，取自&lt;sys/stat.h&gt;</p>
<table>
<thead>
<tr>
<th>st_mode mask</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR<br>S_IWUSR<br>S_IXUSR</td>
<td>user-read<br>user-write<br>user-execute</td>
</tr>
<tr>
<td>S_IRGRP<br>S_IWGRP<br>S_IXGRP</td>
<td>group-read<br>group-write<br>group-execute</td>
</tr>
<tr>
<td>S_IROTH<br>S_IWOTH<br>S_IXOTH</td>
<td>other-read<br>other-write<br>other-execute</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Protection bits.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_ISUID       04000   <span class="comment">/* Set user ID on execution.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_ISGID       02000   <span class="comment">/* Set group ID on execution.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_ISVTX       01000   <span class="comment">/* Save swapped text after use (sticky).  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_IREAD       0400    <span class="comment">/* Read by owner.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_IWRITE      0200    <span class="comment">/* Write by owner.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __S_IEXEC       0100    <span class="comment">/* Execute by owner.  */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISUID __S_ISUID       <span class="comment">/* Set user ID on execution.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISGID __S_ISGID       <span class="comment">/* Set group ID on execution.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISVTX __S_ISVTX       <span class="comment">/* Save swapped text after use (sticky bit).  */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR __S_IREAD       <span class="comment">/* Read by owner.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR __S_IWRITE      <span class="comment">/* Write by owner.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR __S_IEXEC       <span class="comment">/* Execute by owner.  */</span></span></div><div class="line"><span class="comment">/* Read, write, and execute by owner.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP (S_IRUSR &gt;&gt; 3)  <span class="comment">/* Read by group.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP (S_IWUSR &gt;&gt; 3)  <span class="comment">/* Write by group.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP (S_IXUSR &gt;&gt; 3)  <span class="comment">/* Execute by group.  */</span></span></div><div class="line"><span class="comment">/* Read, write, and execute by group.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG (S_IRWXU &gt;&gt; 3)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH (S_IRGRP &gt;&gt; 3)  <span class="comment">/* Read by others.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH (S_IWGRP &gt;&gt; 3)  <span class="comment">/* Write by others.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH (S_IXGRP &gt;&gt; 3)  <span class="comment">/* Execute by others.  */</span></span></div><div class="line"><span class="comment">/* Read, write, and execute by others.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO (S_IRWXG &gt;&gt; 3)</span></div></pre></td></tr></table></figure>
<p>用名字打开任一类型的文件时，对该名字包含的每一个目录，包括它可能隐含的当前工作目录，都应具有执行权限，这也是为什么对于目录其执行权限位常被称为搜索位的原因。对于目录的读权限和执行权限，其意义是不同的：</p>
<ul>
<li>读权限允许我们读目录，获得在该目录中所有文件名的列表；</li>
<li>当一个目录是我们要访问文件的路径名的一个组成部分时，对该目录的执行权限使我们可通过该目录（也即是搜索该目录，寻找一个特定的文件名）。</li>
</ul>
<p>引用隐含目录的一个例子是，如果<code>PATH</code>环境变量指定了一个我们不具有执行权限的目录，那么shell决不会在该目录下找到可执行文件。</p>
<p>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限，为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限，但对该文件本身则不需要有读、写权限。如果使用<code>exec</code>函数族中的任何一个执行某个文件，都必须对该文件具有执行权限，且该文件还必须是一个普通文件。</p>
<p>进程每次打开、创建或者删除一个文件时，内核就进行文件访问权限测试，而这种测试可能涉及文件的所有者（<code>st_uid</code> 和<code>st_gid</code>）、进程的有效ID（有效用户ID和有效组ID）以及进程的附加组ID（若支持）。两个所有者ID是文件的性质，而两个有效ID和附加组ID则是进程的性质。内核进行的测试是：<br>（1）若进程的有效用户ID是<code>0</code>（超级用户），则允许访问。这给予了超级用户对整个文件系统进行处理的最充分的自由。<br>（2）若进程的有效用户ID等于文件的所有者ID（也即该进程拥有此文件），那么，若所有者适当的访问权限位被设置，则允许访问，否则拒绝访问。适当的访问权限位指的是，若进程为读而打开该文件，则用户读位应为<code>1</code>；若进程为写而打开该文件，则用户写位应为<code>1</code>；若进程将执行该文件，则用户执行位应为<code>1</code>。<br>（3）若进程的有效组ID或进程的附加组ID之一等于文件的组ID，那么，若组适当的访问权限位被设置，则允许访问，否则拒绝访问。<br>（4）若其他用户适当的访问权限位被设置，则允许访问，否则拒绝访问。<br>按顺序执行这四步。注意，如若进程拥有此文件，则按用户访问权限批准或拒绝该进程对文件的访问 —— 不查看组访问权限。类似的，若进程并不拥有该文件，但进程属于某个适当的组，则按组访问权限批准或拒绝该进程对文件的访问 —— 不查看其他用户的访问权限。</p>
<p><strong>新文件和目录的所有权</strong></p>
<p>新文件的用户ID设置为进程的有效用户ID，关于组ID，POSIX.1 允许实现选择下列之一作为新文件的组ID。<br>（1）新文件的组ID可以是进程的有效组ID<br>（2）新文件的组ID可以是它所在目录的组ID  </p>
<p><strong>粘住位</strong></p>
<blockquote>
<p><code>S_ISVTX</code> 位有一段有趣的历史。在UNIX尚未使用分页技术的早期版本中，<code>S_ISVTX</code> 位被称为 <em>粘住位</em>（stick bit）。如果一个可执行程序文件的这一位被设置了，那么在该程序第一次被执行并结束时，其程序正文部分的一个副本仍被保存在交换区。这使得下次执行该程序时能较快的将其装入内存区。其原因是：交换区占用连续磁盘空间，可将它视为连续文件，而且一个程序的正文部分在交换区中也是连续存放的，而在一般的UNIX文件系统中，文件的各数据块很可能是随机存放的。对于常用的应用程序，例如文本编辑器和 C 编译器，常常设置它们所在文件的粘住位。自然，对于在交换区中可以同时存放的设置了粘住位的文件数是有一定限制的，以免过多占用交换区空间，但无论如何，这是一个有用的技术。因为在系统再次自举前，文件的正文部分总是在交换区中，所以使用了名字“粘住”。后来的UNIX版本称它为<em>保存正文位</em>（saved-text bit），因此也就有了常量 <code>S_ISVTX</code> 。现今较新的UNIX系统大多数都配置有虚拟存储系统以及快速文件系统，所以不再需要使用这种技术。</p>
</blockquote>
<p>现今的系统扩展了粘住位的使用范围，Single UNIX Specification <span style="color:red;">允许针对目录设置粘住位</span>。如果对一个目录设置了粘住位，则只有对该目录具有写权限的用户在满足下列条件之一的情况下，才能删除或更名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>目录 /tmp 是设置粘住位的典型候选者 —— 任何用户都可在这个目录中创建文件。任一用户（用户、组和其他）对这个目录的权限通常都是读、写和执行。但是用户不应能删除或更名属于其他人的文件，为此在这个目录的文件模式中设置了粘住位。</p>
<h2 id="与文件访问权限相关的函数"><a href="#与文件访问权限相关的函数" class="headerlink" title="与文件访问权限相关的函数"></a>与文件访问权限相关的函数</h2><p><strong>access</strong>函数：测试文件访问权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure>
<p>其中，<code>mode</code>是下列常量的按位或（取自&lt;unistd.h&gt;）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Values for the second argument to access.</span></div><div class="line">   These may be OR'd together.  */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> R_OK    4               <span class="comment">/* Test for read permission.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> W_OK    2               <span class="comment">/* Test for write permission.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> X_OK    1               <span class="comment">/* Test for execute permission.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> F_OK    0               <span class="comment">/* Test for existence.  */</span></span></div></pre></td></tr></table></figure></p>
<p>如前所述，当用<code>open</code>函数打开一个文件时，内核以进程的有效用户ID或有效组ID为基础执行其访问权限测试，而<code>access</code>函数则是按实际用户ID和实际组ID进行访问权限测试的。<br><code>access</code>函数示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line">        err_quit(<span class="string">"usage: a.out &lt;pathname&gt;"</span>);</div><div class="line">    <span class="keyword">if</span> (access(argv[<span class="number">1</span>], R_OK) &lt; <span class="number">0</span>)</div><div class="line">        err_ret(<span class="string">"access error for %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read access OK\n"</span>);</div><div class="line">    <span class="keyword">if</span> (open(argv[<span class="number">1</span>], O_RDONLY) &lt; <span class="number">0</span>)</div><div class="line">        err_ret(<span class="string">"open error for %s"</span>, argv[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"open for reading OK\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>umask</strong>函数：设置文件模式创建屏蔽字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</div><div class="line"></div><div class="line">    Returns: previous file mode creation mask</div></pre></td></tr></table></figure></p>
<p>其中，参数<code>cmask</code>由<a href="#file_permission">表4-5</a>中列出的9个常量（<code>S_IRUSR</code>、<code>S_IWUSR</code>等）中的若干个按位“或”构成。<br><code>umask</code>函数为进程设置文件模式创建屏蔽字，并返回以前的值。（这是少数几个没有出错返回函数中的一个。）在进程创建一个新文件或目录时，就一定会使用文件模式创建屏蔽字。对于任何在文件模式创建屏蔽字中为 <code>1</code> 的位，在文件<code>mode</code>中的相应位则一定被关闭。<br>umask函数示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> RWRWRW (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    umask(<span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (creat(<span class="string">"foo"</span>, RWRWRW) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"creat error for foo"</span>);</div><div class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</div><div class="line">    <span class="keyword">if</span> (creat(<span class="string">"bar"</span>, RWRWRW) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"creat error for bar"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述程序创建两个文件，创建第一个时，<code>umask</code>值为<code>0</code>，创建第二个时，<code>umask</code>值禁止所有组和其他用户的访问权限。若运行此程序可得如下结果，从中可见访问权限是如何设置的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">umask</span>                <span class="comment">#first print the current file mode creation mask</span></div><div class="line">002</div><div class="line">$ ./a.out</div><div class="line">$ ls <span class="_">-l</span> foo bar</div><div class="line">-rw------- 1 sar            0 Dec 7 21:20 bar</div><div class="line">-rw-rw-rw- 1 sar            0 Dec 7 21:20 foo</div><div class="line">$ <span class="built_in">umask</span>                <span class="comment">#see if the file mode creation mask changed</span></div><div class="line">002</div></pre></td></tr></table></figure></p>
<p>UNIX系统的大多数用户从不处理他们的<code>umask</code>值。通常在登录时，由shell的启动文件设置一次，然后从不改变。尽管如此，当编写创建新文件的程序时，如果我们想确保指定的访问权限位已经激活，那么必须在进程运行时修改<code>umask</code>值。例如，如果我们想确保任何用户都能读文件，则应将<code>umask</code>设置为<code>0</code>。否则，当我们的进程运行时，有效的<code>umask</code>值可能关闭该权限位。<br>在前面的示例中，我们用shell的<code>umask</code>命令在运行程序的前、后打印文件模式创建屏蔽字。从中可见，<span style="color:red;">更改进程的文件模式创建屏蔽字并不影响其父进程（常常是shell）的屏蔽字</span>。<br>用户可设置<code>umask</code>值以控制他们所创建文件的默认权限。该值表示成八进制数（参考<a href="#file_permission">表4-5</a>的宏定义），一位代表一种要屏蔽的权限。设置了相应位后，它所对应的权限就会被拒绝。常用的几种<code>umask</code>值是<code>002</code>、<code>022</code>和<code>027</code>，<code>002</code>阻止其他用户写文件，<code>022</code>阻止同组成员和其他用户写文件，<code>027</code>阻住同组成员写文件以及其他用户读、写或执行文件。</p>
<p><strong>chmod</strong>和<strong>fchmod</strong>函数：改变现有文件的访问权限。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p><code>chmod</code>函数在指定的文件上进行操作，而<code>fchmod</code>函数则对已打开的文件进行操作。为改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。<br>参数<code>mode</code>是<a href="#file_permission">表4-5</a>中所示的9个文件访问权限位外加以下6项常量的“按位或”：两个设置ID常量（<code>S_ISUID</code> 和 <code>S_ISGID</code>）、保存正文常量（<code>S_ISVTX</code>），以及三个组合常量（<code>S_IRWXU</code>、<code>S_IRWXG</code> 和 <code>S_IRWXO</code>）。<br>chmod函数示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> stat      statbuf;</div><div class="line"></div><div class="line">     <span class="comment">/* turn on set-group-ID and turn off group-execute */</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> (stat(<span class="string">"foo"</span>, &amp;statbuf) &lt; <span class="number">0</span>)</div><div class="line">         err_sys(<span class="string">"stat error for foo"</span>);</div><div class="line">     <span class="keyword">if</span> (chmod(<span class="string">"foo"</span>, (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID) &lt; <span class="number">0</span>)</div><div class="line">         err_sys(<span class="string">"chmod error for foo"</span>);</div><div class="line"></div><div class="line">     <span class="comment">/* set absolute mode to "rw-r--r--" */</span></div><div class="line"></div><div class="line">     <span class="keyword">if</span> (chmod(<span class="string">"bar"</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) &lt; <span class="number">0</span>)</div><div class="line">         err_sys(<span class="string">"chmod error for bar"</span>);</div><div class="line"></div><div class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>chown</strong>、<strong>fchown</strong>和<strong>lchown</strong>函数：更改文件的用户ID和组ID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</div><div class="line"></div><div class="line">    All three <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>除了所引用的文件是符号链接外，这三个函数的操作相似。在符号链接的情况下，<code>lchown</code>更改符号链接本身的所有者，而不是该符号链接所指向的文件。<br>若两个参数<code>owner</code>或<code>group</code>中的任意一个是<code>-1</code>，则对应的ID不变。<br>基于BSD的系统一直规定只有超级用户才能更改一个文件的所有者。这样做的原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。系统V则允许任一用户更改他们所拥有的文件的所有者。<br>若 <code>_POSIX_CHOWN_RESTRICTED</code>（此选项与所引用的文件有关 —— 可在每个文件系统基础上，使该选项起作用或不起作用） 对指定的文件起作用，则<br>（1）只有超级用户进程能更改该文件的用户ID。<br>（2）若满足下列条件，一个非超级用户进程可以更改该文件的组ID：</p>
<ul>
<li>进程拥有此文件（其有效用户ID等于该文件的用户ID）。</li>
<li>参数<code>owner</code>等于<code>-1</code>或文件的用户ID，并且参数<code>group</code>等于进程的有效组ID或进程的附加组ID之一。</li>
</ul>
<p>这意味着，当 <code>_POSIX_CHOWN_RESTRICTED</code> 起作用时，不能更改其他用户文件的用户ID。你可以更改你所拥有的文件的组ID，但只能改到你所属的组。如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户ID位和设置组ID位都会被清除。</p>
<h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p><code>stat</code>结构成员<code>st_size</code>表示以字节为单位的文件长度。此字段只对普通文件、目录文件和符号链接有意义。对于普通文件，其长度可以是<code>0</code>，在读这种文件时，将得到文件结束(end-of-file)指示。对于目录，文件长度通常是一个数（例如<code>16</code>或<code>512</code>）的倍数。对于符号链接，文件长度是文件名中的实际字节数。例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lrwxrwxrwx 1 root           7 Sep 25 07:14 lib -&gt; usr/lib</div></pre></td></tr></table></figure></p>
<p>其中，文件长度 <code>7</code> 就是路径名<code>usr/lib</code>的长度（注意，因为符号链接文件长度总是由<code>st_size</code>指示，所以它并不包含通常C语言用作名字结尾的<code>null</code>字符）。<br>现今，大多数UNIX系统提供字段<code>st_blksize</code>和<code>st_blocks</code>。其中，第一个是对文件I/O较合适的块长度，第二个是所分配的实际512<sub><span style="color:red;">注</span></sub>字节块数量。<span style="color:red;">当<code>st_blksize</code>用于读操作时，读一个文件所需的时间量最少。</span>为了效率的缘故，标准I/O库也试图一次读、写<code>st_blksize</code>个字节。<br><span style="color:red;">注</span>：不同的UNIX版本，其<code>st_blocks</code>所用的单位可能不是<code>512</code>字节的块，使用此值并不是可移植的。</p>
<p><strong>文件中的空洞</strong></p>
<p>普通文件可以包含空洞，空洞是由所设置的偏移量超过文件尾端，并写了某些数据后造成的。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls <span class="_">-l</span> core</div><div class="line">-rw-r--r-- 1 sar       8483248 Nov 18 12:18 core</div><div class="line">$ du <span class="_">-s</span> core</div><div class="line">272        core</div></pre></td></tr></table></figure></p>
<p>文件<code>core</code>的长度刚好超过8 MB字节，而<code>du</code>命令则报告该文件所使用的磁盘空间总量是272个512字节块（139264字节），很明显，此文件中有很多空洞。对于没有写过的字节位置，<code>read</code>函数读到的字节是<code>0</code>。如果执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wc -c core</div><div class="line">8483248 core</div></pre></td></tr></table></figure></p>
<p><code>wc</code>命令的<code>-c</code>选项表示统计文件中的字符（字节）数</p>
<p>如果使用实用程序（例如<code>cat</code>）复制这种文件，那么所有这些空洞都会被填满，其中所有实际数据字节皆填写为<code>0</code>.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cat core &gt; core.copy</div><div class="line">$ ls <span class="_">-l</span> core*</div><div class="line">-rw-r--r--  1 sar      8483248 Nov 18 12:18 core</div><div class="line">-rw-rw-r--  1 sar      8483248 Nov 18 12:27 core.copy</div><div class="line">$ du <span class="_">-s</span> core*</div><div class="line">272     core</div><div class="line">16592   core.copy</div></pre></td></tr></table></figure></p>
<p>从中可见，新文件所用的字节数是8495104（512 x 16592）。此长度与ls命令报告的长度不同，其原因是，文件系统使用了若干块以存放指向实际数据块的各个指针。</p>
<p><strong>文件截短</strong></p>
<p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件清空为<code>0</code>是一个特列，在打开文件时使用<code>O_TRUNC</code>标志可以做到这一点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> length)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>这两个函数将把现有的文件长度截短为<code>length</code>字节。如果该文件以前的长度大于<code>length</code>，则超过<code>length</code>以外的数据就不能再访问；如果以前的长度短于<code>length</code>，则可能在文件中创建一个空洞。</p>
<h2 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h2><p>对每个文件保持有三个时间字段，它们的意义示于表4-10中。</p>
<p>表4-10 与每个文件相关的三个时间值</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>例子</th>
<th>ls 选项</th>
</tr>
</thead>
<tbody>
<tr>
<td>st_atime<br>st_mtime<br>st_ctime</td>
<td>文件数据的最后访问时间<br>文件数据的最后修改时间<br>i节点状态的最后更改时间</td>
<td>read<br>write<br>chmod, chown</td>
<td>-u<br>默认<br>-c</td>
</tr>
</tbody>
</table>
<p>注意修改时间（<code>st_mtime</code>）和状态更改时间（<code>st_ctime</code>）之间的区别。修改时间是文件内容最后一次被修改的时间。状态更改时间是该文件的i节点最后一次被修改的时间。很多影响到i节点的操作，例如，更改文件的访问权限、用户ID、链接数等，但它们并没有更改文件的实际内容。因为i节点中的所有信息都是与文件的实际内容分开存放的，所以，除了文件数据修改时间以外，还需要状态更改的时间。<br>注意，系统并不保存对一个i节点的最后一次访问时间，所以<code>access</code>和<code>stat</code>函数并不更改这三个时间中的任一个。</p>
<p><strong>utime</strong>函数：更改一个文件的访问和修改时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">struct</span> utimbuf *times)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>此函数使用的数据结构是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> utimbuf &#123;</div><div class="line">  <span class="keyword">time_t</span> actime;    <span class="comment">/* access time */</span></div><div class="line">  <span class="keyword">time_t</span> modtime;   <span class="comment">/* modification time */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结构中的两个时间值是日历时间，这是自1970年1月1日00:00:00以来国际标准时间所经过的秒数。</p>
<p>函数的操作以及执行时所要求的特权取决于<code>times</code>参数是否为<code>NULL</code>。</p>
<ul>
<li>如果<code>times</code>是一个空指针，则访问时间和修改时间两者都设置为当前时间。为执行此操作必须满足下列两个条件之一：进程的有效用户ID必须等于文件的所有者ID，或者进程对该文件必须具有写权限。</li>
<li>如果<code>times</code>是非空指针，则访问时间和修改时间被设置为<code>times</code>所指向结构中的值。此时进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件具有写权限是不够的。</li>
</ul>
<p>注意，不能对状态更改时间<code>st_ctime</code>指定一个值，当调用<code>utime</code>函数时，此字段将被自动更新。在某些UNIX系统版本中，<code>touch</code>命令使用了<code>utime</code>函数。</p>
<p><code>utime</code>函数使用示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>             i, fd;</div><div class="line">    <span class="keyword">struct</span> stat     statbuf;</div><div class="line">    <span class="keyword">struct</span> utimbuf  timebuf;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (stat(argv[i], &amp;statbuf) &lt; <span class="number">0</span>) &#123; <span class="comment">/* fetch current times */</span></div><div class="line">            err_ret(<span class="string">"%s: stat error"</span>, argv[i]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((fd = open(argv[i], O_RDWR | O_TRUNC)) &lt; <span class="number">0</span>) &#123; <span class="comment">/* truncate */</span></div><div class="line">            err_ret(<span class="string">"%s: open error"</span>, argv[i]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        close(fd);</div><div class="line">        timebuf.actime  =  statbuf.st_atime;</div><div class="line">        timebuf.modtime =  statbuf.st_mtime;</div><div class="line">        <span class="keyword">if</span> (utime(argv[i], &amp;timebuf) &lt; <span class="number">0</span>) &#123;     <span class="comment">/* reset times */</span></div><div class="line">            err_ret(<span class="string">"%s: utime error"</span>, argv[i]);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p><strong>UNIX 文件系统的基本结构</strong></p>
<p>一个磁盘可以分成多个分区，每个分区可以包含一个文件系统（如图4-1）。</p>
<img src="/programming/APUE/files-and-directories/unix_fs.gif" alt="图4-1 Disk drive, partitions, and a file system" title="图4-1 Disk drive, partitions, and a file system">
<p><code>i</code>节点是固定长度的记录项，它包含有关文件的大部分信息。</p>
<p>如果更仔细地观察一个柱面组的i节点和数据块部分，则可以看到图4-2所示的情况。</p>
<img src="/programming/APUE/files-and-directories/i-node.gif" alt="图4-2 Cylinder group's i-nodes and data blocks in more detail" title="图4-2 Cylinder group's i-nodes and data blocks in more detail">
<p>注意图4-2中的下列各点：</p>
<ul>
<li>在图中有两个目录项指向同一个<code>i</code>节点。每个<code>i</code>节点中都有一个链接计数，其值是指向该<code>i</code>节点的目录项数。只有当链接计数减少至<code>0</code>时，才可删除该文件（也即是可以释放该文件占用的数据块）。这就是为什么“解除对一个文件的链接”操作并不总是意味着“释放该文件占用的磁盘块”的原因。这也是为什么删除一个目录项的函数被称为<code>unlink</code>而不是<code>delete</code>的原因。在<code>stat</code>结构中，链接计数包含在<code>st_nlink</code>成员中，其基本系统数据类型是<code>nlink_t</code>，这种链接类型称为硬链接。</li>
<li><p>另外一种链接类型称为符号链接（symbolic link）。对于这种链接，该文件的实际内容（在数据块）包含了该符号链接所指向的文件的名字。在下例中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lrwxrwxrwx 1 root         7 Sep 25 07:14 lib -&gt; usr/lib</div></pre></td></tr></table></figure>
<p>该目录项中的文件名是<code>3</code>字符的字符串<code>lib</code>，而在该文件中包含了<code>7</code>个数据字节<code>usr/lib</code>。<br>该i节点的文件类型是<code>S_IFLINK</code>，于是系统知道这是一个符号链接。</p>
</li>
<li>i节点包含了大多数与文件有关的信息：文件类型、文件访问权限、文件长度和指向该文件所占用的数据块的指针等等。<code>stat</code>结构中的大多数信息都取自<code>i</code>节点。只有两项数据存放在目录项中：文件名和<code>i</code>节点编号。<code>i</code>节点编号的数据类型是<code>ino_t</code>。</li>
<li>每个文件系统各自对它们的<code>i</code>节点进行编号，因此目录项中的<code>i</code>节点编号数是指向同一个文件系统中的相应i节点，不能使一个目录项指向另一个文件系统的<code>i</code>节点。这就是为什么<code>ln</code>命令（构造一个指向一个现有文件的新目录项）不能跨越文件系统的原因。</li>
<li>当在不更换文件系统的情况下为一个文件更名时，该文件的实际内容并未移动，只需构造一个指向现有<code>i</code>节点的新目录项，并解除与旧目录项的链接。例如，为将文件<code>/usr/lib/foo</code>更名为<code>/usr/foo</code>，如果目录<code>/usr/lib</code>和<code>/usr</code>在同一个文件系统中，则文件<code>foo</code>的内容无需移动。这就是<code>mv</code>命令的通常操作方式。</li>
</ul>
<p>我们说明了普通文件的链接计数概念，但是对于目录文件的链接计数字段又如何呢？假定我们在工作目录中构造了一个新目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir testdir</div></pre></td></tr></table></figure></p>
<p>图4-3显示了其结果。注意，该图显式的显示了 <code>.</code> 和 <code>..</code> 目录项。</p>
<img src="/programming/APUE/files-and-directories/dentry.gif" alt="图4-3 Sample cylinder group after creating the directory testdir" title="图4-3 Sample cylinder group after creating the directory testdir">
<p>对于编号为<code>2549</code>的<code>i</code>节点，其类型字段表示它是一个目录，而链接计数为<code>2</code>.任何一个叶目录（不包含任何其他目录的目录）的链接计数总是<code>2</code>，数值<code>2</code>来自于命名该目录（<code>testdir</code>）的目录项以及在该目录中的 <code>.</code> 项。对于编号为<code>1267</code>的<code>i</code>节点，其类型字段表示它是一个目录，而其链接计数则大于或等于<code>3</code>。它大于或等于<code>3</code>的原因是，至少有三个目录项指向它：一个是命名它的目录项（在图4-3中没有表示出来），第二个是在该目录中的 <code>.</code> 项，第三个是在其子目录<code>testdir</code>中的 <code>..</code> 项。注意，父目录中的每一个子目录都会使该父目录项的链接计数增<code>1</code>。</p>
<p><strong>link</strong>、<strong>unlink</strong>、<strong>remove</strong> 和 <strong>rename</strong> 函数</p>
<p><code>link</code>函数：创建一个指向现有文件的链接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>任何一个文件可以有多个目录项指向其<code>i</code>节点，此函数创建一个新目录项<code>newpath</code>，它引用现有的文件<code>existingpath</code>。如若<code>newpath</code>已经存在，则返回出错。只创建<code>newpath</code>中的最后一个分量，路径中的其他部分应当已经存在。<br>创建新目录项以及增加链接计数应当是个原子操作。POSIX.1允许实现支持跨文件系统的链接，但大多数实现要求这两个路径名在同一个文件系统中。很多文件系统实现不允许创建指向目录的硬链接，其理由是指向目录的硬链接可能在文件系统中形成循环，而大多数处理文件系统的实用程序都不能处理这种情况。</p>
<p><code>unlink</code>函数：删除一个现有的目录项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>此函数删除目录项，并将由<code>pathname</code>所引用文件的链接计数减<code>1</code>.如果还有指向该文件的其他链接，则仍可以通过其他链接访问该文件的数据。如果出错，则不对该文件做任何更改。<br>为解除对文件的链接，进程必须对包含该目录项的目录具有写和执行权限。如果对目录设置了粘住位，则对该目录必须具有写权限，并且具备下面三个条件之一：</p>
<ul>
<li>拥有该文件。</li>
<li>拥有该目录。</li>
<li>具有超级用户特权。</li>
</ul>
<p>只有当链接计数达到<code>0</code>时，该文件的内容才可被删除。只要仍有进程打开了该文件，其文件内容不能被删除。关闭一个文件时，内核首先检查打开该文件的进程数，如果该数达到<code>0</code>，则检查其链接数，如果这个数也是<code>0</code>，则删除该文件内容。</p>
<p><code>unlink</code>函数使用示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (open(<span class="string">"tempfile"</span>, O_RDWR) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"open error"</span>);</div><div class="line">    <span class="keyword">if</span> (unlink(<span class="string">"tempfile"</span>) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"unlink error"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"file unlinked\n"</span>);</div><div class="line">    sleep(<span class="number">15</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"done\n"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行该程序，其结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ ls <span class="_">-l</span> tempfile            <span class="comment">#look at how big the file is</span></div><div class="line">-rw-r----- 1 sar     413265408 Jan 21 07:14 tempfile</div><div class="line">$ df /home                  <span class="comment">#check how much free space is available</span></div><div class="line">Filesystem  1K-blocks     Used  Available  Use%  Mounted  on</div><div class="line">/dev/hda4    11021440  1956332    9065108   18%  /home</div><div class="line">$ ./a.out &amp;                 <span class="comment">#run the program above in the background</span></div><div class="line">1364                        <span class="comment">#the shell prints its process ID</span></div><div class="line">$ file unlinked             <span class="comment">#the file is unlinked</span></div><div class="line">ls <span class="_">-l</span> tempfile              <span class="comment">#see if the filename is still there</span></div><div class="line">ls: tempfile: No such file or directory   <span class="comment">#the directory entry is gone</span></div><div class="line">$ df /home                  <span class="comment">#see if the space is available yet</span></div><div class="line">Filesystem  1K-blocks     Used  Available  Use%  Mounted  on</div><div class="line">/dev/hda4    11021440  1956332    9065108   18%  /home</div><div class="line">$ <span class="keyword">done</span>                      <span class="comment">#the program is done, all open files are closed</span></div><div class="line">df /home                    <span class="comment">#now the disk space should be available</span></div><div class="line">Filesystem  1K-blocks     Used  Available  Use%  Mounted on</div><div class="line">/dev/hda4    11021440  1552352    9469088   15%  /home</div><div class="line">                            <span class="comment">#now the 394.1 MB of disk space are available</span></div></pre></td></tr></table></figure></p>
<p><span style="color:red;"><code>unlink</code>的这种性质经常被程序用来确保即使是在该程序崩溃时，它所创建的临时文件也不会遗留下来。</span>进程用<code>open</code>或<code>create</code>创建一个文件，然后立即调用<code>unlink</code>。因为该文件仍旧是打开的，所以不会将其内容删除。只有当进程关闭该文件或终止时（在这种情况下，内核会关闭该进程打开的全部文件），该文件的内容才会被删除。<br>如果<code>pathname</code>是符号链接，那么<code>unlink</code>删除该符号链接，而不会删除由该链接所引用的文件。给出符号链接名情况下，没有一个函数能删除由该链接所引用的文件。超级用户可以调用<code>unlink</code>，其参数<code>pathname</code>指向一个目录，但通常应当使用<code>rmdir</code>函数，而不使用这种方式。</p>
<p><code>remove</code>函数：解除对一个文件或目录的链接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>对于文件，<code>remove</code>的功能与<code>unlink</code>相同；对于目录，<code>remove</code>的功能与<code>rmdir</code>相同。</p>
<blockquote>
<p>ISO C 指定<code>remove</code>函数删除一个文件，这更改了UNIX历来使用的名字<code>unlink</code>，其原因是实现C标准的大多数非UNIX系统并不支持文件链接。</p>
</blockquote>
<p><code>rename</code>函数：更改文件或目录的名称。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<blockquote>
<p>ISO C对文件定义了此函数（C标准不处理目录）。POSIX.1扩展此定义，使其包含目录和符号链接。</p>
</blockquote>
<p>根据<code>oldname</code>指向文件还是目录，有以下几种情况：<br>（1）如果<code>oldname</code>指向一个文件而不是目录，那么为该文件或符号链接更名。如果<code>newname</code>已存在，则它不能引用一个目录。如果<code>newname</code>已存在，而且不是一个目录，则先将该目录项删除然后将<code>oldname</code>更名为<code>newname</code>。对包含<code>oldname</code>的目录以及包含<code>newname</code>的目录，调用进程必须具有写权限，因为将更改这两个目录。<br>（2）如果<code>oldname</code>指向一个目录，那么为该目录更名。如果<code>newname</code>已存在，则它必须引用一个目录，而且该目录应当是空目录（空目录指的是该目录中只有 <code>.</code> 和 <code>..</code> 项）。如果<code>newname</code>存在（而且是一个空目录），则先将其删除，然后将<code>oldname</code>更名为<code>newname</code>。另外，当为一个目录更名时，<code>newname</code>不能包含<code>oldname</code>作为其路径前缀。例如，不能将<code>/usr/foo</code>更名为<code>/usr/foo/testdir</code>，因为旧名字（<code>/usr/foo</code>）是新名字的路径前缀，因而不能将其删除。<br>（3）如果<code>oldname</code>或<code>newname</code>引用符号链接，则处理的是符号链接本身，而不是它所引用的文件。<br>（4）作为一个特例，如果<code>oldname</code>和<code>newname</code>引用同一个文件，则函数不做任何更改而成功返回。</p>
<p><strong>符号链接</strong></p>
<p>符号链接是指向一个文件的间接指针，它与硬链接不同，硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制：</p>
<ul>
<li>硬链接通常要求链接和文件位于同一个文件系统中。</li>
<li>只有超级用户才能创建指向目录的硬链接。</li>
</ul>
<p>对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一个位置。<br>当使用<span style="color:red;">以名字引用文件</span>的函数时，应当了解该函数是否处理符号链接。也即是该函数是否<span style="color:red;">跟随符号链接到达它所链接的文件</span>。如若该函数具有处理符号链接的功能，则其路径名参数引用由符号链接指向的文件。否则，路径名参数将引用链接本身，而不是该链接指向的文件。<br>用<code>open</code>打开文件时，如果传递给<code>open</code>函数的路径名指定了一个符号链接，<code>open</code>函数将跟随此链接到达所指向的文件。若此符号链接所指向的文件并不存在，则<code>open</code>返回出错，表示它不能打开该文件。这可能会使不熟悉符号链接的用户感到迷惑，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> /no/such/file myfile            <span class="comment">#create a symbolic link</span></div><div class="line">$ ls myfile</div><div class="line">myfile                                  <span class="comment">#ls says it's there</span></div><div class="line">$ cat myfile                            <span class="comment">#so we try to look at it</span></div><div class="line">cat: myfile: No such file or directory</div><div class="line">$ ls <span class="_">-l</span> myfile                          <span class="comment">#try -l option</span></div><div class="line">lrwxrwxrwx 1 sar        13 Jan 22 00:26 myfile -&gt; /no/such/file</div></pre></td></tr></table></figure></p>
<p><strong>symlink</strong> 和 <strong>readlink</strong> 函数</p>
<p><code>symlink</code>函数：创建一个符号链接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>该函数创建一个指向<code>actualpath</code>的新目录项<code>sympath</code>，在创建此符号链接时，并不要求<code>actualpath</code>已经存在，并且，<code>actualpath</code>和<code>sympath</code>并不需要位于同一个文件系统中。</p>
<p><code>readlink</code>函数：读取符号链接中的名字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf,</div><div class="line">                 <span class="keyword">size_t</span> bufsize);</div><div class="line"></div><div class="line">    Returns: number of bytes read <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>因为<code>open</code>函数跟随符号链接，所以需要有一种方法打开该符号链接本身，并读取该链接中的名字。<code>readlink</code>函数组合了<code>open</code>、<code>read</code>和<code>close</code>的所有操作。如果此函数成功执行，则它返回读入<code>buf</code>的字节数。<span style="color:red;">在<code>buf</code>中返回的符号链接的内容不以<code>null</code>字符终止。</span></p>
<p><strong>mkdir</strong> 和 <strong>rmdir</strong> 函数</p>
<p><code>mkdir</code>函数：创建目录<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>此函数创建一个空目录。其中 <code>.</code> 和 <code>..</code> 目录项是自动创建的。所指定的文件访问权限<code>mode</code>由进程的文件模式创建屏蔽字修改。常见的错误是指定与文件相同的<code>mode</code>（只指定读、写权限），对于目录，通常至少要设置<code>1</code>个执行权限位，以允许访问该目录中的文件名。</p>
<p><code>rmdir</code>函数：删除一个空目录，空目录是只包含 <code>.</code> 和 <code>..</code> 这两项的目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p><strong>读目录</strong></p>
<p>对某个目录具有访问权限的任一用户都可读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不表示能否写目录本身。</p>
<p>目录的实际格式依赖于UNIX系统，特别是其文件系统的具体设计和实现。早期的系统有一个比较简单的结构：每个目录项是<code>16</code>个字节，其中<code>14</code>个字节是文件名，<code>2</code>个字节是i节点编号。而对于<code>4</code>.2BSD而言，由于它允许相当长的文件名，所以每个目录项的长度是可变的。这就意味着读目录的程序与系统相关。为简化这种情况，UNIX现在包含了一套与读目录相关的例程，它们是POSIX.1的一部分。很多实现阻止应用程序使用<code>read</code>函数读取目录的内容，从而进一步将应用程序与目录格式中与实现相关的细节隔离开。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"></div><div class="line">    Returns: pointer <span class="keyword">if</span> OK, <span class="function"><span class="literal">NULL</span> on error</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span>;</div><div class="line"></div><div class="line">    Returns: pointer <span class="keyword">if</span> OK, <span class="function"><span class="literal">NULL</span> at end of directory or error</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> <span class="function">on error</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span>;</div><div class="line"></div><div class="line">    Returns: <span class="function">current location in directory associated with dp</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span>;</div></pre></td></tr></table></figure></p>
<p><code>telldir</code>和<code>seekdir</code>函数不是基本POSIX.1标准的组成部分，它们是Single UNIX Specification中的XSI扩展，所以所有遵循UNIX系统的实现都会提供这两个函数。</p>
<p>头文件&lt;dirent.h&gt;中定义的<code>dirent</code>结构与实现有关。几种典型的UNIX实现对此结构所作的定义至少包含下列两个成员：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> dirent &#123;</div><div class="line">    <span class="keyword">ino_t</span> d_ino;                  <span class="comment">/* i-node number */</span></div><div class="line">    <span class="keyword">char</span>  d_name[NAME_MAX + <span class="number">1</span>];   <span class="comment">/* null-terminated filename */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>NAME_MAX</code> 的常用值是<code>255</code>。因为文件名是以<code>null</code>字符结束的，所以在头文件中如何定义数组<code>d_name</code>并无多大关系，数组大小并不表示文件名的长度。</p>
<p><code>DIR</code> 结构是一个内部结构，上述6个函数用这个内部结构保存当前正被读的目录的有关信息。其作用类似于 <code>FILE</code> 结构，<code>FILE</code>结构由标准I/O库维护。</p>
<p>由<code>opendir</code>返回的指向<code>DIR</code>结构的指针由另外5个函数使用。<code>opendir</code>执行初始化操作，使第一个<code>readdir</code>读目录中的第一个目录项。目录中各目录项的顺序与实现有关，它们通常并不按字母顺序排列。</p>
<p><strong>chdir</strong>、<strong>fchdir</strong>和<strong>getcwd</strong>函数</p>
<p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点（不以斜杠开始的路径名为相对路径名）。当用户登录到UNIX系统时，其当前工作目录通常是口令文件（<code>/etc/passwd</code>）中该用户登录项的第6个字段——用户的起始目录（home directory）。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。</p>
<p>进程通过调用<code>chdir</code>或<code>fchdir</code>函数更改当前工作目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>在这两个函数中，分别用<code>pathname</code>或打开的文件描述符来指定新的当前工作目录。</p>
<blockquote>
<p><code>fchdir</code>不是基本POSIX.1规范的所属部分，在Single UNIX Specification中，它是XSI扩展部分。</p>
</blockquote>
<p>因为当前工作目录是进程的一个属性，所以它只影响调用<code>chdir</code>的进程本身，而不影响其他进程。</p>
<p>chdir函数示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (chdir(<span class="string">"/tmp"</span>) &lt; <span class="number">0</span>)</div><div class="line">         err_sys(<span class="string">"chdir failed"</span>);</div><div class="line">     <span class="built_in">printf</span>(<span class="string">"chdir to /tmp succeeded\n"</span>);</div><div class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果编译执行上述程序，并且调用其可执行目标代码文件<code>mycd</code>，则可以得到下列结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">pwd</span></div><div class="line">/usr/lib</div><div class="line">$ mycd</div><div class="line"><span class="built_in">chdir</span> to /tmp succeeded</div><div class="line">$ <span class="built_in">pwd</span></div><div class="line">/usr/lib</div></pre></td></tr></table></figure></p>
<p>从中可以看出，执行<code>mycd</code>程序的shell的当前工作目录并没有改变，其原因是shell创建了一个子进程，由该子进程具体执行<code>mycd</code>程序。由此可见，为了改变shell进程自己的工作目录，shell应当直接调用<code>chdir</code>函数，为此 <code>cd</code> 命令的执行程序直接包含在shell程序中（内建命令）。</p>
<p>因为内核保持有当前工作目录的信息，所以我们应能取其当前值。不幸的是，内核为每个进程只保存指向该目录 <code>v</code> 节点的指针等目录本身的信息，并不保存该目录的完整路径名。</p>
<p>我们需要一个函数，它从当前工作目录（ <code>.</code> 目录 ）开始，用 <code>..</code> 目录项找到其上一级目录，然后读其目录项，直到该目录项中的 <code>i</code> 节点编号与工作目录 <code>i</code> 节点编号相同，这样就找到了其对应的文件名。按照这种方法，逐层上移，直到遇到根（ <code>/</code> ），这样就得到了当前工作目录完整的绝对路径名。很幸运，函数<code>getcwd</code>就提供了这种功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</div><div class="line"></div><div class="line">    Returns: buf <span class="keyword">if</span> OK, <span class="literal">NULL</span> on error</div></pre></td></tr></table></figure></p>
<p>向此函数传递两个参数，一个是缓冲地址<code>buf</code>，另一个是缓冲的长度<code>size</code>（单位：字节）。该缓冲必须有足够的长度以容纳绝对路径名再加上一个<code>null</code>终止符，否则返回出错。</p>
<p><code>getcwd</code>函数使用示例：将工作目录更改至一个指定的目录，然后调用<code>getcwd</code>，最后打印该工作目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span>    *ptr;</div><div class="line">    <span class="keyword">int</span>     size;</div><div class="line">    <span class="keyword">if</span> (chdir(<span class="string">"/usr/spool/uucppublic"</span>) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"chdir failed"</span>);</div><div class="line"></div><div class="line">    ptr = path_alloc(&amp;size); <span class="comment">/* our own function */</span></div><div class="line">    <span class="keyword">if</span> (getcwd(ptr, size) == <span class="literal">NULL</span>)</div><div class="line">        err_sys(<span class="string">"getcwd failed"</span>);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"cwd = %s\n"</span>, ptr);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行上述程序，可得：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./a.out</div><div class="line">cwd = /var/spool/uucppublic</div><div class="line">$ ls <span class="_">-l</span> /usr/spool</div><div class="line">lrwxrwxrwx 1 root 12 Jan 31 07:57 /usr/spool -&gt; ../var/spool</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，<code>chdir</code>跟随符号链接，但是当<code>getcwd</code>沿目录树上溯到<code>/var/spool</code>目录时，它并不了解该目录由符号链接<code>/usr/spool</code>所指向。这是符号链接的一种特性。</p>
</blockquote>
<p>当一个应用程序需要在文件系统中返回到其工作的起点时，<code>getcwd</code>函数是有用的。在更换工作目录之前，可以调用<code>getcwd</code>函数先将其保存起来。在完成了处理后，就可将从<code>getcwd</code>获得的路径名作为调用参数传送给<code>chdir</code>，这样就返回到了文件系统中的起点。<br><code>fchdir</code>函数提供了一种完成此任务的便捷方法。在更换到文件系统中的不同位置前，无需调用<code>getcwd</code>函数，而是使用<code>open</code>打开当前工作目录，然后保存文件描述符。当希望回到原工作目录时，只需要简单的将该文件描述符传递给<code>fchdir</code>。</p>
<h2 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h2><p><code>st_dev</code>和<code>st_rdev</code>这两个字段经常引起混淆，而使用这两个字段，有关规则很简单：</p>
<ul>
<li>每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序，次设备号标识特定的子设备。磁盘驱动器经常包含若干个文件系统，在同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但它们的次设备号却不同。</li>
<li>通常可以使用两个宏<code>major</code>和<code>minor</code>来访问主、次设备号，大多数实现都定义了这两个宏。这就意味着无需关心这两个数是如何存放在<code>dev_t</code>对象中的。</li>
<li>系统中与每个文件名关联的<code>st_dev</code>值是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的<code>i</code>节点。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值。此值包含实际设备的设备号。</li>
</ul>
<blockquote>
<p>POSIX.1说明<code>dev_t</code>类型是存在的，但没有定义它包含什么，或如何取得其内容。大多数实现定义了宏<code>major</code>和<code>minor</code>，但在哪一个头文件中定义它们则与实现有关。基于BSD的UNIX系统将它们定义在&lt;sys/types.h&gt;中；Solaris将它们定义在&lt;sys/mkdev.h&gt;中；Linux将它们定义在&lt;sys/sysmacros.h&gt;中，而该头文件又包括在&lt;sys/types.h&gt;中。</p>
</blockquote>
<p>下面来看一个实例：打印<code>st_dev</code>和<code>st_rdev</code>值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SOLARIS</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mkdev.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span>         i;</div><div class="line">    <span class="keyword">struct</span> stat buf;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%s: "</span>, argv[i]);</div><div class="line">        <span class="keyword">if</span> (stat(argv[i], &amp;buf) &lt; <span class="number">0</span>) &#123;</div><div class="line">            err_ret(<span class="string">"stat error"</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="built_in">printf</span>(<span class="string">"dev = %d/%d"</span>, major(buf.st_dev), minor(buf.st_dev));</div><div class="line">         <span class="keyword">if</span> (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) &#123;</div><div class="line">             <span class="built_in">printf</span>(<span class="string">" (%s) rdev = %d/%d"</span>,</div><div class="line">                     (S_ISCHR(buf.st_mode)) ? <span class="string">"character"</span> : <span class="string">"block"</span>,</div><div class="line">                     major(buf.st_rdev), minor(buf.st_rdev));</div><div class="line"></div><div class="line">         &#125;</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行此程序得到下面的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ ./a.out / /home/sar /dev/tty[01]</div><div class="line">/: dev = 3/3</div><div class="line">/home/sar: dev = 3/4</div><div class="line">/dev/tty0: dev = 0/7 (character) rdev = 4/0</div><div class="line">/dev/tty1: dev = 0/7 (character) rdev = 4/1</div><div class="line">$ mount             <span class="comment">#which directories are mounted on which devices?</span></div><div class="line">/dev/hda3 on / <span class="built_in">type</span> ext2 (rw,noatime)</div><div class="line">/dev/hda4 on /home <span class="built_in">type</span> ext2 (rw,noatime)</div><div class="line">$ ls <span class="_">-l</span>L /dev/tty[01] /dev/hda[34]</div><div class="line">brw-------  1 root       3,   3 Dec 31  1969 /dev/hda3</div><div class="line">brw-------  1 root       3,   4 Dec 31  1969 /dev/hda4</div><div class="line">crw-------  1 root       4,   0 Dec 31  1969 /dev/tty0</div><div class="line">crw-------  1 root       4,   1 Jan 18 15:36 /dev/tty1</div></pre></td></tr></table></figure></p>
<p>传递给该程序的前两个参数是目录（<code>/</code> 和 <code>/home/sar</code>），后两个是设备名<code>/dev/tty[01]</code>。（用shell正则表达式语言以缩短设备名，shell将扩展该字符串<code>/dev/tty[01]</code>为<code>/dev/tty0</code> <code>/dev/tty1</code>）<br>这两个设备是字符特殊设备。从程序的输出可见，根目录<code>(/)</code>和<code>/home/sar</code>目录的设备号不同，这表示它们位于不同的文件系统中。运行<code>mount</code>命令证明了这一点。<br>然后用<code>ls</code>命令查看由<code>mount</code>命令报告的两个磁盘设备和两个终端设备。这两个磁盘设备是块特殊文件，而两个终端设备则是字符特殊文件。<br>注意，两个终端设备（<code>st_dev</code>）的文件名和<code>i</code>节点在设备<code>0/7</code>上（<code>devfs</code>伪文件系统，它实现了<code>/dev</code>文件系统），但是它们的实际设备号是<code>4/0</code>和<code>4/1</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章内容围绕<code>stat</code>函数，详细介绍了<code>stat</code>结构中的每一个成员。这使我们对UNIX文件的各个属性都有所了解。对于文件的所有属性以及操作文件的所有函数有完整的了解对UNIX编程是非常重要的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文件 I/O]]></title>
      <url>https://jarsonfang.github.io/programming/APUE/file-io/</url>
      <content type="html"><![CDATA[<p>原文参考：<a href="http://www.cnblogs.com/CoreyGao/archive/2013/04/21/3031414.html" target="_blank" rel="external">APUE读书笔记 之 文件I/O</a><br>文章中的英文图片都引用自：<a href="http://infohost.nmt.edu/~eweiss/222_book/222_book/0201433079/toc.html" target="_blank" rel="external">http://infohost.nmt.edu/~eweiss/222_book/222_book/0201433079/toc.html</a><br>中文图片为（CoreyGao）原创，用Xmind所画。<br><a id="more"></a></p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>UNIX下“一切皆文件”，UNIX下的I/O即对文件的操作。<br>APUE将基本I/O相关内容分为 不带缓冲的I/O，文件和目录，标准I/O库 和 系统数据文件和信息。<br>不带缓冲的I/O和标准I/O库 描述了最基本的I/O。 文件和目录，数据系统文件和信息 描述了UNIX基本的文件系统和权限控制。</p>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><p>文件I/O都是不带缓冲的I/O。不带缓冲的I/O是指在用户空间不缓冲的I/O操作，每一个<code>read</code>和<code>write</code>都调用内核中的一个系统调用。UNIX系统中的大多数文件I/O只需用到5个函数：<code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>以及<code>close</code>。</p>
<p><strong>文件I/O部分可以概括为两个图：</strong></p>
<p>图1 是文件I/O的常用函数总结。文件I/O函数的核心是文件描述符。</p>
<p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或写一个文件时，使用<code>open</code>或<code>create</code>返回的文件描述符标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。UNIX惯例：<code>0</code>是标准输入，<code>1</code>是标准输出，<code>2</code>是标准出错输出。POSIX标准中，幻数<code>0</code>、<code>1</code>、<code>2</code>替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code> 和 <code>STDERR_FILENO</code>，这些常量定义在头文件&lt;unistd.h&gt;中。</p>
<img src="/programming/APUE/file-io/file-io.png" alt="图1 文件I/O的常用函数" title="图1 文件I/O的常用函数">
<p>图2 是内核用于所有I/O的数据结构。</p>
<p><code>fd flags</code> 只有一种：<code>fd_cloexec</code>（用于执行<code>exec</code>后是否保持该<code>fd</code>)<br><code>fd</code>是进程独享的，<code>file table</code>和<code>v-node table</code>都是进程间共享的。<code>dup</code>之后的俩<code>fd</code>共享<code>file table</code>，但是不复制<code>fd flags</code>。</p>
<img src="/programming/APUE/file-io/file-share.gif" alt="图2 打开文件的内核数据结构" title="图2 打开文件的内核数据结构">
<p>内核使用三种数据结构表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。<br>（1）每个进程在进程表中都有一个记录项，记录项中包含有一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个描述符相关联的是：</p>
<ol>
<li>文件描述符标志（close_on_exec）</li>
<li>指向一个文件表项的指针</li>
</ol>
<p>（2）内核为所有打开文件维持一张文件表。每个文件表项包含：</p>
<ol>
<li>文件状态标志（读、写、添写、同步和非阻塞等）</li>
<li>当前文件偏移量</li>
<li>指向该文件 <code>v</code> 节点表项的指针</li>
</ol>
<p>（3）每个打开文件（或设备）都有一个 <code>v</code> 节点（<code>v-node</code>）结构。<code>v</code> 节点包含了文件类型和对此文件进行各种操作的函数的指针。对于大多数文件，<code>v</code> 节点还包含了该文件的 <code>i</code> 节点（<code>i-node</code>，索引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以关于文件的信息都是快速可供使用的。例如， <code>i</code> 节点包含了文件的所有者、文件长度、文件所在的设备、指向文件实际数据块在磁盘上所在位置的指针等。（注：linux没有使用 <code>v</code> 节点，而是使用了通用 <code>i</code> 节点结构，虽然两种实现有所不同，但在概念上，<code>v</code> 节点与 <code>i</code> 节点是一样的。两者都是指向文件系统特有的 <code>i</code> 节点结构。）</p>
<p>如果两个独立进程各自打开了同一个文件，则有图2-1中所示的安排。我们假定第一个进程在文件描述符<code>3</code>上打开该文件，而另一个进程在文件描述符<code>4</code>上打开该文件。打开该文件的每个进程都得到一个文件表项，但对一个给定的文件只有一个 <code>v</code> 节点表项。<span style="color:red;">每个进程都有自己的文件表项的一个理由是：这种安排使每个进程都有它自己的对该文件的当前偏移量。</span></p>
<img src="/programming/APUE/file-io/file-share2.gif" alt="图2-1 两个独立进程各自打开同一个文件" title="图2-1 两个独立进程各自打开同一个文件">
<h2 id="I-O函数"><a href="#I-O函数" class="headerlink" title="I/O函数"></a>I/O函数</h2><p><strong>open</strong>函数：打开或创建一个文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</div><div class="line"></div><div class="line">    Returns: file descriptor <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>第三个参数写为 <code>...</code> ，ISO C 用这种方法表明余下参数的数量及其类型根据具体的调用会有所不同。对于<code>open</code>函数而言，仅当创建新文件时才使用第三个参数。在函数原型中将此参数放置在注释中。<br><code>pathname</code>表示要打开或创建文件的名字，<code>oflag</code>参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成<code>oflag</code>参数（这些常量定义在&lt;fcntl.h&gt;头文件中）：</p>
<table>
<thead>
<tr>
<th>oflag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>只读打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读、写打开</td>
</tr>
</tbody>
</table>
<p>在这三个常量中必须指定一个且只能指定一个。下列常量则是可选的：</p>
<table>
<thead>
<tr>
<th>oflag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_APPEND</td>
<td>每次写时都追加到文件的尾端。</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>若此文件不存在，则创建它。使用此选项时，需要第三个参数<code>mode</code>，用其指定该新文件的访问权限</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果同时指定了<code>O_CREAT</code>，而文件已经存在，则会出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果此文件存在，而且为只写或读写成功打开，则将其长度截短为0。</td>
</tr>
<tr>
<td>O_NOCTTY</td>
<td>如果<code>pathname</code>指的是终端设备，则不将该设备分配作为此进程的控制终端。</td>
</tr>
<tr>
<td>O_NONBLOCK</td>
<td>如果<code>pathname</code>指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置非阻塞模式</td>
</tr>
</tbody>
</table>
<p>下面三个标志也是可选的。它们是Single UNIX Specification (以及POSIX.1) 中同步输入和输出选项的一部分。</p>
<table>
<thead>
<tr>
<th>oflag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_DSYNC</td>
<td>使每次<code>write</code>等待物理I/O操作完成，但是如果写操作并不影响读取刚写入的数据，则不等待文件属性被更新。</td>
</tr>
<tr>
<td>O_RSYNC</td>
<td>使每一个以文件描述符作为参数的<code>read</code>操作等待，直至任何对文件同一部分进行的未决写操作都完成。</td>
</tr>
<tr>
<td>O_SYNC</td>
<td>使每次<code>write</code>都等待物理I/O操作完成，包括由<code>write</code>操作引起的文件属性更新所需的I/O。</td>
</tr>
</tbody>
</table>
<p>由<code>open</code>返回的文件描述符一定是最小的未用描述符数值。这一点被某些应用程序用来在标准输入、标准输出或标准出错输出上打开新的文件。例如，一个应用程序可以先关闭标准输出（通常是文件描述符<code>1</code>），然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符<code>1</code>上打开。使用 <code>dup2</code> 函数可以更好的保证在一个给定的描述符上打开一个文件。</p>
<p><strong>creat</strong>函数：创建一个新文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</div><div class="line"></div><div class="line">    Returns: file descriptor opened <span class="keyword">for</span> write-only <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>此函数等效于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</div></pre></td></tr></table></figure></p>
<p>在早期的UNIX系统版本中，<code>open</code>的第二个参数只能是<code>0</code>、<code>1</code>或<code>2</code>，没有办法打开一个尚未存在的文件，因此需要另一个系统调用<code>creat</code>以创建新文件。现在，<code>open</code>函数提供了选项<code>O_CREAT</code>和<code>O_TRUNC</code>，于是也就不再需要<code>creat</code>函数了。</p>
<p><strong>close</strong>函数：关闭一个打开的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有打开的文件。很多程序都利用了这一功能而不显式地用<code>close</code>关闭打开的文件。</p>
<p><strong>lseek</strong>函数：显式地为一个打开的文件设置其偏移量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> filedes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</div><div class="line"></div><div class="line">    Returns: <span class="keyword">new</span> file offset <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>每个打开的文件都有一个与其相关联的“当前文件偏移量(<code>current file offset</code>)”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为<code>0</code>。</p>
<p>对参数<code>offset</code>的解释与参数<code>whence</code>的值有关。</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK_CUR</code>，则将该文件的偏移量设置为其当前值加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可为正或负。</li>
</ul>
<p>若<code>lseek</code>成功执行，则返回新的文件偏移量，为此可以用下列方式确定打开文件的当前偏移量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">off_t</span> currpos;</div><div class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</div></pre></td></tr></table></figure></p>
<p>这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符引用的是一个管道、FIFO或网络套接字，则<code>lseek</code>返回 <code>-1</code>，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<p>通常，文件的当前偏移量应当是一个非负整数，但是，某些设备也可能允许负的偏移量。但对于普通文件，则其偏移量必须是非负值。因为偏移量可能是负值，所以在比较<code>lseek</code>的返回值时应当谨慎，不要测试它是否小于<code>0</code>，而要测试它是否等于 <code>-1</code>。</p>
<p><code>lseek</code>仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作。然后，该偏移量用于下一个读或写操作。文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为<code>0</code>。文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<p><strong>read</strong>函数：从打开的文件中读数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</div><div class="line"></div><div class="line">    Returns: number of bytes read, <span class="number">0</span> <span class="keyword">if</span> end of file, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>如果<code>read</code>成功，则返回读到的字节数。如已到达文件结尾，则返回<code>0</code>。有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读普通文件，在读到要求字节数之前已到达了文件尾端。</li>
<li>读终端设备，通常一次最多读一行。</li>
<li>读网络套接字，网络中的缓冲机制可能造成返回值小于所要求读的字节数。</li>
<li>读管道或FIFO，如若管道包含的字节少于所需的数量，那么<code>read</code>将只返回实际可用的字节数。</li>
<li>读某些面向记录的设备，一次最多返回一条记录。</li>
<li>当某一信号造成中断，而已经读了部分数据量时。</li>
</ul>
<p>读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man 2 <span class="built_in">read</span></div></pre></td></tr></table></figure></p>
<p>查看<code>read</code>系统调用帮助文档。</p>
<p><code>readn</code>函数：从打开的文件中读取 <code>n</code> 字节数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span>             <span class="comment">/* Read "n" bytes from a descriptor  */</span></div><div class="line">readn(<span class="keyword">int</span> fd, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span>      nleft;</div><div class="line">    <span class="keyword">ssize_t</span>     nread;</div><div class="line"></div><div class="line">    nleft = n;</div><div class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nleft == n)</div><div class="line">                <span class="keyword">return</span>(<span class="number">-1</span>); <span class="comment">/* error, return -1 */</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;      <span class="comment">/* error, return amount read so far */</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;          <span class="comment">/* EOF */</span></div><div class="line">        &#125;</div><div class="line">        nleft -= nread;</div><div class="line">        ptr   += nread;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>(n - nleft);      <span class="comment">/* return &gt;= 0 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>write</strong>函数：向打开的文件写数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</div><div class="line"></div><div class="line">    Returns: number of bytes written <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>其返回值通常与参数<code>nbytes</code>的值相同，否则表示出错。<code>write</code>出错的一个常见原因是：磁盘已写满，或者超过了一个给定进程的文件长度限制。<br>对于普通文件，写操作从文件的当前偏移量处开始。如果打开该文件时，指定了<code>O_APPEND</code>选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">man 2 write</div></pre></td></tr></table></figure></p>
<p>查看<code>write</code>系统调用帮助文档。</p>
<p><code>writen</code>函数：向打开的文件写入 <code>n</code> 字节数据<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span>             <span class="comment">/* Write "n" bytes to a descriptor  */</span></div><div class="line">writen(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> n)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span>      nleft;</div><div class="line">    <span class="keyword">ssize_t</span>     nwritten;</div><div class="line"></div><div class="line">    nleft = n;</div><div class="line">    <span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((nwritten = write(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (nleft == n)</div><div class="line">                <span class="keyword">return</span>(<span class="number">-1</span>); <span class="comment">/* error, return -1 */</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;      <span class="comment">/* error, return amount written so far */</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nwritten == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        nleft -= nwritten;</div><div class="line">        ptr   += nwritten;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>(n - nleft);      <span class="comment">/* return &gt;= 0 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>pread</strong>和<strong>pwrite</strong>函数：在给定的文件偏移处从文件读取或向文件写入数据。<br>Single UNIX Specification包括了XSI扩展，该扩展允许原子性的定位搜索（seek）和执行I/O。<code>pread</code>和<code>pwrite</code>就是这种扩展。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> filedes, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</div><div class="line"></div><div class="line">    Returns: number of bytes read, <span class="number">0</span> <span class="keyword">if</span> end of file, <span class="number">-1</span> <span class="function">on error</span></div><div class="line"></div><div class="line">ssize_t <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> filedes, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span>;</div><div class="line"></div><div class="line">    Returns: number of bytes written <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于顺序调用<code>lseek</code>和<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别：</p>
<ul>
<li>调用<code>pread</code>时，无法中断其定位和读操作</li>
<li>不更新文件指针</li>
</ul>
<p>调用<code>pwrite</code>相当于顺序调用<code>lseek</code>和<code>write</code>，但也与它们有类似的区别。</p>
<p><strong>dup</strong>和<strong>dup2</strong>函数：复制一个现存的文件描述符。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</div><div class="line"></div><div class="line">    Both <span class="keyword">return</span>: <span class="keyword">new</span> file descriptor <span class="keyword">if</span> OK, <span class="number">-1</span> on error</div></pre></td></tr></table></figure></p>
<p>由<code>dup</code>返回的新文件描述符一定是当前可用文件描述符中的最小数值。用<code>dup2</code>则可以用<code>newfd</code>参数指定新描述符的数值。如果<code>newfd</code>已经打开，则先将其关闭。</p>
<ul>
<li>如果<code>oldfd</code>是无效的文件描述符，则调用失败，<code>newfd</code>不会被关闭。</li>
<li>如果<code>newfd</code>等于<code>oldfd</code>，则<code>dup2</code>返回<code>newfd</code>，而不关闭它。</li>
</ul>
<p>这些函数返回的新文件描述符与参数<code>oldfd</code>共享同一个文件表项。图3 显示了这种情况。<br>在此图中，假定进程执行了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newfd = dup(<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>当此函数开始执行时，假定下一个可用的描述符是<code>3</code>。因为两个描述符指向同一文件表项，所以它们共享同一文件状态标志（读、写、添写等）以及同一当前文件偏移量。<br>每个文件描述符都有它自己的一套文件描述符标志，但新描述符的执行时关闭（close-on-exec）标志总是由<code>dup</code>函数清除。</p>
<img src="/programming/APUE/file-io/dup.gif" alt="图3 执行dup后的内核数据结构" title="图3 执行dup后的内核数据结构">
<p>复制一个描述符的另一种方法是使用<code>fcntl</code>函数，实际上，调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup(oldfd);</div></pre></td></tr></table></figure></p>
<p>等效于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fcntl(oldfd, F_DUPFD, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>而调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dup2(oldfd, newfd);</div></pre></td></tr></table></figure></p>
<p>等效于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close(newfd);</div><div class="line">fcntl(oldfd, F_DUPFD, newfd);</div></pre></td></tr></table></figure></p>
<p>后一种情况，<code>dup2</code>并不完全等同于<code>close</code>加上<code>fcntl</code>。它们之间的区别是：<br>（1）<code>dup2</code>是一个原子操作，而<code>close</code>及<code>fcntl</code>则包括两个函数调用。有可能在<code>close</code>和<code>fcntl</code>之间插入执行信号捕获函数，它可能修改文件描述符。<br>（2）<code>dup2</code>和<code>fcntl</code>有某些不同的<code>errno</code>。</p>
<p><strong>sync</strong>、<strong>fsync</strong>和<strong>fdatasync</strong>函数</p>
<p>传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将数据复制到其中的一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为<span style="color:red;">延迟写</span>。<br>延迟写减少了磁盘读写次数，但是降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟写可能造成文件更新内容的丢失。为保证磁盘上实际文件系统与缓冲区高速缓存中内容一致，UNIX系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> filedes)</span></span>;</div><div class="line"></div><div class="line">    Returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> <span class="function">on error</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span>;</div></pre></td></tr></table></figure></p>
<p><code>sync</code> 函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。通常称为<code>update</code>的系统守护进程会周期性地（一般每隔30秒）调用<code>sync</code>函数，这就保证了定期冲洗内核的块缓冲区。命令<code>sync</code>也调用<code>sync</code>函数。<br><code>fsync</code> 函数只对由文件描述符<code>filedes</code>指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。<code>fsync</code>可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。<br><code>fdatasync</code> 函数类似于<code>fsync</code>，但它只影向文件的数据部分。而除数据外，<code>fsync</code>还会同步更新文件的属性。</p>
<p><strong>fcntl</strong>函数：改变已打开文件的性质。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;fcntl.h&gt;</div><div class="line"></div><div class="line">int fcntl(int filedes, int cmd, ... /* arg */ );</div><div class="line"></div><div class="line">    Returns: depends on cmd if OK (see following), -1 on error</div></pre></td></tr></table></figure></p>
<p><code>fcntl</code>函数有5种功能：<br>（1）复制一个现有的描述符（<code>cmd = F_DUPFD</code>）。<br>（2）获得/设置文件描述符标志（<code>cmd = F_GETFD</code> 或 <code>F_SETFD</code>）。<br>（3）获得/设置文件状态标志（<code>cmd = F_GETFL</code> 或 <code>F_SETFL</code>）。<br>（4）获得/设置异步I/O所有权（<code>cmd = F_GETOWN</code> 或 <code>F_SETOWN</code>）。<br>（5）获得/设置记录锁（<code>cmd = F_GETLK</code>、<code>F_SETLK</code> 或 <code>F_SETLKW</code>）。<br>前4种功能中（<code>cmd</code>值中的前7种），第三个参数<code>arg</code>是一个整型数。<code>cmd</code>值中的后3种，都与记录锁有关，此时函数的第三个参数<code>arg</code>指向一个结构的指针。</p>
<table>
<thead>
<tr>
<th>cmd</th>
<th>Descriptiong</th>
</tr>
</thead>
<tbody>
<tr>
<td>F_DUPFD</td>
<td>复制文件描述符<code>filedes</code>，新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第三个参数值（取为整型值）中各值的最小值。新描述符与<code>filedes</code>共享同一文件表项，但是，新描述符有它自己的一套文件描述符标志，其<code>FD_CLOSEXEC</code>文件描述符标志被清除</td>
</tr>
<tr>
<td>F_GETFD</td>
<td>对应于<code>filedes</code>的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志<code>F_CLOSEXEC</code>。</td>
</tr>
<tr>
<td>F_SETFD</td>
<td>对于<code>filedes</code>设置文件描述符标志。新标志值按第三个参数（取为整型值）设置。</td>
</tr>
<tr>
<td>F_GETFL</td>
<td>对应于<code>filedes</code>的文件状态标志作为函数值返回，文件状态标志对应于<code>open</code>函数中的<code>flags</code>参数。</td>
</tr>
<tr>
<td>F_SETFL</td>
<td>将文件状态标志设置为第三个参数的值（取为整型值）。可以更改的几个标志是：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>（等待写完成，包括数据和属性）、<code>O_DSYNC</code>（等待写完成，仅数据） 和<code>O_RSYNC</code>（同步读、写）</td>
</tr>
<tr>
<td>F_GETOWN</td>
<td>获取当前接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID</td>
</tr>
<tr>
<td>F_SETOWN</td>
<td>设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID或进程组ID。正的<code>arg</code>指定一个进程ID，负的<code>arg</code>表示等于<code>arg</code>绝对值的一个进程组ID。</td>
</tr>
</tbody>
</table>
<p><code>fcntl</code>的返回值与命令有关。如果出错，所有命令都返回<code>-1</code>,如果成功则返回某个其他值。下列四个命令有特定返回值：<code>F_DUPFD</code>、<code>F_GETFD</code>、<code>F_GETFL</code>以及<code>F_GETOWN</code>。第一个返回新的文件描述符，接下来两个返回相应标志，最后一个返回一个正的进程ID或负的进程组ID。</p>
<p>在修改文件描述符标志或文件状态标志时必须谨慎，先要取得现有的标志值，然后根据需要修改它，最后设置新标志值。不能只是执行<code>F_SETFD</code>或<code>F_SETFL</code>命令，这样会关闭以前设置的标志位。<br>下面代码显示了一个对一个文件描述符设置一个或多个文件状态标志的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span>     val;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"fcntl F_GETFL error"</span>);</div><div class="line"></div><div class="line">    val |= flags;       <span class="comment">/* turn on flags */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</div><div class="line">        err_sys(<span class="string">"fcntl F_SETFL error"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果将中间的一条语句改为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">val &amp;= ~flags;  <span class="comment">/* turn flags off */</span></div></pre></td></tr></table></figure></p>
<p>就构成另一个函数，称其为 <code>clr_fl</code> 。此语句使当前文件状态标志值<code>val</code>与<code>flags</code>的补码进行逻辑“与”运算。</p>
<p><strong>ioctl</strong>函数：I/O操作的杂物箱。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>主要用于设备驱动程序，终端I/O是<code>ioctl</code>的最大使用方面。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核环形队列kfifo]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/kfifo/</url>
      <content type="html"><![CDATA[<p>Linux kernel 里面从来就不缺少简洁，优雅和高效的代码，只是我们缺少发现和品味的眼光。在Linux kernel里面，简洁并不表示代码使用神出鬼没的超然技巧，相反，它使用的不过是大家非常熟悉的基础数据结构，但是kernel开发者能从基础的数据结构中，提炼出优美的特性。</p>
<p><code>kfifo</code>就是这样的一类优美代码，它十分简洁，绝无多余的一行代码，却非常高效。<br>关于kfifo信息如下：<br><span style="color:blue;"><br>本文分析的原代码版本：2.6.25<br>kfifo的定义文件：kernel/kfifo.c<br>kfifo的头文件：include/linux/kfifo.h<br></span><br><a id="more"></a></p>
<h2 id="kfifo概述"><a href="#kfifo概述" class="headerlink" title="kfifo概述"></a>kfifo概述</h2><p><code>kfifo</code>是内核里面的一个First In First Out数据结构，它采用环形循环队列的数据结构来实现；它提供一个无边界的字节流服务，最重要的一点是，它使用并行无锁编程技术，即当它用于只有一个入队线程和一个出队线程的场情时，两个线程可以并发操作，而不需要任何加锁行为，就可以保证<code>kfifo</code>的线程安全。</p>
<p><code>kfifo</code>代码既然肩负着这么多特性，那我们先一瞥它的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kfifo &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;  <span class="comment">/* the buffer holding the data */</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* the size of the allocated buffer */</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> in;        <span class="comment">/* data is added at offset (in % size) */</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> out;       <span class="comment">/* data is extracted from off. (out % size) */</span></div><div class="line">        <span class="keyword">spinlock_t</span> *lock;       <span class="comment">/* protects concurrent modifications */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是<code>kfifo</code>的数据结构，<code>kfifo</code>主要提供了两个操作，<code>__kfifo_put</code>(入队操作)和<code>__kfifo_get</code>(出队操作)。 它的各个数据成员如下：<br><code>buffer</code> 用于存放数据的缓存<br><code>size</code>   buffer空间的大小，在初化时，将它向上扩展成2的幂<br><code>lock</code>   如果使用不能保证任何时间最多只有一个读线程和写线程，需要使用该lock实施同步。<br><code>in</code>,<code>out</code>和<code>buffer</code>一起构成一个循环队列。 <code>in</code>指向<code>buffer</code>中队头，而且<code>out</code>指向<code>buffer</code>中的队尾，它的结构如示图如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+--------------------------------------------------------------+</div><div class="line">|           |&lt;----------data----------&gt;|                       |</div><div class="line">+--------------------------------------------------------------+</div><div class="line">            ^                          ^</div><div class="line">            |                          |</div><div class="line">            in                         out</div></pre></td></tr></table></figure></p>
<p>当然，内核开发者使用了一种更好的技术处理了<code>in</code>,<code>out</code>和<code>buffer</code>的关系，我们将在下面进行详细的分析。</p>
<h2 id="kfifo-内存分配和初始化工作"><a href="#kfifo-内存分配和初始化工作" class="headerlink" title="kfifo 内存分配和初始化工作"></a>kfifo 内存分配和初始化工作</h2><p><strong>kfifo_alloc</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_alloc - allocates a new FIFO and its internal buffer</div><div class="line"> * @size: the size of the internal buffer to be allocated.</div><div class="line"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</div><div class="line"> * @lock: the lock to be used to protect the fifo buffer</div><div class="line"> *</div><div class="line"> * The size will be rounded-up to a power of 2.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">struct</span> kfifo *<span class="title">kfifo_alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</div><div class="line">        <span class="keyword">struct</span> kfifo *ret;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * round up to the next power of 2, since our 'let the indices</div><div class="line">         * wrap' tachnique works only in this case.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (size &amp; (size - <span class="number">1</span>)) &#123;  <span class="comment">/* size must be a power of 2 */</span></div><div class="line">                BUG_ON(size &gt; <span class="number">0x80000000</span>);</div><div class="line">                size = roundup_pow_of_two(size);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        buffer = kmalloc(size, gfp_mask);</div><div class="line">        <span class="keyword">if</span> (!buffer)</div><div class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</div><div class="line"></div><div class="line">        ret = kfifo_init(buffer, size, gfp_mask, lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (IS_ERR(ret))</div><div class="line">                kfree(buffer);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(kfifo_alloc);</div></pre></td></tr></table></figure></p>
<p>这里值得一提的是，<code>kfifo-&gt;size</code>的值总是在调用者传进来的<code>size</code>参数的基础上向2的幂扩展，这是内核一贯的做法。这样的好处不言而喻 —— 对<code>kfifo-&gt;size</code> <span style="color:red;">取模</span>运算可以转化为<span style="color:red;">与</span>运算，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kfifo-&gt;in % kfifo-&gt;size</div></pre></td></tr></table></figure></p>
<p>可以转化为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kfifo-&gt;in &amp; (kfifo-&gt;size – <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>在<code>kfifo_alloc</code>函数中，使用<code>size &amp; (size – 1)</code>来判断<code>size</code>是否为 2 的幂，如果条件为真，则表示<code>size</code>不是 2 的幂，然后调用<code>roundup_pow_of_two</code>将之向上扩展为 2 的幂。 这些都是很常用的技巧，只不过大家没有将它们结合起来使用而已，下面要分析的 <code>__kfifo_put</code>和<code>__kfifo_get</code>则是将<code>kfifo-&gt;size</code>的特点发挥到了极致。</p>
<p><strong>kfifo_init</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_init - allocates a new FIFO using a preallocated buffer</div><div class="line"> * @buffer: the preallocated buffer to be used.</div><div class="line"> * @size: the size of the internal buffer, this have to be a power of 2.</div><div class="line"> * @gfp_mask: get_free_pages mask, passed to kmalloc()</div><div class="line"> * @lock: the lock to be used to protect the fifo buffer</div><div class="line"> *</div><div class="line"> * Do NOT pass the kfifo to kfifo_free() after use! Simply free the</div><div class="line"> * &amp;struct kfifo with kfree().</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">struct</span> kfifo *<span class="title">kfifo_init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> size,</span></span></div><div class="line">                         <span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">spinlock_t</span> *lock)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> kfifo *fifo;</div><div class="line"></div><div class="line">        <span class="comment">/* size must be a power of 2 */</span></div><div class="line">        BUG_ON(!is_power_of_2(size));</div><div class="line"></div><div class="line">        fifo = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kfifo), gfp_mask);</div><div class="line">        <span class="keyword">if</span> (!fifo)</div><div class="line">                <span class="keyword">return</span> ERR_PTR(-ENOMEM);</div><div class="line"></div><div class="line">        fifo-&gt;buffer = buffer;</div><div class="line">        fifo-&gt;size = size;</div><div class="line">        fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</div><div class="line">        fifo-&gt;lock = lock;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> fifo;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(kfifo_init);</div></pre></td></tr></table></figure></p>
<p><strong>kfifo_free</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_free - frees the FIFO</div><div class="line"> * @fifo: the fifo to be freed.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfifo_free</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span></div><div class="line">&#123;</div><div class="line">        kfree(fifo-&gt;buffer);</div><div class="line">        kfree(fifo);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(kfifo_free);</div></pre></td></tr></table></figure></p>
<h2 id="kfifo-put和-kfifo-get，巧妙的入队和出队操作，无锁并发"><a href="#kfifo-put和-kfifo-get，巧妙的入队和出队操作，无锁并发" class="headerlink" title="__kfifo_put和__kfifo_get，巧妙的入队和出队操作，无锁并发"></a><code>__kfifo_put</code>和<code>__kfifo_get</code>，巧妙的入队和出队操作，无锁并发</h2><p><code>__kfifo_put</code>是入队操作，它先将数据放入<code>buffer</code>里面，最后才修改<code>in</code>参数；<code>__kfifo_get</code>是出队操作，它先将数据从<code>buffer</code>中移走，最后才修改<code>out</code>。你会发现<code>in</code>和<code>out</code>两者各司其职。计算机科学家已经证明，当只有一个读经程和一个写线程并发操作时，不需要任何额外的锁，就可以确保是线程安全的，也即<code>kfifo</code>使用了无锁编程技术，以提高kernel的并发。</p>
<p><strong>__kfifo_put</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * __kfifo_put - puts some data into the FIFO, no locking version</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> * @buffer: the data to be added.</div><div class="line"> * @len: the length of the data to be added.</div><div class="line"> *</div><div class="line"> * This function copies at most @len bytes from the @buffer into</div><div class="line"> * the FIFO depending on the free space, and returns the number of</div><div class="line"> * bytes copied.</div><div class="line"> *</div><div class="line"> * Note that with only one concurrent reader and one concurrent</div><div class="line"> * writer, you don't need extra locking to use these functions.</div><div class="line"> */</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_put(<span class="keyword">struct</span> kfifo *fifo,</div><div class="line">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</div><div class="line"></div><div class="line">        len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Ensure that we sample the fifo-&gt;out index -before- we</div><div class="line">         * start putting bytes into the kfifo.</div><div class="line">         */</div><div class="line"></div><div class="line">        smp_mb();</div><div class="line"></div><div class="line">        <span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></div><div class="line">        l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</div><div class="line">        <span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</div><div class="line"></div><div class="line">        <span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></div><div class="line">        <span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Ensure that we add the bytes to the kfifo -before-</div><div class="line">         * we update the fifo-&gt;in index.</div><div class="line">         */</div><div class="line"></div><div class="line">        smp_wmb();</div><div class="line"></div><div class="line">        fifo-&gt;in += len;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(__kfifo_put);</div></pre></td></tr></table></figure></p>
<p><strong>__kfifo_get</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * __kfifo_get - gets some data from the FIFO, no locking version</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> * @buffer: where the data must be copied.</div><div class="line"> * @len: the size of the destination buffer.</div><div class="line"> *</div><div class="line"> * This function copies at most @len bytes from the FIFO into the</div><div class="line"> * @buffer and returns the number of copied bytes.</div><div class="line"> *</div><div class="line"> * Note that with only one concurrent reader and one concurrent</div><div class="line"> * writer, you don't need extra locking to use these functions.</div><div class="line"> */</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_get(<span class="keyword">struct</span> kfifo *fifo,</div><div class="line">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</div><div class="line"></div><div class="line">        len = min(len, fifo-&gt;in - fifo-&gt;out);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Ensure that we sample the fifo-&gt;in index -before- we</div><div class="line">         * start removing bytes from the kfifo.</div><div class="line">         */</div><div class="line"></div><div class="line">        smp_rmb();</div><div class="line"></div><div class="line">        <span class="comment">/* first get the data from fifo-&gt;out until the end of the buffer */</span></div><div class="line">        l = min(len, fifo-&gt;size - (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)));</div><div class="line">        <span class="built_in">memcpy</span>(buffer, fifo-&gt;buffer + (fifo-&gt;out &amp; (fifo-&gt;size - <span class="number">1</span>)), l);</div><div class="line"></div><div class="line">        <span class="comment">/* then get the rest (if any) from the beginning of the buffer */</span></div><div class="line">        <span class="built_in">memcpy</span>(buffer + l, fifo-&gt;buffer, len - l);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Ensure that we remove the bytes from the kfifo -before-</div><div class="line">         * we update the fifo-&gt;out index.</div><div class="line">         */</div><div class="line"></div><div class="line">        smp_mb();</div><div class="line"></div><div class="line">        fifo-&gt;out += len;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> len;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(__kfifo_get);</div></pre></td></tr></table></figure></p>
<p><code>kfifo</code>每次入队或出队，<code>kfifo-&gt;in</code>或<code>kfifo-&gt;out</code>只是简单地<code>kfifo-&gt;in</code> (or)<code>kfifo-&gt;out</code> <code>+= len</code>，并没有对<code>kfifo-&gt;size</code>进行取模运算。因此<code>kfifo-&gt;in</code>和<code>kfifo-&gt;out</code>总是一直增大，直到<code>unsigned in</code> 最大值时，回绕到 0 这一起始端。但始终满足 <code>kfifo-&gt;out &lt; kfifo-&gt;in</code>，除非<code>kfifo-&gt;in</code> 回绕到了 0 的那一端，即使如此，代码中计算长度的性质仍然是保持的。</p>
<p>我们先用简单的例子来形象说明这些性质吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+----------------------------------------+</div><div class="line">|                         |&lt;---data---&gt;| |</div><div class="line">+----------------------------------------+</div><div class="line">                          ^            ^</div><div class="line">                          |            |</div><div class="line">                          out          in</div></pre></td></tr></table></figure></p>
<p>上图的<code>out</code>和<code>in</code>为<code>kfifo-&gt;buffer</code>的出队数据和入队数据的游标，方框为<code>buffer</code> 的内存区域。当有数据入队时，那么<code>in</code>的值可能超过<code>kfifo-&gt;size</code>的值，那么我们使用另一个虚拟的方框来表示<code>in</code>变化后，在<code>buffer</code>内对<code>kfifo-&gt;size</code> 取模的值。如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> 真实的buffer内存                             虚拟的buffer内存，方便查看in对kfifo-&gt;size取模后在buffer的下标</div><div class="line">+----------------------------------------+ +------------------------------------+</div><div class="line">|                          |&lt;---data-----| |---------&gt;|                         |</div><div class="line">+----------------------------------------+ +------------------------------------+</div><div class="line">                           ^                          ^</div><div class="line">                           |                          |</div><div class="line">                           out                        in</div></pre></td></tr></table></figure></p>
<p>当用户调用<code>__kfifo_put</code>函数，入队的数据使<code>kfifo-&gt;in</code> 游标发生如上图所示的变化时，要分两次拷贝内存数据。</p>
<p>因为入队数据，一部存放在<code>kfifo-&gt;buffer</code>的尾部，另一部分存放在<code>kfifo-&gt;buffer</code> 的头部。计算公式非常简单：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">l = kfifo-&gt;size – kfifo-&gt;in &amp; (kfifo-&gt;size – <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>表示<code>in</code>下标到<code>buffer</code>末尾，还有多少空间。</p>
<p>如果<code>len</code>表示需要拷贝的长度的话，那么<code>len - l</code>则表示有多少字节需要拷贝到<code>buffer</code>开始之处。</p>
<p>这样，我们读<code>__kfifo_put</code>代码就很容易了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">len = min(len, fifo-&gt;size - fifo-&gt;in + fifo-&gt;out);</div></pre></td></tr></table></figure></p>
<p><code>fifo-&gt;in – fifo-&gt;out</code>表示队列里面已使用的空间大小，<code>fifo-&gt;size - (fifo-&gt;in – fifo-&gt;out)</code>表示队列未使用的空间，</p>
<p>因此<code>len = min(…)</code>，取两者之小，表示实际要拷贝的字节数。</p>
<p>拷贝<code>len</code>个字符数，<code>fifo-&gt;in</code>到<code>buffer</code>末尾所剩的空间是多少，这里面计算：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* first put the data starting from fifo-&gt;in to buffer end */</span></div><div class="line">l = min(len, fifo-&gt;size - (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)));</div><div class="line"><span class="built_in">memcpy</span>(fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - <span class="number">1</span>)), buffer, l);</div><div class="line"></div><div class="line"><span class="comment">/* then put the rest (if any) at the beginning of the buffer */</span></div><div class="line"><span class="built_in">memcpy</span>(fifo-&gt;buffer, buffer + l, len - l);</div></pre></td></tr></table></figure></p>
<p><code>l</code>表示<code>len</code>或<code>fifo-&gt;in</code>到<code>buffer</code>末尾所剩的空间大小的最小值，因为需要拷贝<code>l</code>字节到 <code>fifo-&gt;buffer + (fifo-&gt;in &amp; (fifo-&gt;size - 1))</code>的位置上；那么剩下要拷贝到<code>buffer</code>开始之处的长度为<code>len – l</code>，当然，此值可能会为0，为 0 时，memcpy函数不进行任何拷贝。</p>
<p>所有的拷贝完成后（可能是一次，也可能是两次 memcpy)，<code>fifo-&gt;in</code> 直接 <code>+= len</code>，不需要取模运算。</p>
<p>写到这里，细心的读者会发现，如果<code>fifo-&gt;in</code>超过了<code>unsigned int</code>的最大值时，而回绕到 0 这一端，上述的计算公式还正确吗？ 答案是肯定的。</p>
<p>因为<code>fifo-&gt;size</code>的大小是 2 的幂，而<code>unsigned int</code>空间的大小是 <code>2^32</code>，后者刚好是前者的倍数。如果从上述两个图的方式来描述，则表示<code>unsigned int</code>空间的数轴上刚好可以划成一定数量个 <code>kfifo-&gt;size</code>大小方框，没有长度多余。这样，<code>fifo-&gt;in</code> (or) <code>fifo-&gt;out</code>对<code>fifo-&gt;size</code>取模后，刚好落后对应的位置上。</p>
<p>现在假设往<code>kfifo</code>加入数据后，使用<code>fifo-&gt;in &lt; fifo-&gt;out</code>关系，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+----------------------------------------+     +------------------------------------+</div><div class="line">|&lt;---data---|                            | ……  |                        |&lt;---data---|</div><div class="line">+----------------------------------------+     +------------------------------------+</div><div class="line">|----------------------------------------------------------------------------------&gt;|</div><div class="line"><span class="number">0</span>                                                                                   <span class="number">0xffffffff</span></div><div class="line">                                               ^                        ^</div><div class="line">                                               |                        |</div><div class="line">                                               in                       out</div></pre></td></tr></table></figure></p>
<p>假设<code>kfifo</code>中数据的长度为<code>ldata</code>，那么<code>fifo-&gt;in</code>和<code>fifo-&gt;out</code>有这样的关系：<code>fifo-&gt;in = fifo-&gt;out + ldata</code>，并且<code>fifo-&gt;in &lt; fifo-&gt;out</code>。这说明<code>fifo-&gt;in</code>回绕到0这一端了，尽管如此，<code>fifo-&gt;in</code>和<code>fifo-&gt;out</code>的差距还是保持的，没有变化。即<code>fifo-&gt;in – fifo-&gt;out</code>仍然是<code>ldata</code>, 那么此时的可用空间是<code>fifo-&gt;size – ldata = fifo-&gt;size - (fifo-&gt;in – fifo-&gt;out) = fifo-&gt;size – fifo-&gt;in + fifo-&gt;out</code>。</p>
<p>因此无论<code>fifo-&gt;in</code>和<code>fifo-&gt;out</code>谁大谁小，计算<code>fifo</code>剩余空间大小的公式<code>fifo-&gt;size – fifo-&gt;in + fifo-&gt;out</code>都正确，故可以保证<code>__kfifo_put</code>函数里面的长度计算均是正确的。</p>
<p><code>__kfifo_get</code>函数使用<code>fifo-&gt;in – fifo-&gt;out</code>来计算<code>fifo</code> 内数据的空间长度，然后拷贝需要出队的数据。是否需要两次拷贝，其中原理和方法都和<code>__kfifo_put</code>是一样的。</p>
<h2 id="kfifo-put-和-kfifo-get"><a href="#kfifo-put-和-kfifo-get" class="headerlink" title="kfifo_put 和 kfifo_get"></a>kfifo_put 和 kfifo_get</h2><p><code>kfifo_put</code>和<code>kfifo_get</code>在调用<code>__kfifo_put</code>和<code>__kfifo_get</code>过程都进行加锁，防止并发。</p>
<p><strong>kfifo_put</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_put - puts some data into the FIFO</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> * @buffer: the data to be added.</div><div class="line"> * @len: the length of the data to be added.</div><div class="line"> *</div><div class="line"> * This function copies at most @len bytes from the @buffer into</div><div class="line"> * the FIFO depending on the free space, and returns the number of</div><div class="line"> * bytes copied.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kfifo_put</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,</span></span></div><div class="line">                                     <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">        spin_lock_irqsave(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        ret = __kfifo_put(fifo, buffer, len);</div><div class="line"></div><div class="line">        spin_unlock_irqrestore(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>kfifo_get</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_get - gets some data from the FIFO</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> * @buffer: where the data must be copied.</div><div class="line"> * @len: the size of the destination buffer.</div><div class="line"> *</div><div class="line"> * This function copies at most @len bytes from the FIFO into the</div><div class="line"> * @buffer and returns the number of copied bytes.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kfifo_get</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,</span></span></div><div class="line">                                     <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">        spin_lock_irqsave(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        ret = __kfifo_get(fifo, buffer, len);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * optimization: if the FIFO is empty, set the indices to 0</div><div class="line">         * so we don't wrap the next time</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (fifo-&gt;in == fifo-&gt;out)</div><div class="line">                fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</div><div class="line"></div><div class="line">        spin_unlock_irqrestore(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><p><strong>kfifo_reset</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * __kfifo_reset - removes the entire FIFO contents, no locking version</div><div class="line"> * @fifo: the fifo to be emptied.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __kfifo_reset(<span class="keyword">struct</span> kfifo *fifo)</div><div class="line">&#123;</div><div class="line">        fifo-&gt;in = fifo-&gt;out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_reset - removes the entire FIFO contents</div><div class="line"> * @fifo: the fifo to be emptied.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line"></div><div class="line">        spin_lock_irqsave(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        __kfifo_reset(fifo);</div><div class="line"></div><div class="line">        spin_unlock_irqrestore(fifo-&gt;lock, flags);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>kfifo_len</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * __kfifo_len - returns the number of bytes available in the FIFO, no locking version</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __kfifo_len(<span class="keyword">struct</span> kfifo *fifo)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> fifo-&gt;in - fifo-&gt;out;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * kfifo_len - returns the number of bytes available in the FIFO</div><div class="line"> * @fifo: the fifo to be used.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">kfifo_len</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">        spin_lock_irqsave(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        ret = __kfifo_len(fifo);</div><div class="line"></div><div class="line">        spin_unlock_irqrestore(fifo-&gt;lock, flags);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/linyt/article/details/5764312" target="_blank" rel="external">巧夺天工的kfifo</a><br><a href="http://www.cnblogs.com/Anker/p/3481373.html" target="_blank" rel="external">linux内核数据结构之kfifo</a><br><a href="http://www.cnblogs.com/wang_yb/archive/2013/04/16/3023892.html" target="_blank" rel="external">《Linux内核设计与实现》读书笔记（六）- 内核数据结构</a></p>
<p><span style="color:red;">2014.03.31 更新</span><br>新的内核版本中，kfifo 接口已经改写，新的 kfifo 接口请查阅最新的内核源码。<br>相关的接口修改历史可查阅以下链接：<br><a href="http://lwn.net/Articles/345015/" target="_blank" rel="external">http://lwn.net/Articles/345015/</a><br><a href="http://lwn.net/Articles/347619/" target="_blank" rel="external">http://lwn.net/Articles/347619/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux字符设备模块加载脚本]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/linux-char-device-module-script/</url>
      <content type="html"><![CDATA[<p>设备号动态分配的字符设备模块加载及设备节点创建脚本：（摘自LDD3）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment"># $Id: scull_load,v 1.4 2004/11/03 06:19:49 rubini Exp $</span></div><div class="line">module=<span class="string">"scull"</span></div><div class="line">device=<span class="string">"scull"</span></div><div class="line">mode=<span class="string">"664"</span></div><div class="line"></div><div class="line"><span class="comment"># Group: since distributions do it differently, look for wheel or use staff</span></div><div class="line"><span class="keyword">if</span> grep -q <span class="string">'^staff:'</span> /etc/group; <span class="keyword">then</span></div><div class="line">    group=<span class="string">"staff"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    group=<span class="string">"wheel"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment"># invoke insmod with all arguments we got</span></div><div class="line"><span class="comment"># and use a pathname, as insmod doesn't look in . by default</span></div><div class="line">/sbin/insmod ./<span class="variable">$module</span>.ko $* || <span class="built_in">exit</span> 1</div><div class="line"></div><div class="line"><span class="comment"># retrieve major number</span></div><div class="line">major=$(awk <span class="string">"\$2==\"<span class="variable">$module</span>\" &#123;print \$1&#125;"</span> /proc/devices)</div><div class="line"></div><div class="line"><span class="comment"># Remove stale nodes and replace them, then give gid and perms</span></div><div class="line"><span class="comment"># Usually the script is shorter, it's scull that has several devices in it.</span></div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>[0-3]</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>0 c <span class="variable">$major</span> 0</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>1 c <span class="variable">$major</span> 1</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>2 c <span class="variable">$major</span> 2</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>3 c <span class="variable">$major</span> 3</div><div class="line">ln -sf <span class="variable">$&#123;device&#125;</span>0 /dev/<span class="variable">$&#123;device&#125;</span></div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>[0-3]</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>[0-3]</div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>pipe[0-3]</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>pipe0 c <span class="variable">$major</span> 4</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>pipe1 c <span class="variable">$major</span> 5</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>pipe2 c <span class="variable">$major</span> 6</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>pipe3 c <span class="variable">$major</span> 7</div><div class="line">ln -sf <span class="variable">$&#123;device&#125;</span>pipe0 /dev/<span class="variable">$&#123;device&#125;</span>pipe</div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>pipe[0-3]</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>pipe[0-3]</div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>single</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>single  c <span class="variable">$major</span> 8</div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>single</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>single</div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>uid</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>uid   c <span class="variable">$major</span> 9</div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>uid</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>uid</div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>wuid</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>wuid  c <span class="variable">$major</span> 10</div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>wuid</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>wuid</div><div class="line"></div><div class="line">rm <span class="_">-f</span> /dev/<span class="variable">$&#123;device&#125;</span>priv</div><div class="line">mknod /dev/<span class="variable">$&#123;device&#125;</span>priv  c <span class="variable">$major</span> 11</div><div class="line">chgrp <span class="variable">$group</span> /dev/<span class="variable">$&#123;device&#125;</span>priv</div><div class="line">chmod <span class="variable">$mode</span>  /dev/<span class="variable">$&#123;device&#125;</span>priv</div></pre></td></tr></table></figure></p>
<p>获取动态分配到的主设备号：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># retrieve major number</span></div><div class="line">major=$(awk <span class="string">"\$2==\"<span class="variable">$module</span>\" &#123;print \$1&#125;"</span> /proc/devices)</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核模块编译Makefile模板]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/template-of-linux-kernel-module-makefile/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.chinaunix.net/uid-20543672-id-3241147.html" target="_blank" rel="external">Linux内核模块LKM编译-自制Makefile模板</a> By Tekkaman Ninja</p>
<p>根据LDD3的内核模块makefile和原理说明，根据自己的需要做了适当的修改使得这个Makefile脚本可以方便被应用于不同的简单模块编译，并可以在模块需要编译进内核的时候直接放入内核源码目录中，脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">MODULE_NAME = hello_linux_simple</div><div class="line">MODULE_CONFIG = CONFIG_HELLO_LINUX_SIMPLE</div><div class="line">CROSS_CONFIG = y</div><div class="line"># Comment/uncomment the following line to disable/enable debugging</div><div class="line">DEBUG = y</div><div class="line"></div><div class="line"># If KERNELRELEASE is defined, we&apos;ve been invoked from the</div><div class="line"># kernel build system and can use its language.</div><div class="line">ifneq ($(KERNELRELEASE),)</div><div class="line"></div><div class="line"># Add your debugging flag (or not) to CFLAGS</div><div class="line">ifeq ($(DEBUG),y)</div><div class="line">	DEBFLAGS = -O -g -DDEBUG # &quot;-O&quot; is needed to expand inlines</div><div class="line">else</div><div class="line">	DEBFLAGS = -O2</div><div class="line">endif</div><div class="line"></div><div class="line">ccflags-y += $(DEBFLAGS)</div><div class="line"></div><div class="line">obj-$($(MODULE_CONFIG)) := $(MODULE_NAME).o</div><div class="line">#for Multi-files module</div><div class="line">$(MODULE_NAME)-objs := hello_linux_simple_dep.o ex_output.o</div><div class="line"></div><div class="line"># Otherwise we were called directly from the command line;</div><div class="line"># invoke the kernel build system.</div><div class="line">else</div><div class="line"></div><div class="line">ifeq ($(CROSS_CONFIG), y)</div><div class="line">#for Cross-compile</div><div class="line">KERNELDIR = （内核源码路径）</div><div class="line">ARCH = arm</div><div class="line">#FIXME:maybe we need absolute path for different user. eg root</div><div class="line">#CROSS_COMPILE = arm-none-linux-gnueabi-</div><div class="line">CROSS_COMPILE = （交叉编译工具路径）</div><div class="line">INSTALLDIR := （目标模块所安装的根文件系统路径）</div><div class="line"></div><div class="line">else</div><div class="line">#for Local compile</div><div class="line">KERNELDIR = /lib/modules/$(shell uname -r)/build</div><div class="line">ARCH = x86</div><div class="line">CROSS_COMPILE =</div><div class="line">INSTALLDIR := /</div><div class="line"></div><div class="line">endif</div><div class="line"></div><div class="line">################################</div><div class="line">PWD := $(shell pwd)</div><div class="line"></div><div class="line">.PHONY: modules modules_install clean</div><div class="line"></div><div class="line">modules:</div><div class="line">	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(MODULE_CONFIG)=m -C $(KERNELDIR) M=$(PWD) modules</div><div class="line"></div><div class="line">modules_install: modules</div><div class="line">	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(MODULE_CONFIG)=m -C $(KERNELDIR) INSTALL_MOD_PATH=$(INSTALLDIR) M=$(PWD) modules_install</div><div class="line"></div><div class="line">clean:</div><div class="line">	@rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions *.symvers *.order .*.o.d modules.builtin</div><div class="line"></div><div class="line">endif</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这个脚本与模块源码放置于同一个目录。针对不同的模块，只要简单的修改部分参数，使用时只需要在该目录下执行一个简单的“make”命令即可。下面我简单分析一下：<br>上面的示例脚本利用了扩展的 GNU make 语法，这个 makefile 在编译内核模块的时候会要被读取 2 次。</p>
<p>第一次：当从命令行执行“make”命令时，“make”会读取这个makefile。此时由于“<code>KERNELRELEASE</code>”变量没有被设置，所以会执行“<code>else</code>”的部分，也就是“<code>modules</code>”目标下的指令，类似我们上面讲的的编译命令“<code>make -C $() M=$() modules</code>”。只不过这里为了通用性添加了一些变量而已。</p>
<p>第二次：当执行了上面的指令后，make 命令( 在 makefile 里参数化成 <code>$(MAKE)</code> )调用内核编译系统。再次读取这个makefile。由于内核编译系统设置了“<code>KERNELRELEASE</code>”变量，所以此次内核编译系统看到了“<code>obj-$($(MODULE_CONFIG)) := $(MODULE_NAME).o</code>”也就是类似之前我们描述的“<code>obj-m</code>”。这样内核的编译系统就可以完成实际的模块编译工作。</p>
<p>这种模块编译Makefile只需做很小的改动就可以方便的应用于不同的模块中。对于不同的模块你可能需要修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">MODULE_NAME =   （模块名）</div><div class="line">MODULE_CONFIG = （在模块编译进内核时的配置选项）</div><div class="line">CROSS_CONFIG = y（是否为交叉编译）</div><div class="line">DEBUG = y       （是否定义调试标志）</div><div class="line">......</div><div class="line">$(MODULE_NAME)-objs := （若为多文件模块，则在此列出。否则用#屏蔽)</div><div class="line">......</div><div class="line">ifeq ($(CROSS_CONFIG), y)</div><div class="line">#for Cross-compile</div><div class="line">KERNELDIR = （内核源码路径）</div><div class="line">ARCH = arm（交叉编译时，目标CPU构架名，此处为arm）</div><div class="line">#FIXME:maybe we need absolute path for different user. eg root</div><div class="line">#CROSS_COMPILE = arm-none-linux-gnueabi-</div><div class="line">CROSS_COMPILE = （交叉编译工具路径及前缀）</div><div class="line">INSTALLDIR := （目标模块所安装的根文件系统路径）</div><div class="line">else</div><div class="line">#for Local compile</div><div class="line">......</div><div class="line">ARCH = x86(这个根据本地构架可能需要修改)</div><div class="line">......</div><div class="line">endif</div></pre></td></tr></table></figure></p>
<p>对于这个Makefile，还有一点就是考虑到直接放入内核目录，编译进内核的情况。如果只是简单的模块，可以再次利用这个Makefile。这就是为什么上面的Makefile比较繁琐，因为它同时支持直接放入内核源码树中使用。</p>
<p>假设我们将一个名为<code>hello_linux_simple</code>的模块编译入内核中，我们需要做的工作就是将包含以上Makefile和源码的目录拷贝到一个目录（例如<code>drivers/misc</code>）下，并适当修改该目录下的内核编译系统<code>Kconfig</code>和<code>Makefile</code>文件。</p>
<p>在（<code>drivers/misc/</code>）<code>Kconfig</code>中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">config HELLO_LINUX_SIMPLE</div><div class="line">	tristate &quot;simple hello_linux module&quot;</div><div class="line">	# depends on</div><div class="line">	help</div><div class="line">	  simple hello_linux module</div></pre></td></tr></table></figure></p>
<p>由于此模块不依赖其他模块，“<code>depends on</code>”就可以屏蔽了。</p>
<p>在（<code>drivers/misc/</code>）<code>Makefile</code>中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-$(CONFIG_HELLO_LINUX_SIMPLE) += hello_linux_simple/</div></pre></td></tr></table></figure></p>
<p>注意：上面的<code>CONFIG_HELLO_LINUX_SIMPLE</code>必须要和模块源码Makefile中的<code>MODULE_CONFIG</code>的值一致。<br>文件修改好后，就可以配置内核了。在内核的<code>make menuconfig</code>中，我们可以看到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Device Drivers -→</div><div class="line">[*] Misc devices ---&gt;</div><div class="line">&lt; &gt; simple hello_linux module</div></pre></td></tr></table></figure></p>
<p>既可以用“<code>M</code>”编译成模块，也可以用“<code>Y</code>”编译进内核中。</p>
<p><strong>关于调试选项DEBUG</strong><br>上面定义了<code>DEBUG=y</code>的选项，是为了在调试的时候启用<code>pr_debug</code>和<code>pr_devel</code>宏，这些宏是<code>printk</code>的封装（参见<a href="http://blog.chinaunix.net/uid-20543672-id-3211832.html" target="_blank" rel="external">《内核日志及printk结构浅析》</a>），或者可以开启其他依赖<code>DEBUG</code>定义的宏。这样在调试结束之后就可以方便的通过屏蔽<code>#DEBUG=y</code>来关闭调试信息的输出，不产生调试信息代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字符设备驱动原理图解]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/principle-of-linux-char-device-driver/</url>
      <content type="html"><![CDATA[<p>现实世界中存在着大量的设备，这些设备在电气特性和I/O方式上都各不相同。为了简化设备驱动程序员的工作，linux系统从这些各异的设备中抽象出共性的特征，将其划分为三大类：字符设备、块设备和网络设备。内核针对每一类设备都提供了对应的驱动模型框架，包括基本的内核设施和文件系统接口。这样，设备驱动程序员在编写某类设备驱动程序时，就有一套完整的驱动模型框架可以使用，从而可以将大量的精力放在设备本身的操作上。下图2-1展示了一个粗略的linux设备驱动程序结构图：</p>
<img src="/kernel/设备驱动/principle-of-linux-char-device-driver/device_driver_framework.png" alt="device_driver_framework.png" title="">
<a id="more"></a>
<p>以下内容转自 <a href="http://blog.chinaunix.net/uid-20543672-id-3203690.html" target="_blank" rel="external">《深入Linux设备驱动程序机制》学习心得—字符设备驱动原理图解</a> By Tekkaman Ninja</p>
<p>在第二章讲解字符设备的时候，个人觉得比较有收获的主要是两个方面的知识：<br>1、字符设备号的管理（<code>char_device_struct</code>）<br>2、字符设备驱动的<code>file_operation</code>中的函数如何与file结构体中的相应接口关联，并被应用程序调用。  </p>
<p>对于以上两个主要的知识点，我觉得书上的条理已经很清楚的，很容易看懂，我在这里复述就多余了。我把学到的两个知识点用图的方式总结出来，供大家参考。</p>
<p><strong>字符设备号的管理</strong></p>
<p>重点在于内核在管理时所依赖的数据结构<code>char_device_struct</code>以及全局的散列表<code>chrdevs</code>。<br>还有就是要知道内核对于设备号的注册与注销和驱动功能的实现是没有必然的联系的。设备号的管理是一个独立的机制，以避免驱动在使用设备号的时候发生冲突，导致驱动中的<code>file_operation</code>对应错误，进而出现应用层操作错误的设备。因为应用层对设备的操作就是通过设备号对应到具体的<code>file_operation</code>的。</p>
<img src="/kernel/设备驱动/principle-of-linux-char-device-driver/chr_dev.jpg" alt="chr_dev.jpg" title="">
<p><strong>字符设备驱动的<code>file_operation</code>中的函数如何与<code>file</code>结构体中的相应接口关联</strong></p>
<p>这部分的内容主要是要熟悉<code>open</code>函数的调用流程，驱动中的<code>file_operation</code>结构体就是在<code>open</code>函数中通过设备号与进程相关的<code>file</code>结构体中相应函数进行对应的。在完成了<code>open</code>操作之后，其他的文件操作就可以直接调用驱动<code>file_operation</code>中的函数了。<br>内核对于<code>char_device_struct</code>结构体的管理方式和设备号的<code>cdev_map</code>是类似的，都是通过主设备号作为哈希表的key来索引。</p>
<img src="/kernel/设备驱动/principle-of-linux-char-device-driver/chr_dev2.jpg" alt="chr_dev2.jpg" title="">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核链表之klist]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/klist/</url>
      <content type="html"><![CDATA[<p><code>klist</code>是<code>list</code>的线程安全版本，它提供了整个链表的自旋锁，查找链表节点，对链表节点的插入和删除操作都要获得这个自旋锁。<code>klist</code>的节点数据结构是<code>klist_node</code>，<code>klist_node</code>引入引用计数，只有当引用计数减到0时才允许该<code>node</code>从链表中移除。当一个内核线程要移除一个<code>node</code>，必须要等待到<code>node</code>的引用计数释放，在此期间线程处于休眠状态。为了方便线程等待，<code>klist</code>引入等待移除节点者结构体<code>klist_waiter</code>，<code>klist_waiter</code>组成<code>klist_remove_waiters</code>（内核全局变量）链表，为保护<code>klist_remove_waiters</code>线程安全，引入<code>klist_remove_lock</code>（内核全局变量）自旋锁。为方便遍历<code>klist</code>，引入了迭代器<code>klist_iter</code>。<br><a id="more"></a></p>
<h2 id="数据结构及接口声明"><a href="#数据结构及接口声明" class="headerlink" title="数据结构及接口声明"></a>数据结构及接口声明</h2><p>include/linux/klist.h：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">struct klist_node;</div><div class="line">struct klist &#123;</div><div class="line">        spinlock_t              k_lock;</div><div class="line">        struct list_head        k_list;</div><div class="line">        void                    (*get)(struct klist_node *);</div><div class="line">        void                    (*put)(struct klist_node *);</div><div class="line">&#125; __attribute__ ((aligned (sizeof(void *))));</div><div class="line"></div><div class="line">#define KLIST_INIT(_name, _get, _put)                                   \</div><div class="line">        &#123; .k_lock       = __SPIN_LOCK_UNLOCKED(_name.k_lock),           \</div><div class="line">          .k_list       = LIST_HEAD_INIT(_name.k_list),                 \</div><div class="line">          .get          = _get,                                         \</div><div class="line">          .put          = _put, &#125;</div><div class="line"></div><div class="line">#define DEFINE_KLIST(_name, _get, _put)                                 \</div><div class="line">        struct klist _name = KLIST_INIT(_name, _get, _put)</div><div class="line"></div><div class="line">extern void klist_init(struct klist *k, void (*get)(struct klist_node *),</div><div class="line">                       void (*put)(struct klist_node *));</div><div class="line"></div><div class="line">struct klist_node &#123;</div><div class="line">        void                    *n_klist;       /* never access directly */</div><div class="line">        struct list_head        n_node;</div><div class="line">        struct kref             n_ref;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extern void klist_add_tail(struct klist_node *n, struct klist *k);</div><div class="line">extern void klist_add_head(struct klist_node *n, struct klist *k);</div><div class="line">extern void klist_add_after(struct klist_node *n, struct klist_node *pos);</div><div class="line">extern void klist_add_before(struct klist_node *n, struct klist_node *pos);</div><div class="line"></div><div class="line">extern void klist_del(struct klist_node *n);</div><div class="line">extern void klist_remove(struct klist_node *n);</div><div class="line"></div><div class="line">extern int klist_node_attached(struct klist_node *n);</div><div class="line"></div><div class="line">struct klist_iter &#123;</div><div class="line">        struct klist            *i_klist;</div><div class="line">        struct klist_node       *i_cur;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">extern void klist_iter_init(struct klist *k, struct klist_iter *i);</div><div class="line">extern void klist_iter_init_node(struct klist *k, struct klist_iter *i,</div><div class="line">                                 struct klist_node *n);</div><div class="line">extern void klist_iter_exit(struct klist_iter *i);</div><div class="line">extern struct klist_node *klist_next(struct klist_iter *i);</div></pre></td></tr></table></figure></p>
<p><strong>klist_node</strong></p>
<p><code>klist_node</code>有个<code>dead</code>字段，联合在<code>n_klist</code>指针中，<code>n_klist</code>只能默认指向<code>klist</code>。<code>klist</code>的定义中，<code>__attribute__ ((aligned (sizeof(void *))))</code>要求按<code>void</code>指针类型大小进行内存字节对齐，这意味着<code>klist</code>实例的地址低2位（x86_32）或者低3位（x86_64）总是0，这些为0的低位刚好可以作为其他用处，对该指针解引用前需与掉相应位。来看源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Use the lowest bit of n_klist to mark deleted nodes and exclude</div><div class="line"> * dead ones from iteration.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_DEAD		1LU</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KNODE_KLIST_MASK	~KNODE_DEAD</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> klist *<span class="title">knode_klist</span><span class="params">(<span class="keyword">struct</span> klist_node *knode)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> klist *)</div><div class="line">		((<span class="keyword">unsigned</span> <span class="keyword">long</span>)knode-&gt;n_klist &amp; KNODE_KLIST_MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">knode_dead</span><span class="params">(<span class="keyword">struct</span> klist_node *knode)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>)knode-&gt;n_klist &amp; KNODE_DEAD;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knode_set_klist</span><span class="params">(<span class="keyword">struct</span> klist_node *knode, <span class="keyword">struct</span> klist *klist)</span></span></div><div class="line">&#123;</div><div class="line">	knode-&gt;n_klist = klist;</div><div class="line">	<span class="comment">/* no knode deserves to start its life dead */</span></div><div class="line">	WARN_ON(knode_dead(knode));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knode_kill</span><span class="params">(<span class="keyword">struct</span> klist_node *knode)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/* and no knode should die twice ever either, see we're very humane */</span></div><div class="line">	WARN_ON(knode_dead(knode));</div><div class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;knode-&gt;n_klist |= KNODE_DEAD;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为什么要引入这个dead标识呢？</p>
<p>如果一个内核线程要让某个<code>node</code>无效，不能简单的从<code>klist</code>中把<code>node</code>摘下来，只能减少<code>node</code>的引用计数，但是由于其他内核线程也拥有该<code>node</code>的引用计数，所以节点还是在<code>klist</code>链中，遍历节点等操作时无法避开该<code>node</code>。引入这个标识后，只要设置这个标识，尽管该<code>node</code>还在<code>klist</code>链上，但是迭代操作的时候通过这个标识避开<code>dead</code>的节点。这样在该节点上不会有新的操作，通过链表遍历也无法获取到该节点，当其他内核线程不再引用该<code>node</code>后，该<code>node</code>自动从<code>klist</code>链中移除。所以<code>dead</code>的作用是禁止再使用该<code>node</code>，但是已经被人家在用的还是可以继续使用。调用<code>klist_del()</code>会标示该<code>node</code>为<code>dead</code>，并最终删除节点。</p>
<p>前面的四个函数都是内部静态函数，用于辅助API实现：<br><code>knode_klist</code>是从节点找到链表头，<code>knode_dead</code>是检查该节点是否已被请求删除，<br><code>knode_set_klist</code>设置节点的链表头，<code>knode_kill</code>将请求删除一个节点。<br>细心的话大家会发现这四个函数是对称的，而且都是操作节点的内部函数。</p>
<p><strong>klist 的定义和初始化</strong></p>
<p>常规定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> klist myklist;</div><div class="line">klist_init(&amp;myklist,get,put);</div></pre></td></tr></table></figure></p>
<p>便捷宏方式定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEFINE_KLIST(myklist,get,put);<span class="comment">//定义一个myklist，并初始化</span></div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * klist_init - Initialize a klist structure.</div><div class="line"> * @k: The klist we're initializing.</div><div class="line"> * @get: The get function for the embedding object (NULL if none)</div><div class="line"> * @put: The put function for the embedding object (NULL if none)</div><div class="line"> *</div><div class="line"> * Initialises the klist structure.  If the klist_node structures are</div><div class="line"> * going to be embedded in refcounted objects (necessary for safe</div><div class="line"> * deletion) then the get/put arguments are used to initialise</div><div class="line"> * functions that take and release references on the embedding</div><div class="line"> * objects.</div><div class="line"> */</div><div class="line">void klist_init(struct klist *k, void (*get)(struct klist_node *),</div><div class="line">                void (*put)(struct klist_node *))</div><div class="line">&#123;</div><div class="line">        INIT_LIST_HEAD(&amp;k-&gt;k_list);</div><div class="line">        spin_lock_init(&amp;k-&gt;k_lock);</div><div class="line">        k-&gt;get = get;</div><div class="line">        k-&gt;put = put;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_init);</div></pre></td></tr></table></figure>
<p>注意函数注释中对get/put参数（函数指针）的说明。</p>
<p><strong>插入节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> klist_node mynode;</div><div class="line">klist_add_tail(&amp;mynode,&amp;mylist);</div></pre></td></tr></table></figure></p>
<p><code>klist_add_xxx</code>函数初始化<code>node</code>，并将其插入链表，插入链表后，引用计数为1<br><code>klist_add_tail</code>向后插入，<code>klist_add_head</code>向前插入；<br><code>kilst_add_after</code>在某个节点的后面插入，<code>klist_add_before</code>在某个节点的前面插入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_head</span><span class="params">(<span class="keyword">struct</span> klist *k, <span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">	spin_lock(&amp;k-&gt;k_lock);</div><div class="line">	list_add(&amp;n-&gt;n_node, &amp;k-&gt;k_list);</div><div class="line">	spin_unlock(&amp;k-&gt;k_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_tail</span><span class="params">(<span class="keyword">struct</span> klist *k, <span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">	spin_lock(&amp;k-&gt;k_lock);</div><div class="line">	list_add_tail(&amp;n-&gt;n_node, &amp;k-&gt;k_list);</div><div class="line">	spin_unlock(&amp;k-&gt;k_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_node_init</span><span class="params">(<span class="keyword">struct</span> klist *k, <span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">	INIT_LIST_HEAD(&amp;n-&gt;n_node);</div><div class="line">	kref_init(&amp;n-&gt;n_ref);</div><div class="line">	knode_set_klist(n, k);</div><div class="line">	<span class="keyword">if</span> (k-&gt;get)</div><div class="line">		k-&gt;get(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三个内部函数，<code>add_head</code>将节点加入链表头，<code>add_tail</code>将节点加入链表尾，<code>klist_node_init</code>是初始化节点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_add_head - Initialize a klist_node and add it to front.</div><div class="line"> * @n: node we're adding.</div><div class="line"> * @k: klist it's going on.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_head</span><span class="params">(<span class="keyword">struct</span> klist_node *n, <span class="keyword">struct</span> klist *k)</span></span></div><div class="line">&#123;</div><div class="line">        klist_node_init(k, n);</div><div class="line">        add_head(k, n);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_add_head);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_add_tail - Initialize a klist_node and add it to back.</div><div class="line"> * @n: node we're adding.</div><div class="line"> * @k: klist it's going on.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_tail</span><span class="params">(<span class="keyword">struct</span> klist_node *n, <span class="keyword">struct</span> klist *k)</span></span></div><div class="line">&#123;</div><div class="line">        klist_node_init(k, n);</div><div class="line">        add_tail(k, n);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_add_tail);</div></pre></td></tr></table></figure></p>
<p><code>klist_add_head</code>将节点初始化，并将其加入链表头，<code>klist_add_tail</code>将节点初始化，并将其加入链表尾。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_add_after - Init a klist_node and add it after an existing node</div><div class="line"> * @n: node we're adding.</div><div class="line"> * @pos: node to put @n after</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_after</span><span class="params">(<span class="keyword">struct</span> klist_node *n, <span class="keyword">struct</span> klist_node *pos)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> klist *k = knode_klist(pos);</div><div class="line"></div><div class="line">        klist_node_init(k, n);</div><div class="line">        spin_lock(&amp;k-&gt;k_lock);</div><div class="line">        list_add(&amp;n-&gt;n_node, &amp;pos-&gt;n_node);</div><div class="line">        spin_unlock(&amp;k-&gt;k_lock);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_add_after);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_add_before - Init a klist_node and add it before an existing node</div><div class="line"> * @n: node we're adding.</div><div class="line"> * @pos: node to put @n after</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_add_before</span><span class="params">(<span class="keyword">struct</span> klist_node *n, <span class="keyword">struct</span> klist_node *pos)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> klist *k = knode_klist(pos);</div><div class="line"></div><div class="line">        klist_node_init(k, n);</div><div class="line">        spin_lock(&amp;k-&gt;k_lock);</div><div class="line">        list_add_tail(&amp;n-&gt;n_node, &amp;pos-&gt;n_node);</div><div class="line">        spin_unlock(&amp;k-&gt;k_lock);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_add_before);</div></pre></td></tr></table></figure></p>
<p><code>klist_add_after</code>将节点加到指定节点后面，<code>klist_add_before</code>将节点加到指定节点前面。</p>
<p><strong>删除节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">klist_del(&amp;mynode);</div></pre></td></tr></table></figure></p>
<p><code>klist_del</code>调用<code>klist_put</code>，减少引用计数，并设<code>dead</code>标记，当引用计数减为0时，自动调用<code>klist_release</code>，把节点从<code>klist</code>中删除。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">klist_remove(&amp;mynode);</div></pre></td></tr></table></figure></p>
<p><code>klist_remove</code>把当前线程加入等待移除链表，减少引用计数，如果有其他内核线程占用引用计数，把当前线程休眠。</p>
<p><code>klist</code>是怎么迫使<code>remove</code>某个<code>node</code>的线程休眠的，又是怎么唤醒的？为了方便进程管理，引入了<code>klist_waiter</code>结构，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> klist_waiter &#123;</div><div class="line">        <span class="keyword">struct</span> list_head <span class="built_in">list</span>;</div><div class="line">        <span class="keyword">struct</span> klist_node *node; <span class="comment">//等待删除的node</span></div><div class="line">        <span class="keyword">struct</span> task_struct *process; <span class="comment">//进程或者线程指针</span></div><div class="line">        <span class="keyword">int</span> woken; <span class="comment">//唤醒标记</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(klist_remove_lock)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(klist_remove_waiters)</span></span>;</div></pre></td></tr></table></figure></p>
<p>来看使线程进入休眠的代码，klist_remove函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_remove - Decrement the refcount of node and wait for it to go away.</div><div class="line"> * @n: node we're removing.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_remove</span><span class="params">(<span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> klist_waiter waiter;  <span class="comment">//创建一个waiter</span></div><div class="line"></div><div class="line">        waiter.node = n;</div><div class="line">        waiter.process = current;</div><div class="line">        waiter.woken = <span class="number">0</span>;</div><div class="line">        spin_lock(&amp;klist_remove_lock);  <span class="comment">//锁住klist_remove_lock，</span></div><div class="line">                                            <span class="comment">//klist_remove_lock专门是用来保护</span></div><div class="line">                                            <span class="comment">//klist_remove_waiters的</span></div><div class="line">        list_add(&amp;waiter.<span class="built_in">list</span>, &amp;klist_remove_waiters);  <span class="comment">//把waiter加入到klist_remove_waiters中</span></div><div class="line">                                                            <span class="comment">//这里把一个局部变量加入到一个全局的链表结构中，</span></div><div class="line">                                                            <span class="comment">//会不会引起内存越界后续讨论</span></div><div class="line">        spin_unlock(&amp;klist_remove_lock);</div><div class="line"></div><div class="line">        klist_del(n);  <span class="comment">//减少引用计数并判死刑</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">                set_current_state(TASK_UNINTERRUPTIBLE);  <span class="comment">//设置进程进入休眠状态</span></div><div class="line">                <span class="keyword">if</span> (waiter.woken)</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                schedule();  <span class="comment">//调度进程时当前进程进入休眠状态</span></div><div class="line">        &#125;</div><div class="line">        __set_current_state(TASK_RUNNING);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_remove);</div></pre></td></tr></table></figure></p>
<p><code>klist_del</code>函数调用<code>klist_put</code>调用<code>klist_dec_and_del</code>调用<code>kref_put</code>，<code>kref_put</code>当引用计数减到0时回调<code>klist_release</code>函数，<code>klist_release</code>会释放等待者。<br>进程的休眠与唤醒是<code>klist_remove</code>和<code>klist_release</code>共同作用的结果，我们来看<code>klist_release</code>的源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_release</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> klist_waiter *waiter, *tmp;</div><div class="line">        <span class="keyword">struct</span> klist_node *n = container_of(kref, <span class="keyword">struct</span> klist_node, n_ref);</div><div class="line"></div><div class="line">        WARN_ON(!knode_dead(n));  <span class="comment">//要释放的节点一定是被判死刑的节点</span></div><div class="line">        list_del(&amp;n-&gt;n_node);     <span class="comment">//把node从klist移除</span></div><div class="line">        spin_lock(&amp;klist_remove_lock);  <span class="comment">//保护klist_remove_waiters</span></div><div class="line">        <span class="comment">/* 遍历klist_remove_waiter */</span></div><div class="line">        list_for_each_entry_safe(waiter, tmp, &amp;klist_remove_waiters, <span class="built_in">list</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (waiter-&gt;node != n)</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">                list_del(&amp;waiter-&gt;<span class="built_in">list</span>);  <span class="comment">//把waiter结构体从klist_remove_waiters中移除</span></div><div class="line">                waiter-&gt;woken = <span class="number">1</span>;  <span class="comment">//设唤醒标示</span></div><div class="line">                mb();</div><div class="line">                wake_up_process(waiter-&gt;process);  <span class="comment">//唤醒该进程</span></div><div class="line">        &#125;</div><div class="line">        spin_unlock(&amp;klist_remove_lock);</div><div class="line">        knode_set_klist(n, <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">klist_dec_and_del</span><span class="params">(<span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> kref_put(&amp;n-&gt;n_ref, klist_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">klist_put</span><span class="params">(<span class="keyword">struct</span> klist_node *n, <span class="keyword">bool</span> kill)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> klist *k = knode_klist(n);</div><div class="line">        <span class="keyword">void</span> (*put)(<span class="keyword">struct</span> klist_node *) = k-&gt;put;</div><div class="line"></div><div class="line">        spin_lock(&amp;k-&gt;k_lock);</div><div class="line">        <span class="keyword">if</span> (kill)</div><div class="line">                knode_kill(n);</div><div class="line">        <span class="keyword">if</span> (!klist_dec_and_del(n))</div><div class="line">                put = <span class="literal">NULL</span>;</div><div class="line">        spin_unlock(&amp;k-&gt;k_lock);</div><div class="line">        <span class="keyword">if</span> (put)</div><div class="line">                put(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_del - Decrement the reference count of node and try to remove.</div><div class="line"> * @n: node we're deleting.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_del</span><span class="params">(<span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        klist_put(n, <span class="literal">true</span>);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_del);</div></pre></td></tr></table></figure></p>
<p><code>klist_remove</code>函数把局部变量加入到全局链表中，但是由于<code>klist_remove</code>会使线程休眠，它返回前总是由<code>klist_release</code>把<code>waiter</code>从<code>klist_remove_waiters</code>移走，所以不会导致崩溃。其实<code>klist_remove_waiters</code>的链表节点实际都是一些内核栈中的<code>waiter</code>结构，这些线程都休眠在<code>klist_remove</code>中。</p>
<p><strong>遍历klist</strong></p>
<p><code>klist</code>没有像<code>list</code>一样定义一系列的<code>list_for_each_xxx</code>宏。<code>klist</code>提供专门的迭代器结构提<code>klist_iter</code>，遍历前首先要初始化迭代器 ，<code>klist_next()</code>函数把当前迭代器向后移动，并返回移动后的<code>node</code>。<code>klist_iter_init()</code>，<code>klist_iter_init_node()</code>都是迭代器初始化函数，前者把迭代器当前位置设置为<code>NULL</code>，<code>klist_next()</code>自动从第一个<code>node</code>开始，后者可以指定当前<code>node</code>。迭代器指向<code>node</code>时会增加<code>node</code>的引用计数，当迭代器不用时必须调用<code>klist_iter_exit</code>退出迭代器，释放当前<code>node</code>的引用计数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_node_attached - Say whether a node is bound to a list or not.</div><div class="line"> * @n: Node that we're testing.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">klist_node_attached</span><span class="params">(<span class="keyword">struct</span> klist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> (n-&gt;n_klist != <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_node_attached);</div></pre></td></tr></table></figure></p>
<p><code>klist_node_attached</code>检查节点是否被包含在某链表中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_iter_init_node - Initialize a klist_iter structure.</div><div class="line"> * @k: klist we're iterating.</div><div class="line"> * @i: klist_iter we're filling.</div><div class="line"> * @n: node to start with.</div><div class="line"> *</div><div class="line"> * Similar to klist_iter_init(), but starts the action off with @n,</div><div class="line"> * instead of with the list head.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init_node</span><span class="params">(<span class="keyword">struct</span> klist *k, <span class="keyword">struct</span> klist_iter *i,</span></span></div><div class="line">                          <span class="keyword">struct</span> klist_node *n)</div><div class="line">&#123;</div><div class="line">        i-&gt;i_klist = k;</div><div class="line">        i-&gt;i_cur = n;</div><div class="line">        <span class="keyword">if</span> (n)</div><div class="line">                kref_get(&amp;n-&gt;n_ref);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_iter_init_node);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_iter_init - Iniitalize a klist_iter structure.</div><div class="line"> * @k: klist we're iterating.</div><div class="line"> * @i: klist_iter structure we're filling.</div><div class="line"> *</div><div class="line"> * Similar to klist_iter_init_node(), but start with the list head.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_init</span><span class="params">(<span class="keyword">struct</span> klist *k, <span class="keyword">struct</span> klist_iter *i)</span></span></div><div class="line">&#123;</div><div class="line">        klist_iter_init_node(k, i, <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_iter_init);</div></pre></td></tr></table></figure></p>
<p><code>klist_iter_init_node</code>是从<code>klist</code>中的某个节点开始遍历，而<code>klist_iter_init</code>是从链表头开始遍历的。要注意，<code>klist_iter_init</code>和<code>klist_iter_init_node</code>的用法不同。<code>klist_iter_init_node</code>可以在其后直接对当前节点进行访问，也可以调用<code>klist_next</code>访问下一节点，而<code>klist_iter_init</code>只能调用<code>klist_next</code>访问下一节点。或许，<code>klist_iter_init_node</code>的本意不是从当前节点开始，而是从当前节点的下一节点开始。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_iter_exit - Finish a list iteration.</div><div class="line"> * @i: Iterator structure.</div><div class="line"> *</div><div class="line"> * Must be called when done iterating over list, as it decrements the</div><div class="line"> * refcount of the current node. Necessary in case iteration exited before</div><div class="line"> * the end of the list was reached, and always good form.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">klist_iter_exit</span><span class="params">(<span class="keyword">struct</span> klist_iter *i)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (i-&gt;i_cur) &#123;</div><div class="line">                klist_put(i-&gt;i_cur, <span class="literal">false</span>);</div><div class="line">                i-&gt;i_cur = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_iter_exit);</div></pre></td></tr></table></figure></p>
<p><code>klist_iter_exit</code>遍历结束函数。在遍历完成时调不调无所谓，但如果想中途结束，就一定要调用<code>klist_iter_exit</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> klist_node *<span class="title">to_klist_node</span><span class="params">(<span class="keyword">struct</span> list_head *n)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> container_of(n, <span class="keyword">struct</span> klist_node, n_node);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * klist_next - Ante up next node in list.</div><div class="line"> * @i: Iterator structure.</div><div class="line"> *</div><div class="line"> * First grab list lock. Decrement the reference count of the previous</div><div class="line"> * node, if there was one. Grab the next node, increment its reference</div><div class="line"> * count, drop the lock, and return that next node.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">struct</span> klist_node *<span class="title">klist_next</span><span class="params">(<span class="keyword">struct</span> klist_iter *i)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">void</span> (*put)(<span class="keyword">struct</span> klist_node *) = i-&gt;i_klist-&gt;put;</div><div class="line">        <span class="keyword">struct</span> klist_node *last = i-&gt;i_cur;</div><div class="line">        <span class="keyword">struct</span> klist_node *next;</div><div class="line"></div><div class="line">        spin_lock(&amp;i-&gt;i_klist-&gt;k_lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (last) &#123;</div><div class="line">                next = to_klist_node(last-&gt;n_node.next);</div><div class="line">                <span class="keyword">if</span> (!klist_dec_and_del(last))</div><div class="line">                        put = <span class="literal">NULL</span>;</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">                next = to_klist_node(i-&gt;i_klist-&gt;k_list.next);</div><div class="line"></div><div class="line">        i-&gt;i_cur = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">while</span> (next != to_klist_node(&amp;i-&gt;i_klist-&gt;k_list)) &#123;</div><div class="line">                <span class="keyword">if</span> (likely(!knode_dead(next))) &#123;</div><div class="line">                        kref_get(&amp;next-&gt;n_ref);</div><div class="line">                        i-&gt;i_cur = next;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                next = to_klist_node(next-&gt;n_node.next);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        spin_unlock(&amp;i-&gt;i_klist-&gt;k_lock);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (put &amp;&amp; last)</div><div class="line">                put(last);</div><div class="line">        <span class="keyword">return</span> i-&gt;i_cur;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(klist_next);</div></pre></td></tr></table></figure></p>
<p><code>klist_next</code>是将循环进行到下一节点，实现中需要注意两点问题：</p>
<ol>
<li>加锁，根据经验，单纯对某个节点操作不需要加锁，但对影响整个链表的操作需要加自旋锁。比如之前klist_iter_init_node中对节点增加引用计数，就不需要加锁，因为只有已经拥有节点引用计数的线程才会特别地从那个节点开始。而之后klist_next中则需要加锁，因为当前线程很可能没有引用计数，所以需要加锁，让情况固定下来。这既是保护链表，也是保护节点有效。符合kref引用计数的使用原则。</li>
<li>要注意，虽然在节点切换的过程中是加锁的，但切换完访问当前节点时是解锁的，中间可能有节点被删除，也可能有节点被请求删除，这就需要注意。首先要忽略链表中已被请求删除的节点，然后在减少前一个节点引用计数时，可能就把前一个节点删除了。这里之所以不调用klist_put，是因为本身已处于加锁状态，但仍要有它的实现。这里的实现和klist_put中类似，代码不介意在加锁状态下唤醒另一个线程，但却不希望在加锁状态下调用put函数，那可能会涉及释放另一个更大的结构。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/qb_2008/article/details/6845854" target="_blank" rel="external">linux内核部件分析（四）——更强的链表klist</a><br><a href="http://www.cnblogs.com/httpftpli/archive/2012/07/24/klist.html" target="_blank" rel="external">linux内核源代码分析—-内核基础设施之klist</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核链表之hlist]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hlist/</url>
      <content type="html"><![CDATA[<p>在Linux内核中，hlist（哈希链表）使用非常广泛，本文将对其数据结构和核心函数进行分析。</p>
<p>和hlist相关的数据结构有两个</p>
<ol>
<li>hlist_head</li>
<li>hlist_node<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> hlist_head &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *first;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> hlist_node &#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *next, **pprev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>顾名思义，<code>hlist_head</code>表示哈希表的头结点。哈希表中每一个 entry (hlist_head) 所对应的都是一个链表（hlist)，该链表的结点由<code>hlist_node</code>表示。<br><img src="/kernel/内核数据结构/hlist/hlist.jpg" alt="hlist.jpg" title=""><br><code>hlist_head</code> 结构体只有一个域，即<code>first</code>。<code>first</code>指针指向该 hlist 链表的第一个节点。</p>
<p><code>hlist_node</code>结构体有两个域，<code>next</code>和<code>pprev</code>。 <code>next</code>指针很容易理解，它指向下个<code>hlist_node</code>结点，倘若该节点是链表的最后一个节点，<code>next</code>指向<code>NULL</code>。</p>
<p><code>pprev</code>是一个二级指针，为什么我们需要这样一个指针呢？它的好处是什么？<br><a id="more"></a></p>
<p>在回答这个问题之前，我们先研究另一个问题：为什么散列表的实现需要两个不同的数据结构？</p>
<p>散列表的目的是为了方便快速的查找，所以散列表通常是一个比较大的数组，否则“冲突”的概率会非常大，这样也就失去了散列表的意义。如何做到既能维护一张大表，又能不使用过多的内存呢？这就只能从数据结构上下功夫了。所以对于散列表的每个entry，它的结构体中只存放一个指针，解决了占用空间的问题。现在又出现了另一个问题：数据结构不一致。显然，如果<code>hlist_node</code>采用传统的<code>next</code>, <code>prev</code>指针，对于第一个节点和后面其他节点的处理会不一致。这样并不优雅，而且效率上也有损失。</p>
<p><code>hlist_node</code>巧妙地将<code>pprev</code>指向上一个节点的<code>next</code>指针的地址，由于<code>hlist_head</code>和<code>hlist_node</code>指向的下一个节点的指针类型相同，这样就解决了通用性！</p>
<p>下面我们再来看一看<code>hlist_node</code>这样设计之后，插入、删除这些基本操作会有什么不一样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_del(<span class="keyword">struct</span> hlist_node *n)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> hlist_node *next = n-&gt;next;</div><div class="line">        <span class="keyword">struct</span> hlist_node **pprev = n-&gt;pprev;</div><div class="line">        *pprev = next;</div><div class="line">        <span class="keyword">if</span> (next)</div><div class="line">                next-&gt;pprev = pprev;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>__hlist_del</code>用于删除节点<code>n</code>。</p>
<p>首先获取<code>n</code>的下一个节点<code>next</code>，<code>n-&gt;pprev</code>指向<code>n</code>的前一个节点的<code>next</code>指针的地址，这样<code>*pprev</code>就代表<code>n</code>前一个节点的下一个节点（现在即<code>n</code>本身），第三行代码<code>*pprev=next;</code>就将<code>n</code>的前一个节点和下一个节点关联起来了。至此，<code>n</code> 节点的前一个节点的关联工作就完成了，现在再来完成后一个节点的关联工作。如果<code>n</code>是链表的最后一个节点，那么<code>n-&gt;next</code>即为空，则无需任何操作，否则，<code>next-&gt;pprev = pprev</code>。</p>
<p>给链表增加一个节点需要考虑两个条件：</p>
<ol>
<li>链表首节点</li>
<li>链表普通节点</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span></div><div class="line"> &#123;</div><div class="line">         <span class="keyword">struct</span> hlist_node *first = h-&gt;first;</div><div class="line">         n-&gt;next = first;</div><div class="line">         <span class="keyword">if</span> (first)</div><div class="line">                 first-&gt;pprev = &amp;n-&gt;next;</div><div class="line">         h-&gt;first = n;</div><div class="line">         n-&gt;pprev = &amp;h-&gt;first;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>首先讨论条件1：<br><code>first = h-&gt;first;</code>获取当前链表的首个节点；<br><code>n-&gt;next = fist;</code> 将<code>n</code>作为链表的首个节点，让<code>first</code>往后靠；<br>先来看最后一行<code>n-&gt;pprev = &amp;h-&gt;first;</code>将<code>n</code>的<code>pprev</code>指向<code>hlist_head</code>的<code>first</code>指针，至此关于节点<code>n</code>的关联工作就做完了。<br>再来看倒数第二行<code>h-&gt;first = n;</code>将节点<code>h</code>的关联工作做完；<br>最后我们再来看原先的第一个节点的关联工作，对于它来说，仅仅需要更新一下<code>pprev</code>的关联信息：<code>first-&gt;pprev = &amp;n-&gt;next;</code></p>
<p>接下来讨论条件2，这里也包括两种情况：<br>a) 插在当前节点的前面<br>b) 插在当前节点的后面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* next must be != NULL */</span></div><div class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_before</span><span class="params">(<span class="keyword">struct</span> hlist_node *n,</span></span></div><div class="line">                                         <span class="keyword">struct</span> hlist_node *next)</div><div class="line"> &#123;</div><div class="line">         n-&gt;pprev = next-&gt;pprev;</div><div class="line">         n-&gt;next = next;</div><div class="line">         next-&gt;pprev = &amp;n-&gt;next;</div><div class="line">         *(n-&gt;pprev) = n;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>先讨论情况 a)：将节点<code>n</code>插到<code>next</code>之前（<code>n</code>是新插入的节点)</p>
<p>还是一个一个节点的搞定（一共三个节点），先搞定节点<code>n</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n-&gt;pprev = next-&gt;prev;</div></pre></td></tr></table></figure>
<p>将<code>next</code>的<code>pprev</code>赋值给<code>n-&gt;pprev</code>，<code>n</code>取代<code>next</code>的位置，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n-&gt;next = next;</div></pre></td></tr></table></figure>
<p>将<code>next</code>作为<code>n</code>的下一个节点，至此节点<code>n</code>的关联动作完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">next-&gt;pprev = &amp;n-&gt;next;</div></pre></td></tr></table></figure>
<p><code>next</code>的关联动作完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(n-&gt;pprev) = n;</div></pre></td></tr></table></figure>
<p><code>n-&gt;pprev</code>表示<code>n</code>的前一个节点的next指针，<code>*(n-&gt;pprev)</code>则表示<code>n</code>的前一个节点<code>next</code>指针所指向下一个节点的内容，这里将<code>n</code>赋值给它，正好完成它的关联工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_after</span><span class="params">(<span class="keyword">struct</span> hlist_node *n,</span></span></div><div class="line">                                         <span class="keyword">struct</span> hlist_node *next)</div><div class="line"> &#123;</div><div class="line">         next-&gt;next = n-&gt;next;</div><div class="line">         n-&gt;next = next;</div><div class="line">         next-&gt;pprev = &amp;n-&gt;next;</div><div class="line"></div><div class="line">         <span class="keyword">if</span>(next-&gt;next)</div><div class="line">                 next-&gt;next-&gt;pprev  = &amp;next-&gt;next;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>再来看情况 b)：将结点<code>next</code>插入到n之后(<code>next</code>是新插入的节点）<br>具体步骤就不分析了，应该也很容易。</p>
<p>下面我还要介绍一个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_unhashed</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> hlist_node *h)</span></span></div><div class="line"> &#123;</div><div class="line">         <span class="keyword">return</span> !h-&gt;pprev;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的目的是判断该节点是否已经存在hash表中。这里处理得很巧妙，判断指向前一个节点的next指针的地址是否为空。</p>
<h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p><strong>初始化</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD(name) struct hlist_head name = &#123;  .first = NULL &#125;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_HLIST_NODE</span><span class="params">(<span class="keyword">struct</span> hlist_node *h)</span></span></div><div class="line">&#123;</div><div class="line">        h-&gt;next = <span class="literal">NULL</span>;</div><div class="line">        h-&gt;pprev = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>链表判空</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_empty</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> hlist_head *h)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">return</span> !h-&gt;first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>节点删除</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_del</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        __hlist_del(n);</div><div class="line">        n-&gt;next = LIST_POISON1;</div><div class="line">        n-&gt;pprev = LIST_POISON2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_del_init</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> (!hlist_unhashed(n)) &#123;</div><div class="line">                __hlist_del(n);</div><div class="line">                INIT_HLIST_NODE(n);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><p><strong>hlist_entry</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr,type,member)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry_safe(ptr, type, member) \</span></div><div class="line">        (&#123; typeof(ptr) ____ptr = (ptr); \</div><div class="line">           ____ptr ? hlist_entry(____ptr, type, member) : NULL; \</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
<p><strong>hlist_for_each</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \</span></div><div class="line">        for (pos = (head)-&gt;first; pos ; pos = pos-&gt;next)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_safe(pos, n, head) \</span></div><div class="line">        for (pos = (head)-&gt;first; pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;); \</div><div class="line">             pos = n)</div></pre></td></tr></table></figure>
<p><strong>hlist_for_each_entry</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * hlist_for_each_entry - iterate over list of given type</div><div class="line"> * @pos:        the type * to use as a loop cursor.</div><div class="line"> * @head:       the head for your list.</div><div class="line"> * @member:     the name of the hlist_node within the struct.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry(pos, head, member)                         \</span></div><div class="line">        for (pos = hlist_entry_safe((head)-&gt;first, typeof(*(pos)), member);\</div><div class="line">             pos;                                                       \</div><div class="line">             pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * hlist_for_each_entry_continue - iterate over a hlist continuing after current point</div><div class="line"> * @pos:        the type * to use as a loop cursor.</div><div class="line"> * @member:     the name of the hlist_node within the struct.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_continue(pos, member)                      \</span></div><div class="line">        for (pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member);\</div><div class="line">             pos;                                                       \</div><div class="line">             pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * hlist_for_each_entry_from - iterate over a hlist continuing from current point</div><div class="line"> * @pos:        the type * to use as a loop cursor.</div><div class="line"> * @member:     the name of the hlist_node within the struct.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_from(pos, member)                          \</span></div><div class="line">        for (; pos;                                                     \</div><div class="line">             pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry</div><div class="line"> * @pos:        the type * to use as a loop cursor.</div><div class="line"> * @n:          another &amp;struct hlist_node to use as temporary storage</div><div class="line"> * @head:       the head for your list.</div><div class="line"> * @member:     the name of the hlist_node within the struct.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_safe(pos, n, head, member)                 \</span></div><div class="line">        for (pos = hlist_entry_safe((head)-&gt;first, typeof(*pos), member);\</div><div class="line">             pos &amp;&amp; (&#123; n = pos-&gt;member.next; 1; &#125;);                     \</div><div class="line">             pos = hlist_entry_safe(n, typeof(*pos), member))</div></pre></td></tr></table></figure>
<h2 id="参考原文"><a href="#参考原文" class="headerlink" title="参考原文"></a>参考原文</h2><p><a href="http://blog.csdn.net/zhanglei4214/article/details/6767288" target="_blank" rel="external">linux内核hlist分析</a><br><a href="http://blog.csdn.net/ronliu/article/details/6425368" target="_blank" rel="external">内核数据结构：hlist_head </a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux内核链表之list_head]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list-head/</url>
      <content type="html"><![CDATA[<p>在linux内核中，有一种通用的双向循环链表，构成了各种队列的基础。链表的结构定义和相关函数均在include/linux/list.h中。</p>
<p>在阅读<code>list.h</code>文件之前，有一点必须注意：linux内核中的链表使用方法和一般数据结构中定义的链表是有所不同的。</p>
<p>一般的双向链表一般是如下的结构，</p>
<ul>
<li>有个单独的头结点(<code>head</code>)</li>
<li>每个节点(<code>node</code>)除了包含必要的数据之外，还有2个指针(<code>pre</code>,<code>next</code>)</li>
<li><code>pre</code>指针指向前一个节点(<code>node</code>)，<code>next</code>指针指向后一个节点(<code>node</code>)</li>
<li>头结点(<code>head</code>)的<code>pre</code>指针指向链表的最后一个节点</li>
<li>最后一个节点的<code>next</code>指针指向头结点(<code>head</code>)</li>
</ul>
<p>具体见下图：<br><img src="/kernel/内核数据结构/list-head/dlist.png" alt="dlist.png" title=""><br><a id="more"></a></p>
<p>传统的链表有个最大的缺点就是不好共通化，因为每个<code>node</code>中的<code>data1</code>，<code>data2</code>等等都是不确定的(无论是个数还是类型)。</p>
<p>linux中的链表巧妙的解决了这个问题，linux的链表不是将用户数据保存（嵌入）在链表节点中，而是将链表节点保存（嵌入）在用户数据中。</p>
<p>linux的链表节点只有2个指针(<code>pre</code>和<code>next</code>)，这样的话，链表的节点将独立于用户数据之外，便于实现链表的共同操作。</p>
<p>具体见下图：<br><img src="/kernel/内核数据结构/list-head/dlist_kernel.png" alt="dlist_kernel.png" title=""></p>
<p>linux链表中的最大问题是怎样通过链表的节点来取得用户数据？<br>和传统的链表不同，linux的链表节点(node)中没有包含用户的用户<code>data1</code>，<code>data2</code>等。</p>
<p>下面就来全面的介绍这一链表的各种API。</p>
<h2 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> list_head &#123;</div><div class="line">	<span class="keyword">struct</span> list_head *next, *prev;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这是链表的元素结构。因为是循环链表，表头和节点都是这一结构。有<code>prev</code>和<code>next</code>两个指针域，分别指向链表中前一节点和后一节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></div><div class="line">	struct list_head name = LIST_HEAD_INIT(name)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">list</span>-&gt;next = <span class="built_in">list</span>;</div><div class="line">	<span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化链表，链表头的<code>prev</code>和<code>next</code>都指向自身。</p>
<h2 id="链表修改"><a href="#链表修改" class="headerlink" title="链表修改"></a>链表修改</h2><p><strong>插入</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(<span class="keyword">struct</span> list_head *<span class="keyword">new</span>,</div><div class="line">			      <span class="keyword">struct</span> list_head *prev,</div><div class="line">			      <span class="keyword">struct</span> list_head *next)</div><div class="line">&#123;</div><div class="line">	next-&gt;prev = <span class="keyword">new</span>;</div><div class="line">	<span class="keyword">new</span>-&gt;next = next;</div><div class="line">	<span class="keyword">new</span>-&gt;prev = prev;</div><div class="line">	prev-&gt;next = <span class="keyword">new</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="keyword">new</span>, <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	__list_add(<span class="keyword">new</span>, head, head-&gt;next);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="keyword">new</span>, <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	__list_add(<span class="keyword">new</span>, head-&gt;prev, head);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>双向循环链表的实现，很少有例外情况，基本都可以用公共的方式来处理。这里无论是加第一个节点，还是其它的节点，使用的方法都一样。</p>
<p>另外，链表API实现时大致都是分为两层：一层外部的，如<code>list_add</code>、<code>list_add_tail</code>，用来消除一些例外情况，调用内部实现；一层是内部的，函数名前会加双下划线，如<code>__list_add</code>，往往是几个操作公共的部分，或者排除例外后的实现。</p>
<p><strong>删除</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(<span class="keyword">struct</span> list_head * prev, <span class="keyword">struct</span> list_head * next)</div><div class="line">&#123;</div><div class="line">	next-&gt;prev = prev;</div><div class="line">	prev-&gt;next = next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span></div><div class="line">&#123;</div><div class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</div><div class="line">	entry-&gt;next = LIST_POISON1;</div><div class="line">	entry-&gt;prev = LIST_POISON2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span></div><div class="line">&#123;</div><div class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</div><div class="line">	INIT_LIST_HEAD(entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_del</code>是链表中节点的删除。之所以在调用<code>__list_del</code>后又把被删除元素的<code>next</code>、<code>prev</code>指向特殊的<code>LIST_POSITION1</code>和<code>LIST_POSITION2</code>，是为了调试未定义的指针。</p>
<p><code>list_del_init</code>则是删除节点后，随即把节点中指针再次初始化，这种删除方式更为实用。</p>
<p><strong>替换</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span></div><div class="line">				<span class="keyword">struct</span> list_head *<span class="keyword">new</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">new</span>-&gt;next = old-&gt;next;</div><div class="line">	<span class="keyword">new</span>-&gt;next-&gt;prev = <span class="keyword">new</span>;</div><div class="line">	<span class="keyword">new</span>-&gt;prev = old-&gt;prev;</div><div class="line">	<span class="keyword">new</span>-&gt;prev-&gt;next = <span class="keyword">new</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace_init</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span></div><div class="line">					<span class="keyword">struct</span> list_head *<span class="keyword">new</span>)</div><div class="line">&#123;</div><div class="line">	list_replace(old, <span class="keyword">new</span>);</div><div class="line">	INIT_LIST_HEAD(old);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_replace</code>是将链表中一个节点<code>old</code>，替换为另一个节点<code>new</code>。从实现来看，即使<code>old</code>所在地链表只有<code>old</code>一个节点，<code>new</code>也可以成功替换，这就是双向循环链表可怕的通用之处。</p>
<p><code>list_replace_init</code>将被替换的<code>old</code>随即又初始化。</p>
<p><strong>搬移</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_move</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	__list_del(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>-&gt;next);</div><div class="line">	list_add(<span class="built_in">list</span>, head);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_move_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">				  <span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	__list_del(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>-&gt;next);</div><div class="line">	list_add_tail(<span class="built_in">list</span>, head);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_move</code>的作用是把<code>list</code>节点从原链表中去除，并加入新的链表<code>head</code>中。</p>
<p><code>list_move_tail</code>只在加入新链表时与<code>list_move</code>有所不同，<code>list_move</code>是加到<span style="color:red;">head之后</span>的链表<span style="color:red;">头部</span>，而<code>list_move_tail</code>是加到<span style="color:red;">head之前</span>的链表<span style="color:red;">尾部</span>。</p>
<p><strong>拆分</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_cut_position(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</div><div class="line">		<span class="keyword">struct</span> list_head *head, <span class="keyword">struct</span> list_head *entry)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> list_head *new_first = entry-&gt;next;</div><div class="line">	<span class="built_in">list</span>-&gt;next = head-&gt;next;</div><div class="line">	<span class="built_in">list</span>-&gt;next-&gt;prev = <span class="built_in">list</span>;</div><div class="line">	<span class="built_in">list</span>-&gt;prev = entry;</div><div class="line">	entry-&gt;next = <span class="built_in">list</span>;</div><div class="line">	head-&gt;next = new_first;</div><div class="line">	new_first-&gt;prev = head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_cut_position</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">		<span class="keyword">struct</span> list_head *head, <span class="keyword">struct</span> list_head *entry)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (list_empty(head))</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span> (list_is_singular(head) &amp;&amp;</div><div class="line">		(head-&gt;next != entry &amp;&amp; head != entry))</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span> (entry == head)</div><div class="line">		INIT_LIST_HEAD(<span class="built_in">list</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		__list_cut_position(<span class="built_in">list</span>, head, entry);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_cut_position</code>用于把<code>head</code>链表分为两个部分。<code>head</code>链表中的<code>head-&gt;next</code>一直到<code>entry</code>（包括<code>entry</code>）被删除，并加入到新链表<code>list</code>的头部。新链表<code>list</code>应该是空的，或者原来的节点都可以被忽略掉。可以看到，<code>list_cut_position</code>中排除了一些意外情况，保证调用<code>__list_cut_position</code>时至少有一个元素会被加入到新链表<code>list</code>。</p>
<p><strong>合并</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_splice(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</div><div class="line">				 <span class="keyword">struct</span> list_head *prev,</div><div class="line">				 <span class="keyword">struct</span> list_head *next)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> list_head *first = <span class="built_in">list</span>-&gt;next;</div><div class="line">	<span class="keyword">struct</span> list_head *last = <span class="built_in">list</span>-&gt;prev;</div><div class="line"></div><div class="line">	first-&gt;prev = prev;</div><div class="line">	prev-&gt;next = first;</div><div class="line"></div><div class="line">	last-&gt;next = next;</div><div class="line">	next-&gt;prev = last;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">				<span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>))</div><div class="line">		__list_splice(<span class="built_in">list</span>, head, head-&gt;next);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">				<span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>))</div><div class="line">		__list_splice(<span class="built_in">list</span>, head-&gt;prev, head);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_splice</code>的功能和<code>list_cut_position</code>正相反，它合并两个链表。<code>list_splice</code>把<code>list</code>链表中的节点加入<code>head</code>链表中。在实际操作之前，要先判断<code>list</code>链表是否为空。它保证调用<code>__list_splice</code>时<code>list</code>链表中至少有一个节点可以被合并到<code>head</code>链表中。</p>
<p><code>list_splice_tail</code>只是在合并链表时插入的位置不同。<code>list_splice</code>是把原来<code>list</code>链表中的节点全加到<code>head</code>链表的头部，而<code>list_splice_tail</code>则是把原来<code>list</code>链表中的节点全加到head链表的尾部。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_init</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">				    <span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>)) &#123;</div><div class="line">		__list_splice(<span class="built_in">list</span>, head, head-&gt;next);</div><div class="line">		INIT_LIST_HEAD(<span class="built_in">list</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_tail_init</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">					 <span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>)) &#123;</div><div class="line">		__list_splice(<span class="built_in">list</span>, head-&gt;prev, head);</div><div class="line">		INIT_LIST_HEAD(<span class="built_in">list</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_splice_init</code>除了完成<code>list_splice</code>的功能，还把变空了的<code>list</code>链表头重新初始化。</p>
<p><code>list_splice_tail_init</code>除了完成<code>list_splice_tail</code>的功能，还把变空了得<code>list</code>链表头重新初始化。</p>
<p>list操作的API大致如以上所列，包括链表节点添加与删除、节点从一个链表转移到另一个链表、链表中一个节点被替换为另一个节点、链表的合并与拆分、查看链表当前是否为空或者只有一个节点。</p>
<h2 id="链表判断"><a href="#链表判断" class="headerlink" title="链表判断"></a>链表判断</h2><p><strong>表尾</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_last</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span></div><div class="line">				<span class="keyword">const</span> <span class="keyword">struct</span> list_head *head)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">list</span>-&gt;next == head;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_is_last</code>判断<code>list</code>是否处于<code>head</code>链表的尾部。</p>
<p><strong>空链表</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> head-&gt;next == head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty_careful</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> list_head *next = head-&gt;next;</div><div class="line">	<span class="keyword">return</span> (next == head) &amp;&amp; (next == head-&gt;prev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_empty</code>判断<code>head</code>链表是否为空，为空的意思就是只有一个链表头<code>head</code>。</p>
<p><code>list_empty_careful</code>同样是判断<code>head</code>链表是否为空，只是检查更为严格。</p>
<p><strong>单节点</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_singular</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> list_head *head)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>list_is_singular</code>判断<code>head</code>中是否只有一个节点，即除链表头<code>head</code>外只有一个节点。</p>
<h2 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h2><p>遍历是链表最经常的操作之一，为了方便核心应用遍历链表，Linux链表将遍历操作抽象成几个宏。在介绍遍历宏之前，我们先看看如何从链表中访问到我们真正需要的数据项。</p>
<p><strong>list_entry</strong></p>
<p>我们知道，Linux 链表中仅保存了数据项结构中 <code>list_head</code> 成员变量的地址，那么我们如何通过这个<code>list_head</code>成员访问到作为它的所有者的节点数据呢？ Linux 为此提供了一个<code>list_entry(ptr,type,member)</code>宏，其中<code>ptr</code>是指向该数据中<code>list_head</code>成员的指针，也就是存储在链表中的地址值，<code>type</code>是数据项的类型，<code>member</code>则是数据项类型定义中<code>list_head</code>成员的变量名，例如，我们要访问<code>nf_sockopts</code>链表中首个<code>nf_sockopt_ops</code>变量，则如此调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list_entry(nf_sockopts-&gt;next, <span class="keyword">struct</span> nf_sockopt_ops, <span class="built_in">list</span>);</div></pre></td></tr></table></figure></p>
<p>这里<code>list</code>正是<code>nf_sockopt_ops</code>结构中定义的用于链表操作的节点成员变量名。</p>
<p><code>list_entry</code>的使用相当简单，相比之下，它的实现则有一些难懂：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></div><div class="line">	container_of(ptr, type, member)</div></pre></td></tr></table></figure></p>
<p><code>container_of</code>宏定义在[include/linux/kernel.h]中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;			\</span></div><div class="line">        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\</div><div class="line">        (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</div></pre></td></tr></table></figure></p>
<p><code>offsetof</code>宏定义在[include/linux/stddef.h]中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></div></pre></td></tr></table></figure></p>
<p><code>size_t</code>最终定义为<code>unsigned int</code>（注：i386平台）。</p>
<p>这里使用的是一个利用编译器技术的小技巧，即先求得结构成员在与结构中的偏移量，然后根据成员变量的地址反过来得出属主结构变量的地址。</p>
<p><code>container_of()</code>和<code>offsetof()</code>并不仅用于链表操作，这里最有趣的地方是<code>((type *)0)-&gt;member</code>，它将<code>0</code>地址强制”转换”为<code>type</code>结构的指针，再访问到<code>type</code>结构中的<code>member</code>成员。在<code>container_of</code>宏中，它用来给<code>typeof()</code>提供参数（<code>typeof()</code>是gcc的扩展，和<code>sizeof()</code>类似 ），以获<code>member</code>成员的数据类型；在<code>offsetof()</code>中，这个<code>member</code>成员的地址实际上就是<code>type</code> 数据结构中<code>member</code>成员相对于结构变量的偏移量。</p>
<p>如果这么说还不好理解的话，不妨看看下面这张图：<code>offsetof()</code>宏的原理<br><img src="/kernel/内核数据结构/list-head/offsetof.gif" alt="offsetof.gif" title=""></p>
<p>对于给定一个结构，<code>offsetof(type,member)</code>是一个常量，<code>list_entry()</code>正是利用这个不变的偏移量来求得链表数据项的变量地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, member) \</span></div><div class="line">	list_entry((ptr)-&gt;next, type, member)</div></pre></td></tr></table></figure></p>
<p><code>list_first_entry</code>是将<code>ptr</code>看完一个链表的链表头，取出其中第一个节点对应的结构地址。使用<code>list_first_entry</code>是应保证链表中至少有一个节点。</p>
<p><strong>list_for_each</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></div><div class="line">	for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \</div><div class="line">        	pos = pos-&gt;next)</div></pre></td></tr></table></figure></p>
<p><code>list_for_each</code>循环遍历链表中的每个节点，从链表头部的第一个节点，一直到链表尾部。中间的<code>prefetch</code>是为了利用平台特性加速链表遍历，在某些平台下定义为空，可以忽略。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __list_for_each(pos, head) \</span></div><div class="line">	for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</div></pre></td></tr></table></figure></p>
<p><code>__list_for_each</code>与<code>list_for_each</code>没什么不同，只是少了<code>prefetch</code>的内容，实现上更为简单易懂。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></div><div class="line">	for (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \</div><div class="line">        	pos = pos-&gt;prev)</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_prev</code>与<code>list_for_each</code>的遍历顺序相反，从链表尾逆向遍历到链表头。</p>
<p><strong>list_for_each_safe</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></div><div class="line">	for (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \</div><div class="line">		pos = n, n = pos-&gt;next)</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_safe</code>也是链表顺序遍历，只是更加安全。即使在遍历过程中，当前节点从链表中删除，也不会影响链表的遍历。参数上需要加一个暂存的链表节点指针<code>n</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></div><div class="line">	for (pos = (head)-&gt;prev, n = pos-&gt;prev; \</div><div class="line">	     prefetch(pos-&gt;prev), pos != (head); \</div><div class="line">	     pos = n, n = pos-&gt;prev)</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_prev_safe</code>与<code>list_for_each_prev</code>同样是链表逆序遍历，只是加了链表节点删除保护。</p>
<p><strong>list_for_each_entry</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)				\</span></div><div class="line">	for (pos = list_entry((head)-&gt;next, typeof(*pos), member);	\</div><div class="line">	     prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); 	\</div><div class="line">	     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry</code>是遍历链表节点，而是遍历链表节点所有者的数据结构。这个实现上较为复杂，但可以等价于 <span style="color:red;">list_for_each</span> 加上 <span style="color:red;">list_entry</span> 的组合。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member)			\</span></div><div class="line">	for (pos = list_entry((head)-&gt;prev, typeof(*pos), member);	\</div><div class="line">	     prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head); 	\</div><div class="line">	     pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_reverse</code>是逆序遍历链表节点所有者的数据结构，等价于 <code>list_for_each_prev</code>加上<code>list_etnry</code>的组合。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member) 		\</span></div><div class="line">	for (pos = list_entry(pos-&gt;member.next, typeof(*pos), member);	\</div><div class="line">	     prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);	\</div><div class="line">	     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_continue</code>也是遍历链表上的节点所有者的数据结构。只是并非从链表头开始，而是从结构指针的下一个结构开始，一直到链表尾部。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member)		\</span></div><div class="line">	for (pos = list_entry(pos-&gt;member.prev, typeof(*pos), member);	\</div><div class="line">	     prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head);	\</div><div class="line">	     pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_continue_reverse</code>是逆序遍历链表上的节点所有者的数据结构。只是并非从链表尾开始，而是从结构指针的前一个结构开始，一直到链表头部。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member) 			\</span></div><div class="line">	for (; prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);	\</div><div class="line">	     pos = list_entry(pos-&gt;member.next, typeof(*pos), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_from</code>是从当前结构指针pos开始，顺序遍历链表上的结构指针。</p>
<p><strong>list_for_each_entry_safe</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></div><div class="line">	for (pos = list_entry((head)-&gt;next, typeof(*pos), member),	\</div><div class="line">		n = list_entry(pos-&gt;member.next, typeof(*pos), member);	\</div><div class="line">	     &amp;pos-&gt;member != (head); 					\</div><div class="line">	     pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_safe</code>也是顺序遍历链表上节点所有者的数据结构。只是加了删除节点的保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_continue(pos, n, head, member) 		\</span></div><div class="line">	for (pos = list_entry(pos-&gt;member.next, typeof(*pos), member), 		\</div><div class="line">		n = list_entry(pos-&gt;member.next, typeof(*pos), member);		\</div><div class="line">	     &amp;pos-&gt;member != (head);						\</div><div class="line">	     pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_safe_continue</code>是从pos的下一个结构指针开始，顺序遍历链表上的结构指针，同时加了节点删除保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_from(pos, n, head, member) 			\</span></div><div class="line">	for (n = list_entry(pos-&gt;member.next, typeof(*pos), member);		\</div><div class="line">	     &amp;pos-&gt;member != (head);						\</div><div class="line">	     pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_safe_from</code>是从pos开始，顺序遍历链表上的结构指针，同时加了节点删除保护。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_reverse(pos, n, head, member)		\</span></div><div class="line">	for (pos = list_entry((head)-&gt;prev, typeof(*pos), member),	\</div><div class="line">		n = list_entry(pos-&gt;member.prev, typeof(*pos), member);	\</div><div class="line">	     &amp;pos-&gt;member != (head); 					\</div><div class="line">	     pos = n, n = list_entry(n-&gt;member.prev, typeof(*n), member))</div></pre></td></tr></table></figure></p>
<p><code>list_for_each_entry_safe_reverse</code>是从pos的前一个结构指针开始，逆序遍历链表上的结构指针，同时加了节点删除保护。</p>
<p>至此为止，我们介绍了linux中双向循环链表的结构、所有的操作函数和遍历宏定义。相信以后在linux代码中遇到链表的使用，不会再陌生。</p>
<h2 id="参考原文"><a href="#参考原文" class="headerlink" title="参考原文"></a>参考原文</h2><p><a href="http://blog.csdn.net/qb_2008/article/details/6839230" target="_blank" rel="external">linux内核部件分析（一）——连通世界的list </a><br><a href="https://www.ibm.com/developerworks/cn/linux/kernel/l-chain/" target="_blank" rel="external">深入分析 Linux 内核链表</a><br><a href="http://www.cnblogs.com/wang_yb/archive/2013/04/16/3023892.html" target="_blank" rel="external">《Linux内核设计与实现》读书笔记（六）- 内核数据结构</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[记录内核对象生命周期的kref]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/kref/</url>
      <content type="html"><![CDATA[<p>参考原文链接：<a href="http://blog.csdn.net/qb_2008/article/details/6840387" target="_blank" rel="external">linux内核部件分析（三）——记录生命周期的kref</a><br>另外关于kref的使用可参考：<br><a href="http://www.cnblogs.com/wwang/archive/2010/12/02/1894847.html" target="_blank" rel="external">Linux内核里的“智能指针”</a><br><a href="http://www.cnblogs.com/wwang/archive/2010/12/03/1895852.html" target="_blank" rel="external">Linux内核里的“智能指针” (续)</a></p>
<p><code>kref</code>是一个引用计数器，它被嵌套进其它的结构中，记录所嵌套结构的引用计数，并在计数为0时调用相应的清理函数。<code>kref</code>的原理和实现都非常简单，但要想用好却不容易，或者说<code>kref</code>被创建就是为了跟踪复杂情况下结构的引用和销毁。所以这里先介绍<code>kref</code>的实现，再介绍其使用规则。<br><a id="more"></a></p>
<h3 id="kref-的定义实现"><a href="#kref-的定义实现" class="headerlink" title="kref 的定义实现"></a>kref 的定义实现</h3><p><code>kref</code>的头文件在<code>include/linux/kref.h</code>，实现在<code>lib/kref.c</code>。</p>
<p><code>kref</code>的定义非常简单，其结构体里只有一个原子变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kref &#123;</div><div class="line">    <span class="keyword">atomic_t</span> refcount;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Linux内核定义了下面三个函数接口来使用<code>kref</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void kref_init(struct kref *kref);</div><div class="line">void kref_get(struct kref *kref);</div><div class="line">int kref_put(struct kref *kref, void (*release) (struct kref *kref));</div></pre></td></tr></table></figure></p>
<p><code>kref_init</code> 初始化<code>kref</code>的计数值为1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kref_init - initialize object.</div><div class="line"> * @kref: object in question.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kref_init</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span></div><div class="line">&#123;</div><div class="line">	atomic_set(&amp;kref-&gt;refcount,<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>kref_get</code> 递增<code>kref</code>的计数值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kref_get - increment refcount for object.</div><div class="line"> * @kref: object.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kref_get</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span></div><div class="line">&#123;</div><div class="line">	WARN_ON(!atomic_read(&amp;kref-&gt;refcount));</div><div class="line">	atomic_inc(&amp;kref-&gt;refcount);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>kref_put</code> 递减<code>kref</code>的计数值，如果计数值减为0，说明<code>kref</code>所指向的结构生命周期结束，会执行<code>release</code>释放函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * kref_put - decrement refcount for object.</div><div class="line"> * @kref: object.</div><div class="line"> * @release: pointer to the function that will clean up the object when the</div><div class="line"> *	     last reference to the object is released.</div><div class="line"> *	     This pointer is required, and it is not acceptable to pass kfree</div><div class="line"> *	     in as this function.</div><div class="line"> *</div><div class="line"> * Decrement the refcount, and if 0, call release().</div><div class="line"> * Return 1 if the object was removed, otherwise return 0\.  Beware, if this</div><div class="line"> * function returns 0, you still can not count on the kref from remaining in</div><div class="line"> * memory.  Only use the return value if you want to see if the kref is now</div><div class="line"> * gone, not present.</div><div class="line"> */</div><div class="line">int kref_put(struct kref *kref, void (*release)(struct kref *kref))</div><div class="line">&#123;</div><div class="line">	WARN_ON(release == NULL);</div><div class="line">	WARN_ON(release == (void (*)(struct kref *))kfree);</div><div class="line"></div><div class="line">	if (atomic_dec_and_test(&amp;kref-&gt;refcount)) &#123;</div><div class="line">		release(kref);</div><div class="line">		return 1;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="kref-的使用"><a href="#kref-的使用" class="headerlink" title="kref 的使用"></a>kref 的使用</h3><p><code>kref</code>设计得如此简单，是为了能灵活地用在各种结构的生命周期管理中。要用好它可不简单，好在Documentation/kref.txt中为我们总结了一些使用规则，下面简单翻译一下。</p>
<p>对于那些用在多种场合，被到处传递的结构，如果没有引用计数，bug几乎总是肯定的事。所以我们需要<code>kref</code>，<code>kref</code>允许我们在已有的结构中方便地添加引用计数。</p>
<p>你可以以如下方式添加<code>kref</code>到你的数据结构中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> my_data &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">struct</span> kref refcount;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>kref</code>可以出现在你结构中的任意位置。</p>
<p>在分配<code>kref</code>后你必须初始化它，可以调用<code>kref_init</code>，把<code>kref</code>计数值初始为1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> my_data *data;</div><div class="line"></div><div class="line">data = kmalloc(<span class="keyword">sizeof</span>(*data), GFP_KERNEL);</div><div class="line"><span class="keyword">if</span>(!data)</div><div class="line">    <span class="keyword">return</span> -ENOMEM;</div><div class="line">kref_init(&amp;data-&gt;refcount);</div></pre></td></tr></table></figure></p>
<p>初始化之后，<code>kref</code>的使用应该遵循以下三条规则：</p>
<p>1） 如果你创建了一个结构指针的非暂时性副本，特别是当这个副本指针会被传递到其它执行线程时，你必须在传递副本指针之前执行kref_get：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kref_put(&amp;data-&gt;refcount);</div></pre></td></tr></table></figure></p>
<p>2）当你使用完，不再需要结构的指针，必须执行kref_put。如果这是结构指针的最后一个引用，release函数将会被调用。如果代码绝不会在没有拥有引用计数的请求下去调用kref_get，在kref_put时就不需要加锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kref_put(&amp;data-&gt;refcount, data_release);</div></pre></td></tr></table></figure></p>
<p>3）如果代码试图在还没拥有引用计数的情况下就调用kref_get，就必须串行化kref_put和kref_get的执行。因为很可能在kref_get执行之前或者执行中，kref_put就被调用并把整个结构释放掉了。</p>
<p>例如，你分配了一些数据并把它传递到其它线程去处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_release</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> my_data *data = container_of(kref, <span class="keyword">struct</span> my_data, refcount);</div><div class="line">    kree(data);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">more_data_handling</span><span class="params">(<span class="keyword">void</span> *cb_data)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> my_data *data = cb_data;</div><div class="line">    .</div><div class="line">    .  <span class="keyword">do</span> stuff with data here</div><div class="line">    .</div><div class="line">    kref_put(&amp;data-&gt;refcount, data_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_data_handler</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</div><div class="line">    <span class="keyword">struct</span> my_data *data;</div><div class="line">    <span class="keyword">struct</span> task_struct *task;</div><div class="line">    data = kmalloc(<span class="keyword">sizeof</span>(*data), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (!data)</div><div class="line">        <span class="keyword">return</span> -ENOMEM;</div><div class="line">    kref_init(&amp;data-&gt;refcount);</div><div class="line">    kref_get(&amp;data-&gt;refcount);</div><div class="line">    task = kthread_run(more_data_handling, data, <span class="string">"more_data_handling"</span>);</div><div class="line">    <span class="keyword">if</span> (task == ERR_PTR(-ENOMEM))&#123;</div><div class="line">         rv = -ENOMEM;</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line">    .</div><div class="line">    .  <span class="keyword">do</span> stuff with data here</div><div class="line">    .</div><div class="line">out:</div><div class="line">    kref_put(&amp;data-&gt;refcount, data_release);</div><div class="line">    <span class="keyword">return</span> rv;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做，无论两个线程的执行顺序是怎样的都无所谓，<code>kref_put</code>知道何时数据不再有引用计数，可以被销毁。<code>kref_get()</code>调用不需要加锁，因为在<code>my_data_handler</code>中调用<code>kref_get</code>时已经拥有一个引用。同样地原因，<code>kref_put</code>也不需要加锁。</p>
<p>要注意规则一中的要求，必须在传递指针之前调用<code>kref_get</code>。决不能写下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">task = kthread_run(more_data_handling, data, <span class="string">"more_data_handling"</span>);</div><div class="line"><span class="keyword">if</span>(task == ERR_PTR(-ENOMEM)) &#123;</div><div class="line">    rv = -ENOMEM;</div><div class="line">    <span class="keyword">goto</span> out;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">/* BAD BAD BAD - get is after the handoff */</span></div><div class="line">    kref_get(&amp;data-&gt;refcount);</div></pre></td></tr></table></figure></p>
<p>不要认为自己在使用上面的代码时知道自己在做什么。首先，你可能并不知道你在做什么。其次，你可能知道你在做什么（在部分加锁情况下上面的代码也是正确的），但一些修改或者复制你代码的人并不知道你在做什么。这是一种坏的使用方式。</p>
<p>当然在部分情况下也可以优化对<code>get</code>和<code>put</code>的使用。例如，你已经完成了对这个数据的处理，并要把它传递给其它线程，就不需要再做多余的<code>get</code>和<code>put</code>了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Silly extra get and put */</span></div><div class="line">kref_get(&amp;obj-&gt;ref);</div><div class="line">enqueue(obj);</div><div class="line">kref_put(&amp;obj-&gt;ref, obj_cleanup);</div></pre></td></tr></table></figure></p>
<p>只需要做enqueue操作即可，可以在其后加一条注释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enqueue(obj);</div><div class="line"><span class="comment">/* We are done with obj , so we pass our refcount off to the queue. DON'T TOUCH obj AFTER HERE! */</span></div></pre></td></tr></table></figure></p>
<p>第三条规则是处理起来最麻烦的。例如，你有一列数据，每条数据都有<code>kref</code>计数，你希望获取第一条数据。但你不能简单地把第一条数据从链表中取出并调用<code>kref_get</code>。这违背了第三条，在调用<code>kref_get</code>前你并没有一个引用。你需要增加一个<code>mutex</code>（或者其它锁）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_MUTEX</span><span class="params">(mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(q)</span></span>;</div><div class="line"><span class="keyword">struct</span> my_data</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> kref refcount;</div><div class="line">	<span class="keyword">struct</span> list_head link;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> my_data *<span class="title">get_entry</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> my_data *entry = <span class="literal">NULL</span>;</div><div class="line">	mutex_lock(&amp;mutex);</div><div class="line">	<span class="keyword">if</span>(!list_empty(&amp;q))&#123;</div><div class="line">		entry = container_of(q.next, <span class="keyword">struct</span> my_q_entry, link);</div><div class="line">		kref_get(&amp;entry-&gt;refcount);</div><div class="line">	&#125;</div><div class="line">	mutex_unlock(&amp;mutex);</div><div class="line">	<span class="keyword">return</span> entry;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release_entry</span><span class="params">(<span class="keyword">struct</span> kref *ref)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> my_data *entry = container_of(ref, <span class="keyword">struct</span> my_data, refcount);</div><div class="line"></div><div class="line">	list_del(&amp;entry-&gt;link);</div><div class="line">	kfree(entry);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_entry</span><span class="params">(<span class="keyword">struct</span> my_data *entry)</span></span></div><div class="line">&#123;</div><div class="line">	mutex_lock(&amp;mutex);</div><div class="line">	kref_put(&amp;entry-&gt;refcount, release_entry);</div><div class="line">	mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你不想在整个释放过程中都加锁，<code>kref_put</code>的返回值就有用了。例如你不想在加锁情况下调用<code>kfree</code>，你可以如下使用<code>kref_put</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release_entry</span><span class="params">(<span class="keyword">struct</span> kref *ref)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="comment">/* All work is done after the return from kref_put(). */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put_entry</span><span class="params">(<span class="keyword">struct</span> my_data *entry)</span></span></div><div class="line">&#123;</div><div class="line">        mutex_lock(&amp;mutex);</div><div class="line">        <span class="keyword">if</span> (kref_put(&amp;entry-&gt;refcount, release_entry)) &#123;</div><div class="line">                list_del(&amp;entry-&gt;link);</div><div class="line">                mutex_unlock(&amp;mutex);</div><div class="line">                kfree(entry);</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">                mutex_unlock(&amp;mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你在撤销结构的过程中需要调用其它的需要较长时间的函数，或者函数也可能要获取同样地互斥锁，这样做就很有用了。但要注意在<code>release</code>函数中做完撤销工作会使代码看起来更整洁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之平台设备]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/platform/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://m.blog.csdn.net/blog/guoshaobei/4971881" target="_blank" rel="external">http://m.blog.csdn.net/blog/guoshaobei/4971881</a><br>内核文档：Documentation/driver-model/platform.txt<br><a id="more"></a></p>
<h2 id="平台设备与驱动"><a href="#平台设备与驱动" class="headerlink" title="平台设备与驱动"></a>平台设备与驱动</h2><p>查看<linux platform_device.h="">中关于平台总线的驱动模型接口：平台设备和平台驱动。这个伪总线用于连接具有最小基础设施的总线上的设备，例如SOC上的用于集成外设的总线，或者是老式的PC互联总线，但是不包括大型的有规范定义的总线，比如PCI或者USB。</linux></p>
<h3 id="平台设备"><a href="#平台设备" class="headerlink" title="平台设备"></a>平台设备</h3><p>平台设备是系统中一些典型的自治设备(autonomous entities)。包括老式的基于端口的设备，外设总线上的北桥(host bridge)，以及SOC上的绝大多数控制器。罕见地，一个平台设备通过一段其他类型的总线连接到系统，而它的寄存器仍然是直接寻址的。</p>
<p>平台设备有一个’<code>name</code>‘域，用于驱动绑定；以及一个<code>resource</code>链表，诸如地址和IRQs。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_device &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>    *name;</div><div class="line">    u32        id;</div><div class="line">    <span class="keyword">struct</span> device    dev;</div><div class="line">    u32        num_resources;</div><div class="line">    <span class="keyword">struct</span> resource    *resource;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="平台驱动"><a href="#平台驱动" class="headerlink" title="平台驱动"></a>平台驱动</h3><p>平台驱动遵循标准驱动模型惯例，检测/枚举在驱动之外处理，而驱动提供<code>probe()</code>和<code>remove()</code>方法。它们使用标准惯例接口来支持电源管理和关闭通知。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_driver &#123;</div><div class="line">    <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</div><div class="line">    <span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</div><div class="line">    <span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</div><div class="line">    <span class="keyword">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="keyword">pm_message_t</span> state);</div><div class="line">    <span class="keyword">int</span> (*suspend_late)(<span class="keyword">struct</span> platform_device *, <span class="keyword">pm_message_t</span> state);</div><div class="line">    <span class="keyword">int</span> (*resume_early)(<span class="keyword">struct</span> platform_device *);</div><div class="line">    <span class="keyword">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</div><div class="line">    <span class="keyword">struct</span> device_driver driver;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>记住<code>probe()</code>函数应当验证指定的硬件设备的确存在；有时平台设置代码不能确认这一点。<code>probe()</code>能够使用设备的资源，包括时钟和设备平台数据(device platform_data)。</p>
<p>平台驱动用下面正常的方式来注册它们自己：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_driver_register</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span>;</div></pre></td></tr></table></figure></p>
<p>或者，在设备没有热插拔功能的情况下，<code>probe()</code>函数可以放置到init section，以减少驱动在运行时的内存过度占用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int platform_driver_probe(struct platform_driver *drv,</div><div class="line">          int (*probe)(struct platform_device *))</div></pre></td></tr></table></figure></p>
<h2 id="设备枚举"><a href="#设备枚举" class="headerlink" title="设备枚举"></a>设备枚举</h2><p>一般来说，平台相关(以及板极相关)的设置代码使用下列函数接口注册平台设备：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_add_devices</span><span class="params">(<span class="keyword">struct</span> platform_device **pdevs, <span class="keyword">int</span> ndev)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个通用规则仅注册那些实际存在的设备，但在一些案例里其他的设备也可以注册。例如，内核也许需要配置来驱动一个额外的网络适配器工作，但是这个适配器并不是在所有的目标板上实际存在；类似地，内核也许需要配置来驱动一个集成的控制器，但是这个控制器在一些目标板上并没有挂载任何实际外设。</p>
<p>在一些案例里，启动固件会导出一个表(tables)，来描述在一个给定的目标板上实际存在的设备。没有这样的表的话，通常系统设置代码来设置设备的唯一办法就是为特定的目标板编译一个特定内核。在嵌入式以及定制的系统开发里，编译针对某个特定目标板的内核是常用的方法。</p>
<p>在许多案例中，与设备相关的内存和IRQ资源并不足以让设备驱动工作。板极设置代码将使用设备的 <code>platform_data</code>域来提供一些其他的重要的设备信息。</p>
<p>嵌入式系统中的平台设备经常需要一个或者多个时钟，这些时钟除了在实际被用到的时候，通常保持关闭状态(节省电源)。系统也会设置这些与设备关联的时钟，通过调用<code>clk_get(&amp;pdev-&gt;dev, clock_name)</code>来返回所需要的时钟。</p>
<h2 id="老式驱动：设备检测"><a href="#老式驱动：设备检测" class="headerlink" title="老式驱动：设备检测"></a>老式驱动：设备检测</h2><p>一些驱动并没有完全转换到新的设备驱动模型，因为他们还承担着一个驱动之外的职责：由驱动注册自己的平台设备，而不由系统基础设施完成。这样的驱动不能被热插拔或者冷插拔，因为热/冷插拔机制要求设备的创建放置在一些不同的系统组件里而不是驱动里。</p>
<p>这种做法唯一’好’的理由是用于处理一些老式的系统设计，比如像以前的IBM PC机，依赖于容易出错的”probe-the-hardware”模型来进行硬件配置。新的系统设计已经取缔这种模式，更倾向于总线级的动态配置支持（PCI，USB），或者是由启动固件提供的设备列表（例如PNPACPI on x86）。关于什么东西出现在哪儿有太多冲突的可能,即使由操作系统来做有根据的猜测, 也难免因频繁出错而惹麻烦.</p>
<p>这种驱动模型是不鼓励使用的。如果你在更新这样的驱动，请试图将设备枚举移植到一个更适合的地方，驱动之外。这样的据测可以使驱动净化，一开始处于正常的驱动模型，设备节点由PNP或者平台设备设置代码来完成。</p>
<p>尽管如此，内核依然保留一些APIs来支持老式的驱动。尽量少用这些调用，除非你的驱动缺乏热插拔支持。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> platform_device *<span class="title">platform_device_alloc</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> id);</div></pre></td></tr></table></figure></p>
<p>你可以使用<code>platform_device_alloc()</code>来动态地分配一个设备，用它进行资源初始化和<code>platform_device_register()</code>调用。<br>通常一个更好的解决方案是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> platform_device *<span class="title">platform_device_register_simple</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> id,</div><div class="line">        <span class="keyword">struct</span> resource *res, <span class="keyword">unsigned</span> <span class="keyword">int</span> nres);</div></pre></td></tr></table></figure></p>
<p>你可以使用<code>platform_device_register_simple()</code>调用，一步完成分配和注册一个设备。</p>
<h2 id="设备命名和驱动绑定"><a href="#设备命名和驱动绑定" class="headerlink" title="设备命名和驱动绑定"></a>设备命名和驱动绑定</h2><p><code>platform_device.dev.bus_id</code>是设备的真正名称。它由两部分组成：</p>
<ul>
<li><code>platform_device.name</code> … 用于驱动匹配。</li>
<li><code>platform_device.id</code> … 设备实例化号码，置为”-1“表示仅有一个设备。</li>
</ul>
<p>这两部分是连接在一起的，所以<code>name/id</code> “<code>serial/0</code>“表示了总线的<code>bus_id</code>是”<code>serial.0</code>“，”<code>serial/3</code>“表示了总线的<code>bus_id</code>是”<code>serial.3</code>“；他们都使用了名称为”<code>serial</code>“的平台驱动。而”<code>my_rtc/-1</code>“表示的<code>bus_id</code>是”<code>my_rtc</code>“(没有用id做后缀)，它使用了名称为”<code>my_rtc</code>“的平台驱动。</p>
<p>驱动绑定由驱动核心(driver core)自动执行，当在设备和驱动之间查找到匹配时会调用驱动的<code>probe()</code>函数。如果<code>probe()</code>调用成功，驱动和设备绑定成功。有如下三种不同的方法来查找匹配：</p>
<ul>
<li>当一个设备注册后，总线的驱动就会被检测是否匹配。平台设备应当在系统启动的早期注册。</li>
<li>当一个驱动使用<code>platform_driver_register()</code>注册后，总线上的所有的未绑定设备都会被检测是否匹配。驱动通常会在系统启动晚期注册，或者通过模块加载。</li>
<li>使用<code>platform_driver_probe()</code>注册驱动与使用<code>platform_driver_register()</code>注册驱动差不多，唯一例外的是使用前者注册驱动后，如果之后有其他设备注册，该驱动不会被检测是否配。(这是可以的，因为这种接口仅用于没有热插拔功能的设备上)</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之设备类]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/devclass/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://m.blog.csdn.net/blog/guoshaobei/4927177" target="_blank" rel="external">http://m.blog.csdn.net/blog/guoshaobei/4927177</a><br>内核文档：Documentation/driver-model/class.txt<br><a id="more"></a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一个设备类描述了一类的设备，例如语音设备或者网络设备。下面是已定义的设备类:</p>
<insert list="" of="" device="" classes="" here="">

<p>每个设备类定义了一套语法和设备遵循的编程接口。设备驱动就是为特定总线上的特定设备而完成的这套编程接口实现。</p>
<p>对于一个设备驻足在哪个总线上，设备类是不可知的。</p>
<h3 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h3><p>设备类的数据结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*devclass_add)</span><span class="params">(<span class="keyword">struct</span> device *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*devclass_remove)</span><span class="params">(<span class="keyword">struct</span> device *)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> device_class &#123;</div><div class="line">    <span class="keyword">char</span>            * name;</div><div class="line">    <span class="keyword">rwlock_t</span>        lock;</div><div class="line">    u32            devnum;</div><div class="line">    <span class="keyword">struct</span> list_head    node;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> list_head    drivers;</div><div class="line">    <span class="keyword">struct</span> list_head    intf_list;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> driver_dir_entry    dir;</div><div class="line">    <span class="keyword">struct</span> driver_dir_entry    device_dir;</div><div class="line">    <span class="keyword">struct</span> driver_dir_entry    driver_dir;</div><div class="line"></div><div class="line">    devclass_add        add_device;</div><div class="line">    devclass_remove        remove_device;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一个典型的设备类类似如下定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_class input_devclass = &#123;</div><div class="line">    .name          = <span class="string">"input"</span>,</div><div class="line">    .add_device    = input_add_device,</div><div class="line">    .remove_device = input_remove_device,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每个设备类数据结构放在一个头文件里导出，因此它能够被驱动，扩展程序和接口使用。</p>
<p>内核里设备类的注册和注销函数接口如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">devclass_register</span><span class="params">(<span class="keyword">struct</span> device_class * cls)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">devclass_unregister</span><span class="params">(<span class="keyword">struct</span> device_class * cls)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p>当设备绑定到驱动上，它就会被添加到驱动所属的设备类里。在驱动模型问世之前，这个过程在驱动的<code>probe()</code>回调函数里实现；当有了驱动模型后，这个过程在<code>probe()</code>回调函数被调用后实现。</p>
<p>设备在设备类里会被枚举。当一个设备被加入到一个设备类里，设备类的<code>devnum</code>域就会做加操作，分配给这个设备。这个域从来不会做减操作，所以当设备从设备类里移除，重新添加时，它会获得一个不同的枚举值。</p>
<p>设备类被允许为设备创建一个类相关的数据结构，并将其保存到设备的<code>class_data</code>指针。</p>
<p>设备类里没有设备链表。每个驱动有一个它支持的设备链表。为了能够访问到设备类里的所有的设备，将会迭代设备类里的每个驱动的设备链表。</p>
<h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>当设备驱动被注册到内核里时，它们会被加入到设备类里。一个驱动通过设备<code>struct device_driver::devclass</code>域来说明它属于哪个设备类。</p>
<h3 id="sysfs目录结构"><a href="#sysfs目录结构" class="headerlink" title="sysfs目录结构"></a>sysfs目录结构</h3><p>在sysfs的顶层目录里，有个名为’<code>class</code>‘的目录。</p>
<p>每个设备类在<code>class</code>目录里获得一个自己的目录，以及两个默认的子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class/</div><div class="line">`-- input</div><div class="line">    |-- devices</div><div class="line">    `-- drivers</div></pre></td></tr></table></figure></p>
<p>注册到设备类里的驱动会在<code>drivers/</code>目录里获得一个指向实际<code>drivers</code>目录的符号链接（实际<code>drivers</code>目录在<code>bus</code>目录下）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class/</div><div class="line">`-- input</div><div class="line">    |-- devices</div><div class="line">    `-- drivers</div><div class="line">        `-- usb:usb_mouse -&gt; ../../../bus/drivers/usb_mouse/</div></pre></td></tr></table></figure></p>
<p>每一个设备在<code>devices/</code>目录里获得一个指向实际驻扎的设备目录的符号链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class/</div><div class="line">`-- input</div><div class="line">    |-- devices</div><div class="line">    |   `-- 1 -&gt; ../../../root/pci0/00:1f.0/usb_bus/00:1f.2-1:0/</div><div class="line">    `-- drivers</div></pre></td></tr></table></figure></p>
<h3 id="导出属性"><a href="#导出属性" class="headerlink" title="导出属性"></a>导出属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> devclass_attribute &#123;</div><div class="line">        <span class="keyword">struct</span> attribute        attr;</div><div class="line">        <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device_class *, <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> off);</div><div class="line">        <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device_class *, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> off);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>设备类驱动使用<code>DEVCLASS_ATTR</code>宏导出属性，类似<code>devices</code>提供的<code>DEVICE_ATTR</code>宏。<br>例如，一个如下定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVCLASS_ATTR</span><span class="params">(debug,<span class="number">0644</span>,show_debug,store_debug)</span></span>;</div></pre></td></tr></table></figure></p>
<p>等价于如下声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> devclass_attribute devclass_attr_debug;</div></pre></td></tr></table></figure></p>
<p>总线驱动可以从设备类的sysfs目录里添加/删除一个属性，使用如下函数接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">devclass_create_file</span><span class="params">(<span class="keyword">struct</span> device_class *, <span class="keyword">struct</span> devclass_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">devclass_remove_file</span><span class="params">(<span class="keyword">struct</span> device_class *, <span class="keyword">struct</span> devclass_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
<p>在上面的例子里，放置在设备类目录里的文件会被命名为’<code>debug</code>‘。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>也许存在多个访问同一设备类下的同一设备的机制。设备接口(Device interfaces)就是用来描述这样的机制的。</p>
<p>当一个设备被加入到一个设备类里，内核尝试将它添加到设备类的每一个被注册过的接口里。</p>
</insert>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之驱动绑定]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/binding/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://m.blog.csdn.net/blog/guoshaobei/4917225" target="_blank" rel="external">http://m.blog.csdn.net/blog/guoshaobei/4917225</a><br>内核文档：Documentation/driver-model/binding.txt<br><a id="more"></a></p>
<p>驱动绑定就是将一个设备和控制该设备的驱动关联在一起的过程。典型的情况下，总线驱动来处理驱动绑定，因为每个总线驱动都有总线相关的数据结构来表示设备和设备驱动。有了表示设备和设备驱动的通用数据结构，绝大多数的绑定过程可以使用这些通用代码。</p>
<p><strong>总线</strong></p>
<p>总线类型数据结构包含一个记录所有属于这个总线类型的设备链表。当一个设备驱动调用<code>device_register()</code>时，它会被添加到这个链表的尾部。总线类型数据结构也包含一个记录所有属于这个总线类型的驱动链表。当一个设备驱动调用<code>driver_register()</code>时，该驱动会被添加到这个链表的尾部。这是触发驱动绑定的两个主要事件。</p>
<p><strong>设备注册</strong></p>
<p>当一个新设备被添加后，总线的驱动链表会被迭代，查找出支持该设备的驱动。为了达到这个目的，新设备的设备ID必须匹配驱动支持的设备ID中的一个。设备ID的格式和语法是总线相关的。不需要使用一个复杂的状态机和匹配算法，而是由总线驱动提供一个<code>callback</code>函数来比较设备和一个驱动所支持的ID是否匹配，如果匹配返回值为1，否则返回值为0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">struct</span> device * dev, <span class="keyword">struct</span> device_driver * drv)</span></span>;</div></pre></td></tr></table></figure></p>
<p>当一个匹配被找到时，设备的’<code>driver</code>‘域会被设置为这个驱动，驱动的<code>probe</code>回调函数会被调用。这使驱动有机会检验是否真正支持这个硬件设备,同时会检验设备是否处于工作状态。</p>
<p><strong>设备类别</strong></p>
<p>当<code>probe</code>成功完成后，设备被注册到它属于的类中。设备驱动属于且仅属于一个类，这个类会在驱动的<code>devclass</code>域中设置。<code>devclass_add_device</code>被调用来枚举和注册类中的设备，这个过程发生在类的<code>register_dev</code>回调函数中。</p>
<p>注意：设备<code>class</code>结构和其核心操作函数还没有进入mainline内核，所以以上讨论有一定推测性。</p>
<p><strong>驱动</strong></p>
<p>当一个驱动被关联到一个设备时，这个设备被插入到驱动的设备链表中。</p>
<p><strong>sysfs</strong></p>
<p>在<code>bus</code>目录的’<code>devices</code>‘子目录里，创建符号链接，指向实际的<code>device</code>目录。</p>
<p>在<code>driver</code>的’<code>devices</code>‘子目录里，创建符号链接，指向实际的<code>device</code>目录。</p>
<p>在<code>class</code>目录里为设备创建子目录，在子目录里，创建符号链接，指向该设备在sysfs tree里的实际位置。</p>
<p>也可以在设备的实际目录里，创建符号链接，指向它的<code>class</code>目录，或者<code>class</code>目录的顶层目录；也可以创建符号链接，指向它的<code>driver</code>目录。不过目前并没有这样做。</p>
<p><strong>驱动注册</strong></p>
<p>添加一个新的<code>driver</code>的过程，与添加一个新的<code>device</code>的过程类似。总线的设备链表会被迭代，找到一个匹配的设备。已经绑定在驱动上的设备可以被跳过。所有的设备都要被迭代，多个设备可以绑定到一个驱动上。</p>
<p><strong>删除</strong></p>
<p>当一个设备要被删除时，它的引用计数最终会为0。当为0时，驱动的<code>remove</code>回调函数会被调用。设备会从驱动的设备链表中移除，驱动的引用计数会减1。设备和它的驱动之间的符号链接均被删除。</p>
<p>当一个驱动要被删除时，它所支持的设备列表会被迭代，驱动的<code>remove</code>回调函数会为每一个设备调用一次。设备从设备列表中删除，符号链接也要被删除。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之设备驱动]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/driver/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://blog.chinaunix.net/uid-20522771-id-3449546.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3449546.html</a><br>内核文档： Documentation/driver-model/driver.txt</p>
<a id="more"></a>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>查阅 kerneldoc 以了解 struct device_driver.</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>设备驱动应该是静态分配的结构体。虽然系统中一个 driver 可能会支持多个设备，但<code>struct device_driver</code>仍将 driver 做为一个单独的整体（而不是某个设备实例的一部分）。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>driver 至少应该初始化两个字段：<code>name</code> 和 <code>bus</code>。当然也应该初始化 <code>devclass</code> 字段，这样它可以在内部获得适当的链接。同时它也应该尽可能多的初始化回调函数，尽管这些回调函数是可选的。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>如上所述，<code>struct device_driver</code> 对象是静态分配的。以下是一个 <code>eepro100 driver</code> 的声明的小例子。这个声明仅仅是个假设，它依赖于被完全转换成新模型的 driver。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> device_driver eepro100_driver = &#123;</div><div class="line">    .name = <span class="string">"eepro100"</span>,</div><div class="line">    .bus = &amp;pci_bus_type,</div><div class="line"></div><div class="line">    .probe = eepro100_probe,</div><div class="line">    .remove = eepro100_remove,</div><div class="line">    .suspend = eepro100_suspend,</div><div class="line">    .resume = eepro100_resume,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>但大多数 driver 不能够被完全转换成新模型，这是因为这些 driver 所依附的总线都有一个该总线特定的（bus-specific）字段，而这些字段不能一概而论。</p>
<p>最常见的例子就是设备 ID 结构。通常一个驱动会定义一组它支持的设备 ID。而这些结构的数据格式以及与设备 ID 进行比较的算法都完全是总线特定的。因为将它们定义成总线特定的实体会牺牲类型安全，所以我们将保留总线特定的数据结构。</p>
<p>总线特定的（bus-specific）驱动应该包含一个通用的结构体 <code>struct device_driver</code>，就像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> pci_driver &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> pci_device_id *id_table;</div><div class="line">    <span class="keyword">struct</span> device_driver driver;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>一个包含了总线特定字段的驱动应该像这样定义（还是用 eepro100 driver）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> pci_driver eepro100_driver = &#123;</div><div class="line">    .id_table = eepro100_pci_tbl,</div><div class="line">    .driver = &#123;</div><div class="line">        .name = <span class="string">"eepro100"</span>,</div><div class="line">        .bus = &amp;pci_bus_type,</div><div class="line">        .probe = eepro100_probe,</div><div class="line">        .remove = eepro100_remove,</div><div class="line">        .suspend = eepro100_suspend,</div><div class="line">        .resume = eepro100_resume,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可能有些人会觉得这样的内嵌结构体有些别扭甚至比较丑陋。但目前为止，这是能够满足我们需要的最好的方法了…</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver * drv)</span></span>;</div></pre></td></tr></table></figure>
<p>驱动程序将会在启动时注册该结构体。对于那些没有总线特定字段的 driver（即没有一个总线特定的 driver 结构体），应该使用<code>driver_register</code>并传递给这个函数指向该驱动的<code>struct device_driver</code>对象的指针。</p>
<p>然而大部分 driver 拥有一个总线特定结构并需要一个像<code>pci_driver_register</code>这样的函数完成驱动在总线上的注册。</p>
<p>重要的是驱动程序应该尽早的注册他们的 driver 结构。在向核心注册的过程中，<code>struct device_driver</code>对象中的几个字段会被初始化，这些字段包括引用计数(reference count)和锁(lock)，因为设备模型核心或总线驱动假设上述字段总是可用的。</p>
<h3 id="转换到总线驱动"><a href="#转换到总线驱动" class="headerlink" title="转换到总线驱动"></a>转换到总线驱动</h3><p>定义一个封装函数，可以更容易的实现驱动到新模型的转换。driver 可以完全忽略通用结构并让总线封装函数去填充这些字段。对于那些回调函数，总线则可以定义一组通用回调函数用来指向 driver 的总线特定回调函数。</p>
<p>该解决方案只是暂时的。为了得到 driver 里的 <code>class</code> 信息，这些 driver 必须能够被修改。因为从 driver 到新模型的转换应当减少基础结构的复杂性和代码规模，所以建议添加 它们到 <code>class</code> 信息的转换。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>一旦该对象已被注册，它就可以访问对象的公共字段，比如锁(lock)和设备列表。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int driver_for_each_dev(struct device_driver * drv, void * data,</div><div class="line">                        int (*callback)(struct device * dev, void * data));</div></pre></td></tr></table></figure></p>
<p><code>devices</code> 字段就是一组已经绑定到 driver 的设备。LDM 核心提供了一个辅助函数操作 driver 所控制的所有设备。这个辅助函数将在访问每个节点时锁定driver，并且会在访问每个设备时设置正确的引用计数。</p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p>当一个 driver 注册之后，就会在 sysfs 中它所属总线目录下创建一个目录。在这个目录中，driver 可以在全局范围内向用户空间导出驱动的控制接口，例如切换驱动程序中的 debug 输出。</p>
<p>这个目录的一个未来的特性就是它本身将是一个‘<code>devices</code>’目录。该目录将会包含它所支持的那些设备的目录符号链接。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> device * dev);</div></pre></td></tr></table></figure>
<p><code>probe()</code> 将在总线的 <code>rwsem</code> 锁定的情况下在进程上下文中调用，然后 driver 将部分地与设备绑定。在<code>probe()</code>或其他例程中，driver 通常使用<code>container_of()</code>实现”<code>dev</code>“到总线特定类型的转换。该类型往往会提供设备的资源数据，就像<code>pci_dev.resource[]</code>或<code>platform_device.resources</code>，这些资源用于除了<code>dev-&gt;platform_data</code>以外的 driver 初始化。</p>
<p>这个回调包含了绑定该 driver 到给定设备的驱动特定的逻辑。这包括了验证该设备是否存在、该版本能否被处理、能否分配该 driver 的数据结构并初始化以及哪些硬件能被初始化。driver 通常会使用<code>dev_set_drvdata()</code>保存一个指向它的<code>state</code>的指针。当一个 driver 成功将自己绑定到设备时，<code>probe()</code>会返回0，然后驱动模型代码将会完成它这部分的 driver 到设备的绑定。</p>
<p>driver 的<code>probe()</code>函数可能返回负的<code>errno</code>值表示该 driver 没有被绑定到设备，这种情况下它必须释放所有已经成功分配的资源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> device * dev);</div></pre></td></tr></table></figure></p>
<p>调用 <code>remove</code> 来解除驱动(driver)和设备(device)的绑定。如果从系统中物理移除一个设备，或者驱动模块已经被卸载，或者在一个 <code>reboot</code> 时序中等等，这个 <code>remove</code> 都会被调用。</p>
<p>这都取决于这个 driver 判定该设备存在与否。它应该释放为这个设备而专门分配的资源，比如 <code>driver_data</code> 字段中的一切。</p>
<p>如果该设备仍然存在，它应该暂停该设备并将其置于能够支持的低功耗状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*suspend)(<span class="keyword">struct</span> device * dev, <span class="keyword">pm_message_t</span> state);</div></pre></td></tr></table></figure></p>
<p><code>suspend</code> 将设备置于在低功耗状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*resume)(<span class="keyword">struct</span> device * dev);</div></pre></td></tr></table></figure>
<p><code>resume</code> 则用于把设备从低功耗状态中恢复回来。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> driver_attribute &#123;</div><div class="line">    <span class="keyword">struct</span> attribute attr;</div><div class="line">    <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device_driver *driver, <span class="keyword">char</span> *buf);</div><div class="line">    <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>设备驱动程序可以通过它们的 sysfs 目录将属性导出。可以使用宏 <code>DRIVER_ATTR</code> 定义属性，这个宏工作原理和 <code>DEVICE_ATTR</code> 是一样的。</p>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DRIVER_ATTR(debug,<span class="number">0644</span>,show_debug,store_debug);</div></pre></td></tr></table></figure></p>
<p>这实际上就是定义一个这样的东西：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> driver_attribute driver_attr_debug;</div></pre></td></tr></table></figure></p>
<p>稍后就可以使用以下函数在 driver 的目录中添加或删除属性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_create_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">struct</span> driver_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_remove_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">struct</span> driver_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之设备结构]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/device/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://blog.chinaunix.net/uid-20522771-id-3447322.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3447322.html</a><br>内核文档：Documentation/driver-model/device.txt<br><a id="more"></a></p>
<h3 id="基本设备结构体"><a href="#基本设备结构体" class="headerlink" title="基本设备结构体"></a>基本设备结构体</h3><p>查阅 kerneldoc 以了解 <code>struct device</code>。</p>
<h3 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h3><p>那些发现了设备的总线驱动使用以下接口将这个设备注册到核心：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(<span class="keyword">struct</span> device * dev)</span></span>;</div></pre></td></tr></table></figure></p>
<p>总线应该初始化该设备的下列字段：</p>
<ul>
<li>parent</li>
<li>name</li>
<li>bus_id</li>
<li>bus</li>
</ul>
<p>当一个设备的引用计数减到 0 时，则从核心中移除该设备。可以使用以下接口改变一个设备的引用计数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> device * <span class="title">get_device</span><span class="params">(<span class="keyword">struct</span> device * dev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_device</span><span class="params">(<span class="keyword">struct</span> device * dev)</span></span>;</div></pre></td></tr></table></figure></p>
<p>如果 <code>device</code> 的引用计数不是 0（已经在移除的过程中），<code>get_device()</code> 会返回一个指向传递给它的<code>struct device</code>的指针。</p>
<p>一个 <code>driver</code> 可以使用以下接口访问 <code>device</code> 结构体中的<code>lock</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_device</span><span class="params">(<span class="keyword">struct</span> device * dev)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_device</span><span class="params">(<span class="keyword">struct</span> device * dev)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_attribute &#123;</div><div class="line">    <span class="keyword">struct</span> attribute    attr;</div><div class="line">    <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">                    <span class="keyword">char</span> *buf);</div><div class="line">    <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>设备驱动程序可以通过 sysfs 导出设备的属性。</p>
<p>请参考 Documentation/filesystems/sysfs.txt 来了解 sysfs 如何工作。</p>
<p>正如 Documentation/kobject.txt 中所述，设备属性的创建必须在<code>KOBJ_ADD</code><br>uevent 发生之前。实现这个的唯一途径就是定义一个属性组。</p>
<p>定义属性可以使用宏函数<code>DEVICE_ATTR</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR(name,mode,show,store)</span></div></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(type, <span class="number">0444</span>, show_type, <span class="literal">NULL</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(power, <span class="number">0644</span>, show_power, store_power)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这将定义两个拥有各自名称的 <code>struct device_attribute</code> 类型的结构体，’<code>dev_attr_type</code>‘<br>和’<code>dev_attr_power</code>‘。这两个属性可以象这样组织到一块：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *dev_attrs[] = &#123;</div><div class="line">    &amp;dev_attr_type.attr,</div><div class="line">    &amp;dev_attr_power.attr,</div><div class="line">    <span class="literal">NULL</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute_group dev_attr_group = &#123;</div><div class="line">    .attrs = dev_attrs,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> attribute_group *dev_attr_groups[] = &#123;</div><div class="line">    &amp;dev_attr_group,</div><div class="line">    <span class="literal">NULL</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这些数组随后可以通过设置 <code>groups</code> 指针，在 <code>device_register()</code> 被调用之前关联到一个 <code>device</code> 上：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dev-&gt;groups = dev_attr_groups;</div><div class="line">device_register(dev);</div></pre></td></tr></table></figure></p>
<p><code>device_register()</code> 函数将使用‘<code>groups</code>‘指针去创建该设备的属性，而<br><code>device_unregister()</code> 函数也将使用‘<code>groups</code>‘指针去移除该设备的属性。</p>
<p>提醒一句：尽管 kernel 允许在任何时候都可以在一个设备上调用 <code>device_create_file()</code> 和 <code>device_remove_file()</code>，但用户空间还是强烈期望能够得知在属性何时被创建。当一个新的设备注册进 kernel 时，就会产生一个 <code>uevent</code> 事件并通知用户空间该设备可用了。但如果设备的属性是在设备注册之后才添加的话，那么用户空间将得不到任何通知，对这个新的属性也将一无所知。</p>
<p>这对于那些需要在驱动探测（driver probe）时为设备发布附加属性的设备驱动程序来说是很重要的。如果设备驱动程序只是简单的传递 <code>device</code> 结构体来调用<code>device_create_file()</code>的话，用户空间就永远也得不到关于新属性的通知。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[驱动模型之总线类型]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/bus/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://blog.chinaunix.net/uid-20522771-id-3452028.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3452028.html</a><br>内核文档： Documentation/driver-model/bus.txt<br><a id="more"></a></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>查阅 kerneldoc 以了解 <code>struct bus_type</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(<span class="keyword">struct</span> bus_type * bus)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>内核中每个总线类型（PCI、USB 等等）都应该声明一个此类型的静态对象。它们必须初始化该对象的 <code>name</code> 字段，然后可选的初始化 <code>match</code> 回调函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bus_type pci_bus_type = &#123;</div><div class="line">    .name = <span class="string">"pci"</span>,</div><div class="line">    .match = pci_bus_match,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个结构体应该在头文件中向驱动程序导出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> bus_type pci_bus_type;</div></pre></td></tr></table></figure></p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>当初始化一个总线驱动时，将会调用<code>bus_register</code>。这时这个总线对象剩下的字段将被初始化，然后这个对象会被插入到总线类型的一个全局列表里去。一旦完成一个总线对象的注册，那么对于总线驱动来说它里面的字段就已经可用了。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><code>match()</code>：给设备加载驱动</p>
<p>设备 ID 的结构和比较这些 ID 的语义本质上讲都是总线定制的。驱动通常会定义一个它所支持的设备 ID 的数组，并将这个数组驻留在总线定制的驱动结构中。</p>
<p>回调函数 <code>match</code> 的目的就是在不牺牲总线定制功能或类型安全的情况下，通过比较驱动所支持的 ID 与特定设备的 ID，给总线提供一个确定特定驱动是否支持特定设备的机会。</p>
<p>当一个驱动注册到总线后，将会遍历总线的设备列表，然后会为每个还没有和任何一个驱动关联的设备调用回调函数<code>match</code>。</p>
<h3 id="设备和驱动列表"><a href="#设备和驱动列表" class="headerlink" title="设备和驱动列表"></a>设备和驱动列表</h3><p>设备和驱动列表是为了取代那些总线自己保存的本地列表。它们分别是 <code>struct devices</code> 和 <code>struct device_drivers</code> 的列表。总线驱动可以随意的使用这些列表，但有可能需要将其转换成总线定制类型。</p>
<p>LDM 核心提供了遍历各个列表的辅助函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int bus_for_each_dev(struct bus_type * bus, struct device * start, void * data,</div><div class="line">                     int (*fn)(struct device *, void *));</div><div class="line"></div><div class="line">int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,</div><div class="line">                     void * data, int (*fn)(struct device_driver *, void *));</div></pre></td></tr></table></figure></p>
<p>这些辅助函数迭代各个列表，然后为这些列表里的设备或驱动调用回调函数。所有列表的访问都是通过取得总线锁（实时读取）而保持同步的。列表中每个对象的引用计数都会在调用回调函数前递增；并且会在取得下一个对象之后递减。总线锁并不在回调函数调用期间继续保持。</p>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p>这里有一个顶层目录：‘<code>bus</code>’。</p>
<p>每个总线在 <code>bus</code> 目录下都有自己的目录，其中有两个默认目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/sys/bus/pci/</div><div class="line">|-- devices</div><div class="line">`-- drivers</div></pre></td></tr></table></figure></p>
<p>在总线注册的驱动会得到一个该总线 <code>drivers</code> 目录的子目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/sys/bus/pci/</div><div class="line">|-- devices</div><div class="line">`-- drivers</div><div class="line">   |-- Intel ICH</div><div class="line">   |-- Intel ICH Joystick</div><div class="line">   |-- agpgart</div><div class="line">   `-- e100</div></pre></td></tr></table></figure></p>
<p>在这种类型总线上发现的每个设备都会在总线的 <code>deivces</code> 目录下获得一个符号链接，该链接指向这个设备在物理层次中的目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/sys/bus/pci/</div><div class="line">|-- devices</div><div class="line">|  |-- 00:00.0 -&gt; ../../../root/pci0/00:00.0</div><div class="line">|  |-- 00:01.0 -&gt; ../../../root/pci0/00:01.0</div><div class="line">|  `-- 00:02.0 -&gt; ../../../root/pci0/00:02.0</div><div class="line">`-- drivers</div></pre></td></tr></table></figure></p>
<h3 id="属性导出"><a href="#属性导出" class="headerlink" title="属性导出"></a>属性导出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bus_attribute &#123;</div><div class="line">    <span class="keyword">struct</span> attribute    attr;</div><div class="line">    <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> bus_type *, <span class="keyword">char</span> * buf);</div><div class="line">    <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> bus_type *, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>总线驱动可以使用宏 <code>BUS_ATTR</code> 导出属性，它的工作方式就像 <code>device</code> 里的 <code>DEVICE_ATTR</code> 一样。例如，像这样定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">BUS_ATTR</span><span class="params">(debug,<span class="number">0644</span>,show_debug,store_debug)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这等于是定义一个这样的东西：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> bus_attribute bus_attr_debug;</div></pre></td></tr></table></figure></p>
<p>使用以下函数，可以用来从总线的 sysfs 目录中添加或删除属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_create_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_remove_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sysfs - 用于导出内核对象(kobject)的文件系统]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/sysfs/</url>
      <content type="html"><![CDATA[<p>Chinese translated version of Documentation/filesystems/sysfs.txt</p>
<p>If you have any comment or update to the content, please contact the<br>original document maintainer directly.  However, if you have a problem<br>communicating in English you can also ask the Chinese maintainer for<br>help.  Contact the Chinese maintainer if this translation is outdated<br>or if there is a problem with the translation.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maintainer:</td>
<td>Patrick Mochel    &lt;mochel@osdl.org&gt;</td>
</tr>
<tr>
<td></td>
<td>Mike Murphy &lt;mamurph@cs.clemson.edu&gt;</td>
</tr>
<tr>
<td>Chinese maintainer:</td>
<td>Fu Wei &lt;tekkamanninja@gmail.com&gt;</td>
</tr>
</tbody>
</table>
<p>Documentation/filesystems/sysfs.txt 的中文翻译</p>
<p>如果想评论或更新本文的内容，请直接联系原文档的维护者。如果你使用英文<br>交流有困难的话，也可以向中文版维护者求助。如果本翻译更新不及时或者翻<br>译存在问题，请联系中文版维护者。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>英文版维护者：</td>
<td>Patrick Mochel    &lt;mochel@osdl.org&gt;</td>
</tr>
<tr>
<td></td>
<td>Mike Murphy &lt;mamurph@cs.clemson.edu&gt;</td>
</tr>
<tr>
<td>中文版维护者：</td>
<td>傅炜 Fu Wei &lt;tekkamanninja@gmail.com&gt;</td>
</tr>
<tr>
<td>中文版翻译者：</td>
<td>傅炜 Fu Wei &lt;tekkamanninja@gmail.com&gt;</td>
</tr>
<tr>
<td>中文版校译者：</td>
<td>傅炜 Fu Wei &lt;tekkamanninja@gmail.com&gt;</td>
</tr>
</tbody>
</table>
<p>以下为正文:</p>
<p>sysfs - 用于导出内核对象(kobject)的文件系统</p>
<p>Patrick Mochel    <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x6d;&#x6f;&#99;&#x68;&#101;&#108;&#x40;&#x6f;&#115;&#100;&#108;&#46;&#111;&#x72;&#x67;">&#x6d;&#x6f;&#99;&#x68;&#101;&#108;&#x40;&#x6f;&#115;&#100;&#108;&#46;&#111;&#x72;&#x67;</a><br>Mike Murphy <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#109;&#97;&#x6d;&#117;&#114;&#112;&#x68;&#64;&#x63;&#x73;&#46;&#x63;&#x6c;&#101;&#x6d;&#115;&#x6f;&#x6e;&#x2e;&#101;&#x64;&#117;">&#109;&#97;&#x6d;&#117;&#114;&#112;&#x68;&#64;&#x63;&#x73;&#46;&#x63;&#x6c;&#101;&#x6d;&#115;&#x6f;&#x6e;&#x2e;&#101;&#x64;&#117;</a></p>
<p>修订:    16 August 2011<br>原始版本:   10 January 2003<br><a id="more"></a></p>
<h3 id="sysfs-简介"><a href="#sysfs-简介" class="headerlink" title="sysfs 简介"></a>sysfs 简介</h3><p>sysfs 是一个最初基于 <code>ramfs</code> 内存文件系统。它提供一种导出内核数据结构及其属性以及它们之间的关联到用户空间的方法。</p>
<p>sysfs 始终与 <code>kobject</code> 的底层结构紧密相关。请阅读Documentation/kobject.txt 文档以获得更多关于 <code>kobject</code> 接口的信息。</p>
<h3 id="使用-sysfs"><a href="#使用-sysfs" class="headerlink" title="使用 sysfs"></a>使用 sysfs</h3><p>只要内核配置中定义了 <code>CONFIG_SYSFS</code> ，sysfs 就总会被编译进内核。你可通过以下命令挂载它:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount -t sysfs sysfs /sys</div></pre></td></tr></table></figure></p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>任何 <code>kobject</code> 在系统中注册，就会有一个目录在 sysfs 中被创建。这个目录是作为该 <code>kobject</code> 的父对象所在目录的子目录创建的，以准确地传递内核的对象层次到用户空间。sysfs 中的顶层目录代表着内核对象层次的共同祖先；例如：某些对象属于某个子系统。</p>
<p>Sysfs 在与其目录关联的 <code>sysfs_dirent</code> 对象中内部保存一个指向实现目录的 <code>kobject</code> 的指针。以前，这个 <code>kobject</code> 指针被 sysfs 直接用于<code>kobject</code> 文件打开和关闭的引用计数。而现在的 sysfs 实现中，<code>kobject</code>引用计数只能通过 <code>sysfs_schedule_callback()</code> 函数直接修改。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>kobject</code> 的属性可在文件系统中以普通文件的形式导出。Sysfs 为属性定义了面向文件 I/O 操作的方法，以提供对内核属性的读写。</p>
<p>属性应为 ASCII 码文本文件。以一个文件只存储一个属性值为宜。但一个文件只包含一个属性值可能影响效率，所以一个包含相同数据类型的属性值数组也被广泛地接受。</p>
<p>混合类型、表达多行数据以及一些怪异的数据格式会遭到强烈反对。这样做是很丢脸的,而且其代码会在未通知作者的情况下被重写。</p>
<p>一个简单的属性结构定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> attribute &#123;</div><div class="line">        <span class="keyword">char</span>                    * name;</div><div class="line">        <span class="keyword">struct</span> <span class="keyword">module</span>		*owner;</div><div class="line">        <span class="keyword">umode_t</span>                 mode;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="keyword">const</span> <span class="keyword">struct</span> attribute * attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="keyword">const</span> <span class="keyword">struct</span> attribute * attr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>一个单独的属性结构并不包含读写其属性值的方法。子系统最好为增删特定对象类型的属性定义自己的属性结构体和封装函数。</p>
<p>例如:驱动程序模型定义的 <code>device_attribute</code> 结构体如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_attribute &#123;</div><div class="line">	<span class="keyword">struct</span> attribute	attr;</div><div class="line">	<span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">			<span class="keyword">char</span> *buf);</div><div class="line">	<span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">			 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="keyword">const</span> <span class="keyword">struct</span> device_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="keyword">const</span> <span class="keyword">struct</span> device_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
<p>为了定义设备属性，同时定义了一下辅助宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></div><div class="line">struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</div></pre></td></tr></table></figure></p>
<p>例如:声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(foo, S_IWUSR | S_IRUGO, show_foo, store_foo)</span></span>;</div></pre></td></tr></table></figure></p>
<p>等同于如下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> device_attribute dev_attr_foo = &#123;</div><div class="line">       .attr	= &#123;</div><div class="line">		.name = <span class="string">"foo"</span>,</div><div class="line">		.mode = S_IWUSR | S_IRUGO,</div><div class="line">	&#125;,</div><div class="line">	.show = show_foo,</div><div class="line">	.store = store_foo,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="子系统特有的回调函数"><a href="#子系统特有的回调函数" class="headerlink" title="子系统特有的回调函数"></a>子系统特有的回调函数</h3><p>当一个子系统定义一个新的属性类型时，必须实现一系列的 sysfs 操作，使读写调用指向属性所有者的显示(<code>show</code>)和储存(<code>store</code>)方法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sysfs_ops &#123;</div><div class="line">        <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="keyword">char</span> *);</div><div class="line">        <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>[子系统应已经定义了一个 <code>struct kobj_type</code> 结构体作为这个类型的描述符，并在此保存 <code>sysfs_ops</code> 的指针。更多的信息参见 <code>kobject</code> 的文档]</p>
<p>当一个文件被读写时，sysfs 会为这个类型调用适当的方法。这个方法会将一般的<code>kobject</code> 和 <code>attribute</code> 结构体指针转换为适当的指针类型，然后调用其关联的函数。</p>
<p>示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> to_dev(obj) container_of(obj, struct device, kobj)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">dev_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                             <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> device_attribute *dev_attr = to_dev_attr(attr);</div><div class="line">        <span class="keyword">struct</span> device *dev = to_dev(kobj);</div><div class="line">        <span class="keyword">ssize_t</span> ret = -EIO;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (dev_attr-&gt;show)</div><div class="line">                ret = dev_attr-&gt;show(dev, dev_attr, buf);</div><div class="line">        <span class="keyword">if</span> (ret &gt;= (<span class="keyword">ssize_t</span>)PAGE_SIZE) &#123;</div><div class="line">                print_symbol(<span class="string">"dev_attr_show: %s returned bad count\n"</span>,</div><div class="line">                                (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev_attr-&gt;show);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="读写属性数据"><a href="#读写属性数据" class="headerlink" title="读写属性数据"></a>读写属性数据</h3><p>在声明属性时，必须指定 <code>show()</code> 或 <code>store()</code> 方法，以实现属性的读或写。这些方法的类型应该和以下的设备属性定义一样简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="keyword">char</span> *buf);</div><div class="line"><span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">                 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div></pre></td></tr></table></figure></p>
<p>也就是说,它们应只以一个处理对象、一个属性和一个缓冲指针作为参数。</p>
<p>sysfs 会分配一个大小为 (<code>PAGE_SIZE</code>) 的缓冲区并传递给这个方法。Sysfs 将会为每次读写操作调用一次这个方法。这使得这些方法的实现遵循以下的行为:</p>
<ul>
<li>在读方面（<code>read</code>(2)），<code>show()</code> 方法应该填充整个缓冲区。回想一下，属性应只导出了一个属性值或是一个同类型属性值的数组，所以这个代价将不会不太高。这使得用户空间可以局部地读和任意的向前搜索整个文件。如果用户空间向后搜索到零或使用‘0’偏移执行一个<code>pread</code>(2)操作，<code>show()</code>方法将再次被调用，以重新填充缓存。</li>
<li>在写方面（<code>write</code>(2)），sysfs 希望在第一次写操作时得到整个缓冲区。之后 Sysfs 传递整个缓冲区给 <code>store()</code> 方法。当要写 sysfs 文件时，用户空间进程应首先读取整个文件，修该想要改变的值，然后回写整个缓冲区。在读写属性值时，属性方法的执行应操作相同的缓冲区。<br>注记:</li>
<li>写操作导致的 <code>show()</code> 方法重载，会忽略当前文件位置。</li>
<li>缓冲区应总是 <code>PAGE_SIZE</code> 大小。对于i386，这个值为<code>4096</code>。</li>
<li><code>show()</code> 方法应该返回写入缓冲区的字节数，也就是 <code>snprintf()</code>的返回值。</li>
<li><code>show()</code> 应始终使用 <code>snprintf()</code>。</li>
<li><code>store()</code> 应返回缓冲区的已用字节数。如果整个缓存都已使用，只需返回<code>count</code> 参数。</li>
<li><code>show()</code> 或 <code>store()</code> 可以返回错误值。当得到一个非法值，必须返回一个错误值。</li>
<li>一个传递给方法的对象将会通过 sysfs 引用计数其内嵌对象而驻留在内存中。尽管如此，对象代表的物理实体(如设备)可能已不存在。如有必要，应该实现一个检测机制。</li>
</ul>
<p>一个简单的(未经实验证实的)设备属性实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">show_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span></div><div class="line">                         <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">snprintf</span>(buf, PAGE_SIZE, <span class="string">"%s\n"</span>, dev-&gt;name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">store_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span></div><div class="line">                          <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">        <span class="built_in">snprintf</span>(dev-&gt;name, <span class="keyword">sizeof</span>(dev-&gt;name), <span class="string">"%.*s"</span>,</div><div class="line">                 (<span class="keyword">int</span>)min(count, <span class="keyword">sizeof</span>(dev-&gt;name) - <span class="number">1</span>), buf);</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, show_name, store_name)</span></span>;</div></pre></td></tr></table></figure></p>
<p>（注意：真正的实现不允许用户空间设置设备名。）</p>
<h3 id="顶层目录布局"><a href="#顶层目录布局" class="headerlink" title="顶层目录布局"></a>顶层目录布局</h3><p>sysfs 目录的安排显示了内核数据结构之间的关系。</p>
<p>顶层 sysfs 目录看起来像这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">block/</div><div class="line">bus/</div><div class="line">class/</div><div class="line">dev/</div><div class="line">devices/</div><div class="line">firmware/</div><div class="line">net/</div><div class="line">fs/</div></pre></td></tr></table></figure></p>
<p><code>devices/</code> 包含了一个设备树的文件系统表示。它直接映射了内核内部的设备树，设备(<code>struct device</code>)的层次结构。</p>
<p><code>bus/</code> 包含了内核中各种总线类型的平面目录布局。每个总线目录包含两个子目录:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">devices/</div><div class="line">drivers/</div></pre></td></tr></table></figure></p>
<p><code>devices/</code> 包含了系统中出现的每个设备的符号链接，它们指向 <code>root/</code> 下的设备目录。</p>
<p><code>drivers/</code> 包含了每个已为特定总线上的设备而挂载的驱动程序的目录(这里假定驱动没有跨越多个总线类型)。</p>
<p><code>fs/</code> 包含了一个为文件系统设立的目录。现在每个想要导出属性的文件系统必须在 <code>fs/</code> 下创建自己的层次结构(参见Documentation/filesystems/fuse.txt)。</p>
<p><code>dev/</code> 包含两个子目录： <code>char/</code> 和 <code>block/</code>。在这两个子目录中，有以<code>&lt;major&gt;:&lt;minor&gt;</code> 格式命名的符号链接。这些符号链接指向 sysfs 目录中相应的设备。<code>/sys/dev</code> 为查找某个设备提供一个通过<code>stat</code>(2) 调用快速搜索 sysfs 接口的方法。</p>
<p>更多有关 driver-model 的特性信息可以在 Documentation/driver-model/ 中找到。</p>
<p>TODO: 完成这一节。</p>
<h3 id="当前接口"><a href="#当前接口" class="headerlink" title="当前接口"></a>当前接口</h3><p>以下的接口层存在于当前的sysfs中:</p>
<h4 id="设备-include-linux-device-h"><a href="#设备-include-linux-device-h" class="headerlink" title="设备 (include/linux/device.h)"></a>设备 (include/linux/device.h)</h4><p>结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> device_attribute &#123;</div><div class="line">	<span class="keyword">struct</span> attribute	attr;</div><div class="line">	<span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">			<span class="keyword">char</span> *buf);</div><div class="line">	<span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</div><div class="line">			 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>声明:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DEVICE_ATTR(_name, _mode, _show, _store);</div></pre></td></tr></table></figure></p>
<p>增/删属性:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">const</span> <span class="keyword">struct</span> device_attribute * attr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">const</span> <span class="keyword">struct</span> device_attribute * attr)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="总线驱动程序-include-linux-device-h"><a href="#总线驱动程序-include-linux-device-h" class="headerlink" title="总线驱动程序 (include/linux/device.h)"></a>总线驱动程序 (include/linux/device.h)</h4><p>结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bus_attribute &#123;</div><div class="line">        <span class="keyword">struct</span> attribute        attr;</div><div class="line">        <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> bus_type *, <span class="keyword">char</span> * buf);</div><div class="line">        <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> bus_type *, <span class="keyword">const</span> <span class="keyword">char</span> * buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>声明:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BUS_ATTR(_name, _mode, _show, _store)</div></pre></td></tr></table></figure></p>
<p>增/删属性:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_create_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_remove_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
<h4 id="设备驱动程序-include-linux-device-h"><a href="#设备驱动程序-include-linux-device-h" class="headerlink" title="设备驱动程序 (include/linux/device.h)"></a>设备驱动程序 (include/linux/device.h)</h4><p>结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> driver_attribute &#123;</div><div class="line">        <span class="keyword">struct</span> attribute        attr;</div><div class="line">        <span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> device_driver *, <span class="keyword">char</span> * buf);</div><div class="line">        <span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">char</span> * buf,</div><div class="line">                         <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>声明:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DRIVER_ATTR(_name, _mode, _show, _store)</div></pre></td></tr></table></figure></p>
<p>增/删属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_create_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">struct</span> driver_attribute *)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver_remove_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="keyword">const</span> <span class="keyword">struct</span> driver_attribute *)</span></span>;</div></pre></td></tr></table></figure></p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>sysfs 目录结构以及其中包含的属性定义了一个内核与用户空间之间的 ABI。对于任何 ABI，其自身的稳定和适当的文档是非常重要的。所有新的 sysfs 属性必须在 Documentation/ABI 中有文档。详见 Documentation/ABI/README。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于 kobject，kset 和 ktype 的一切]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/kobject/</url>
      <content type="html"><![CDATA[<p>翻译原文链接：<a href="http://blog.chinaunix.net/uid-20522771-id-3447116.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20522771-id-3447116.html</a><br>内核文档： Documentation/kobject.txt</p>
<blockquote>
<p>Everything you never wanted to know about kobjects, ksets, and ktypes<br>你永远不会想知道的关于 kobject，kset 和 ktype 的一切<br>Greg Kroah-Hartman</p>
</blockquote>
<p>Based on an original article by Jon Corbet for lwn.net written October 1,<br>2003 and located at <a href="http://lwn.net/Articles/51437/" target="_blank" rel="external">http://lwn.net/Articles/51437/</a></p>
<p>Last updated December 19, 2007<br><a id="more"></a><br>理解那些建立在<code>kobject</code>抽象之上的驱动模型的困难之一就是没有一个明确的入口。<br>使用<code>kobject</code>需要了解几种不同的类型，而这些类型又会相互引用。为了让这一切变<br>得简单些，我们将采取多通道方法，以模糊的术语开始，然后逐渐添加细节。为此，<br>现在给出一些今后会使用到的一些术语的简单定义。</p>
<ul>
<li><code>kobject</code>是一个<code>struct kobject</code>类型的对象。<code>kobject</code>包含一个名字和一个<br>引用计数。同时一个<code>kobject</code>还包含一个父指针（允许对象被安排成层次结构）、<br>一个特定的类型，通常情况下还有一个在<code>sysfs</code>虚拟文件系统里的表现。<br>通常我们并不关注<code>kobject</code>本身，而应该关注那些嵌入了<code>kobject</code>的那些结构体。<br>任何结构体都不允许包含一个以上的<code>kobject</code>。如果这么做，那么引用计数将肯<br>定会出错，你的代码也将bug百出。所以千万别这么做。</li>
<li><code>ktype</code>是嵌入了<code>kobject</code>的对象的类型。每个嵌入了<code>kobject</code>的对象都需要一个<br>相应的<code>ktype</code>。<code>ktype</code>用来控制当<code>kobject</code>创建和销毁时所发生的操作。</li>
<li><p><code>kset</code>是<code>kobject</code>的一组集合。这些<code>kobject</code>可以是同样的<code>ktype</code>，也可以分别<br>属于不同的<code>ktype</code>。<code>kset</code>是<code>kobject</code>集合的基本容器类型。<code>kset</code>也包含它们自<br>己的<code>kobject</code>，但是你可以放心的忽略这些<code>kobjects</code>，因为<code>kset</code>的核心代码会<br>自动处理这些<code>kobject</code>。</p>
<p>当你看到一个<code>sysfs</code>目录里全都是其它目录时，通常每一个目录都对应着一个在<br>同一个<code>kset</code>里的<code>kobject</code>。</p>
</li>
</ul>
<p>我们来看看如何创建和操作所有的这些类型。因为采用自下而上的方法，所以我们<br>首先回到<code>kobject</code>。</p>
<p><code>kobject</code>结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kobject &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span>              *name;</div><div class="line">        <span class="keyword">struct</span> list_head        entry;</div><div class="line">        <span class="keyword">struct</span> kobject          *parent;</div><div class="line">        <span class="keyword">struct</span> kset             *kset;</div><div class="line">        <span class="keyword">struct</span> kobj_type        *ktype;</div><div class="line">        <span class="keyword">struct</span> sysfs_dirent     *sd;</div><div class="line">        <span class="keyword">struct</span> kref             kref;</div><div class="line">        .</div><div class="line">        .</div><div class="line">        .</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="内嵌-kobject"><a href="#内嵌-kobject" class="headerlink" title="内嵌 kobject"></a>内嵌 kobject</h2><p>就内核代码而言，基本上不会创建一个单独的<code>kobject</code>，但也有例外，这以后再说。<br>其实，<code>kobject</code>通常被用来控制一个更大的特定域对象。因此你将发现<code>kobject</code>都被<br>嵌入到了其他的结构体当中。如果从面向对象的观点出发，那么<code>kobject</code>可以被看做<br>是被其他类继承的、顶层的、抽象的类。一个<code>kobject</code>实现了一组对于它们自己不是<br>很有用，但对那些包含了这个<code>kobject</code>的对象很有用的功能。另外 C 语言不支持直接<br>使用继承，所以必须依靠其他的技术来实现，比如结构体嵌套。</p>
<p>（顺便说一句，对于那些熟悉内核链表实现的同志来说，这和“list_head”结构体很<br>类似。它们都是本身没什么用，其真正的价值是在嵌套进一个更大的结构体中才得以<br>体现。）</p>
<p>举一个例子，drivers/uio/uio.c 里的 UIO 代码包含一个定义了内存区域的 uio 设备。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> uio_map &#123;</div><div class="line">    <span class="keyword">struct</span> kobject kobj;</div><div class="line">    <span class="keyword">struct</span> uio_mem *mem;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果你有一个<code>struct uio_map</code>结构体，使用它的成员<code>kobj</code>就能找到嵌套的<code>kobject</code>。<br>但是操作<code>kobject</code>的代码往往会引出一个相反的问题：如果给定一个<code>struct kobject</code><br>指针，那么包含这个指针的结构体又是什么呢？别投机取巧（比如假设这个<code>kobject</code><br>是该结构体的第一个字段），你应该使用<code>container_of()</code>宏函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">container_of(pointer, type, member)</div></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>“<code>pointer</code>“ 是指向被嵌入的<code>kobject</code>的指针。</li>
<li>“<code>type</code>“ 是包含<code>kobject</code>的结构体类型。</li>
<li>“<code>member</code>“ 是结构体中”<code>pointer</code>“所指向的字段名。<br><code>container_of()</code>的返回值就是一个相应结构体的指针。例如，一个指向嵌套在<code>uio_map</code>里的<code>struct kobject</code>的指针“<code>kp</code>”，可以这样获得包含它的结构体的指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> uio_map *u_map = container_of(kp, <span class="keyword">struct</span> uio_map, kobj);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>为方便起见，程序员通常会定义一个简单的宏，用于“反指”包含这个<code>kobject</code>的容器<br>类型指针。正因为这样，在以前的文件 drivers/uio/uio.c 中你可以看到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> uio_map &#123;</div><div class="line">    <span class="keyword">struct</span> kobject kobj;</div><div class="line">    <span class="keyword">struct</span> uio_mem *mem;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> to_map(map) container_of(map, struct uio_map, kobj)</span></div></pre></td></tr></table></figure></p>
<p>宏参数“<code>map</code>”是一个指向<code>struct kobject</code>的指针。这个宏函数将随后被调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> uio_map *<span class="built_in">map</span> = to_map(kobj);</div></pre></td></tr></table></figure></p>
<h2 id="kobject-的初始化"><a href="#kobject-的初始化" class="headerlink" title="kobject 的初始化"></a>kobject 的初始化</h2><p>创建一个<code>kobject</code>的代码首先必须初始化这个对象。调用<code>kobject_init()</code>来设置一些<br>内部字段（强制性的）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_init</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype)</span></span>;</div></pre></td></tr></table></figure></p>
<p>因为每一个<code>kobject</code>都有一个关联的<code>kobj_type</code>，所以正确创建一个<code>kobject</code>时<br><code>ktype</code>是必须的。调用<code>kobject_init()</code>之后，必须是用<code>kobject_add()</code>在<code>sysfs</code>上<br>注册<code>kobject</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_add</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这将为<code>kobject</code>设置<code>parent</code>和<code>name</code>。如果这个<code>kobject</code>将关联于一个指定的<br><code>kset</code>，那么<code>kobj-&gt;kset</code>必须在<code>kobject_add()</code>之前被赋值。如果一个<code>ket</code>关联<br>于一个<code>kobject</code>，那么在调用<code>kobject_add()</code>时<code>parent</code>可以是<code>NULL</code>，这时<code>kobject</code><br>的<code>parent</code>将会是这个<code>kset</code>本身。</p>
<p>当一个<code>kobject</code>的<code>name</code>已经被设置并添加至<code>kernel</code>之后，就不允许直接操作这个<br><code>kobject</code>的<code>name</code>了。如果你必须修改这个<code>name</code>，请使用<code>kobject_rename()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_rename</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">const</span> <span class="keyword">char</span> *new_name)</span></span>;</div></pre></td></tr></table></figure></p>
<p><code>kobject_rename</code>不会执行任何锁定操作，也不会验证<code>name</code>的有效性，所以调用者<br>必须提供自己的完整性检查和序列化。</p>
<p>这里有一个函数<code>kobject_set_name()</code>，但这个函数是遗留问题，而且在将来会被删<br>除。如果你的代码需要调用这个函数，那么这将是不正确的并且必须被修正。</p>
<p>要正确访问<code>kobject</code>的<code>name</code>，使用这个函数<code>kobject_name()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">kobject_name</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> kobject * kobj)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这里有一个辅助函数将同时初始化<code>kobject</code>并将其添加至 kernel，<code>kobject_init_and_add()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype,</span></span></div><div class="line">                         <span class="keyword">struct</span> kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...);</div></pre></td></tr></table></figure></p>
<p>其中的参数与<code>kobject_init()</code>和<code>kobject_add()</code>里描述的一致。</p>
<h2 id="Uevents"><a href="#Uevents" class="headerlink" title="Uevents"></a>Uevents</h2><p>在一个<code>kobject</code>注册到核心(core)之后，你需要通过<code>kobject_uevent()</code>向系统宣布它被创建了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span></span>;</div></pre></td></tr></table></figure></p>
<p>当<code>kobject</code>首次被添加进 kernel 时，使用<code>KOBJ_ADD</code>动作。这个调用必须在<code>kobject</code>所有<br>的<code>attributes</code>或<code>children</code>都被正确初始化之后，因为当这个调用发生时，用户空间将会<br>立即开始寻找它们。</p>
<p>当<code>kobject</code>从 kernel 中移除时，<code>KOBJ_REMOVE</code>的<code>uevent</code>将会被<code>kobject</code>核心(core)<br>自动创建，所以调用者不必担心手动完成这些。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>一个<code>kobject</code>的主要功能之一就是在它被嵌入的对象中作为一个引用计数器。只要存<br>在对该对象的引用，对象（和支持它的代码）就必须继续存在。操作一个<code>kobject</code>的<br>引用计数的底层函数是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> kobject *<span class="title">kobject_get</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_put</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span>;</div></pre></td></tr></table></figure></p>
<p>对<code>kobject_get()</code>的成功调用将递增<code>kobject</code>的引用计数并且返回指向该<code>kobject</code>的指针。</p>
<p>当一个引用被释放时，调用<code>kobject_put()</code>将递减引用计数，并且可能的话，释放对象。<br>请注意，<code>kobject_init()</code>将引用计数设置为 1，所以在建立<code>kobject</code>的代码里需要执行<br><code>kobject_put()</code>用于最终释放该引用。</p>
<p>因为<code>kobject</code>是动态的，所以它们不能被声明为静态的或者在栈区分配空间，它们<br>应该始终被动态分配。未来的 kernel 版本将会包含一个对<code>kobject</code>是否静态创建的<br>运行时检查，并且会警告开发人员这种不正确的使用。</p>
<p>如果你使用<code>kobject</code>的理由仅仅是使用引用计数的话，那么请使用<code>struct kref</code>替代<br><code>kobject</code>。更多关于<code>struct kref</code>的信息请参考 Linux 内核文档 Documentation/kref.txt</p>
<h2 id="创建“简单”的-kobject"><a href="#创建“简单”的-kobject" class="headerlink" title="创建“简单”的 kobject"></a>创建“简单”的 kobject</h2><p>有时开发人员希望有一种创建一个在 sysfs 层次中简单目录的方式，而并不想搞乱本来<br>就错综复杂的<code>ksets</code>，<code>show</code> 和<code>store</code>函数，或一些其他的细节。这是一个创建单独的<br><code>kobjects</code>的一个例外。要创建这样的条目，使用这个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> kobject *<span class="title">kobject_create_and_add</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">struct</span> kobject *parent)</span></span>;</div></pre></td></tr></table></figure></p>
<p>此函数将创建一个<code>kobject</code>，并将其放置在指定的父<code>kobject</code>在 sysfs 中的目录下。<br>要创建简单的与这个<code>kobject</code>关联的属性，使用函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr)</span></span>;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_group</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute_group *grp)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这两种使用<code>kobject_create_and_add()</code>创建的<code>kobject</code>的属性类型都可以是<br><code>kobj_attribute</code>，所以没有创建自定义属性的需要。</p>
<p>查看示例模块 samples/kobject/kobject-example.c，一个简单的<code>kobject</code><br>及其属性的实现。</p>
<h2 id="ktypes-和-release-方法"><a href="#ktypes-和-release-方法" class="headerlink" title="ktypes 和 release 方法"></a>ktypes 和 release 方法</h2><p>到目前为止我们遗漏了一个重要的事情，那就是当一个<code>kobject</code>的引用计数达到 0 时将<br>会发生什么。通常，创建<code>kobject</code>的代码并不知道这种情况何时发生。如果它们知道何<br>时发生，那么把<code>kobject</code>放在结构体的首位可能会有那么一点点帮助。即使是一个可预<br>测的对象生命周期也将变得复杂，特别是在 sysfs 作为 kernel 的一部分被引入时，它<br>可以获取到任意在系统中注册的<code>kobject</code>的引用。</p>
<p>结论就是一个被<code>kobject</code>保护的结构体不能在这个<code>kobject</code>引用计数到 0 之前被释放。<br>而这个引用计数又不被创建这个<code>kobject</code>的代码所直接控制，所以必须在这个<code>kobject</code><br>的最后一个引用消失时异步通知这些代码。</p>
<p>一旦你通过<code>kobject_add()</code> 注册你的<code>kobject</code>之后，永远也不要使用<code>kfree()</code>去释<br>放直接它。唯一安全的途径是使用<code>kobject_put()</code>。总是在<code>kobject_init()</code>之后使<br>用<code>kobject_put()</code>是避免错误蔓延的很好的做法。</p>
<p>这个通知是通过<code>kobject</code>的<code>release()</code>函数完成的。该函数通常具有这样的形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_object_release</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">struct</span> my_object *mine = container_of(kobj, <span class="keyword">struct</span> my_object, kobj);</div><div class="line"></div><div class="line">   kfree(mine);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很重要的一点怎么强调也不过分：每个<code>kobject</code>必须有一个<code>release()</code>方法，而且<br>在这个方法被调用之前<code>kobject</code>必须继续存在（保持一致的状态）。如果不符合这<br>些限制，那么代码是有缺陷的。需要注意的是，如果你忘记提供一个<code>release()</code>方法，<br>kernel 会警告你。不要试图提供一个“空”的<code>release</code>函数来摆脱这个警告，如果你<br>这样做你会受到<code>kobject</code>维护者们无情的嘲笑。</p>
<p>注意，尽管在<code>release</code>函数中<code>kobject</code>的<code>name</code>是可用的，但是千万不要在这个回调函<br>数中修改它。否则将会在<code>kobject</code>核心(core)中发生令人不愉快的内存泄露问题。</p>
<p>有趣的是<code>release()</code>方法并没有保存在<code>kobject</code>之中，而是关联在它的<code>ktype</code><br>成员中。让我们来介绍<code>struct kobj_type</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kobj_type &#123;</div><div class="line">    <span class="keyword">void</span> (*release)(<span class="keyword">struct</span> kobject *);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> sysfs_ops *sysfs_ops;</div><div class="line">    <span class="keyword">struct</span> attribute **default_attrs;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个结构体是用来描述一个特定类型的<code>kobject</code>（或者更确切的说，包含它的对象）。<br>每个<code>kobject</code>都需要一个关联的<code>kobj_type</code>结构体，当你调用<code>kobject_init()</code>或<br><code>kobject_init_and_add()</code>时必须指定一个指向<code>kobj_type</code>结构体的指针。</p>
<p>当然<code>struct kobj_type</code>中的<code>release</code>字段就是一个指向同类型对象<code>release()</code>方法的<br>函数指针。另外两个字段（<code>sysfs_ops</code>和<code>default_attrs</code>）是用来控制这些类型的对象在<br>sysfs 里是如何表现的，这已经超出了本文的讨论范围。</p>
<p><code>default_attrs</code>成员指针是一个在任何属于这个<code>ktype</code>的<code>kobject</code>注册时自动创<br>建的默认属性列表。</p>
<h2 id="ksets"><a href="#ksets" class="headerlink" title="ksets"></a>ksets</h2><p><code>kset</code>仅仅是一个需要相互关联的<code>kobject</code>集合。在这里没有任何规定它们必须是同<br>样的<code>ktype</code>，但如果它们不是一样的<code>ktype</code>，则一定要小心处理。</p>
<p>一个<code>kset</code>提供以下功能：</p>
<ul>
<li>它就像一个装有一堆对象袋子。<code>kset</code>可以被 kernel 用来跟踪像“所有的块设备”<br>或者“所有的 PCI 设备驱动”这样的东西。</li>
<li>一个<code>kset</code>也是一个 sysfs 里的子目录，该目录里能够看见这些相关的<code>kobject</code>。<br>每个<code>kset</code>都包含一个<code>kobject</code>，这个<code>kobject</code>可以用来设置成其他<code>kobjects</code><br>的<code>parent</code>。sysfs 层次结构中的顶层目录就是通过这样的方法构建的。</li>
<li><code>kset</code>还可以支持<code>kobject</code>的“热插拔”，并会影响<code>uevent</code>事件如何报告给用户空间。</li>
</ul>
<p>以面向对象的观点来看，“<code>kset</code>” 是一个顶层容器类。<code>kset</code>包含有它们自己的<code>kobject</code>，<br>这个<code>kobject</code>是在<code>kset</code>代码管理之下的，而且不允许其他任何用户对其操作。</p>
<p>一个<code>kset</code>使用标准的 kernel 链表来保存它的<code>children</code>。<code>kobjects</code>通过它们的<code>kset</code><br>字段回指向包含它们的<code>kset</code>。在几乎所有的情况下，属于某<code>kset</code>的<code>kobject</code>的<br><code>parent</code>都指向这个<code>kset</code>（严格来说是嵌套进这个<code>kset</code>的<code>kobject</code>）。</p>
<p>正是因为一个<code>kset</code>包含了一个<code>kobject</code>，就应该始终动态创建这个<code>kset</code>，千万<br>不要将其声明为静态的或在栈区分配空间。创建一个<code>kset</code>使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></div><div class="line">                                 <span class="keyword">struct</span> kset_uevent_ops *u,</div><div class="line">                                 <span class="keyword">struct</span> kobject *parent);</div></pre></td></tr></table></figure></p>
<p>当你使用完一个<code>kset</code>时，调用这个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kset_unregister</span><span class="params">(<span class="keyword">struct</span> kset *kset)</span></span>;</div></pre></td></tr></table></figure></p>
<p>来销毁它。</p>
<p>内核树中的 samples/kobject/kset-example.c 文件是一个<br>有关于如何使用<code>kset</code>的示例。</p>
<p>如果一个<code>kset</code>希望控制那些与它相关联的<code>kobject</code>的<code>uevent</code>操作，可以使用<br><code>struct kset_uevent_ops</code>处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kset_uevent_ops &#123;</div><div class="line">    <span class="keyword">int</span> (*filter)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*name)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj);</div><div class="line">    <span class="keyword">int</span> (*uevent)(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</div><div class="line">                  <span class="keyword">struct</span> kobj_uevent_env *env);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>filter</code>函数允许<code>kset</code>阻止一个特定的<code>kobject</code>的<code>uevent</code>是否发送到用户空间。如果<br>这个函数返回 0，则<code>uevent</code>将不会被发出。</p>
<p><code>name</code>函数用来重写那些将被<code>uevent</code>发送到用户空间的<code>kset</code>的默认名称。默认情况下，<br>这个名称应该和<code>kset</code>本身的名称相同，但如果提供这个函数，则可以改写这个名称。</p>
<p><code>uevent</code>函数会向即将被发送到用户空间的<code>uevent</code>添加更多的环境变量。</p>
<p>有人可能会问，当一个<code>kobject</code>加入到一个<code>kset</code> 但没有提供完成这些功能的函数时，情况会怎样？<br>答案就是这些任务将由<code>kobject_add()</code>来完成，当一个<code>kobject</code>传递给<code>kobject_add()</code>函数，它的<code>kset</code>成员必将指向它将被<br>加入到的<code>kset</code>，然后<code>kobject_add()</code>会帮你干完剩下的活。</p>
<p>如果一个属于某个<code>kset</code>的<code>kobject</code>没有设置它的<code>parent kobject</code>，那么它将被<br>添加到<code>kset</code>的目录中去。但并不是<code>kset</code>的所有成员都一定存在于<code>kset</code>目录下。<br>如果在<code>kobject</code>被添加前就指明了它的<code>parent kobject</code>， 那么该<code>kobject</code>将被<br>注册到这个<code>kset</code>下，然后添加到它的<code>parent kobject</code>下。</p>
<h2 id="kobject-的移除"><a href="#kobject-的移除" class="headerlink" title="kobject 的移除"></a>kobject 的移除</h2><p>当一个<code>kobject</code>成功的注册到<code>kobject</code>核心(core)之后，这个<code>kobject</code>必须在代码完成对它的<br>使用时销毁。要做到这一点，请调用<code>kobject_put()</code>。通过这个调用，<code>kobject</code> 核心(core)会<br>自动清理所有通过这个<code>kobject</code>分配的内存空间。如果曾经为了这个<code>kobject</code>发送过一个<br><code>KOBJ_ADD</code> uevent，那么一个相应的<code>KOBJ_REMOVE</code> uevent 将会被发送，并且任何<br>其他的 sysfs 维护者都将为这个调用作出相应的处理。</p>
<p>如果你需要分两步来删除一个<code>kobject</code>的话（也就是说在你需要销毁一个对象时不允<br>许 sleep），那么请使用<code>kobject_del()</code>从 sysfs 注销这个<code>kobject</code>。这将使得该<br><code>kobject</code> “不可见”，但是它并没有被清理，并且它的引用计数也没变。在稍后的时候<br>调用<code>kobject_put()</code>去完成与这个<code>kobject</code>相关的内存空间的清理。</p>
<p>如果建立了循环引用，<code>kobject_del()</code>可以用来删除指向<code>parent</code>对象的引用。<br>一些情况下，某个<code>parnet</code>对象引用了它的<code>child</code>是合法的，循环引用必须<br>显式的通过调用<code>kobject_del()</code> 来打破，这样做之后将会调用一个<code>release</code>函数，<br>先前在循环引用中的对象才会彼此释放。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>想要获得更完整的关于正确使用<code>kset</code>和<code>kobject</code>的例子，请参考示例程序<br>samples/kobject/{kobject-example.c,kset-example.c}。可以通过选择编译条件<br><code>CONFIG_SAMPLE_KOBJECT</code>来把这些示例编译成可装载模块。</p>
<p>samples/kobject/kobject-example.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Sample kobject implementation</div><div class="line"> *</div><div class="line"> * Copyright (C) 2004-2007 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</div><div class="line"> * Copyright (C) 2007 Novell Inc.</div><div class="line"> *</div><div class="line"> * Released under the GPL version 2 only.</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * This module shows how to create a simple subdirectory in sysfs called</div><div class="line"> * /sys/kernel/kobject-example  In that directory, 3 files are created:</div><div class="line"> * "foo", "baz", and "bar".  If an integer is written to these files, it can be</div><div class="line"> * later read out of it.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> foo;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> baz;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> bar;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * The "foo" file where a static variable is read from and written to.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_attribute *attr,</span></span></div><div class="line">			<span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, foo);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_attribute *attr,</span></span></div><div class="line">			 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">sscanf</span>(buf, <span class="string">"%du"</span>, &amp;foo);</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_attribute foo_attribute =</div><div class="line">	__ATTR(foo, <span class="number">0666</span>, foo_show, foo_store);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * More complex function where we determine which variable is being accessed by</div><div class="line"> * looking at the attribute for the "baz" and "bar" files.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">b_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_attribute *attr,</span></span></div><div class="line">		      <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> var;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(attr-&gt;attr.name, <span class="string">"baz"</span>) == <span class="number">0</span>)</div><div class="line">		var = baz;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		var = bar;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, var);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">b_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_attribute *attr,</span></span></div><div class="line">		       <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> var;</div><div class="line"></div><div class="line">	<span class="built_in">sscanf</span>(buf, <span class="string">"%du"</span>, &amp;var);</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(attr-&gt;attr.name, <span class="string">"baz"</span>) == <span class="number">0</span>)</div><div class="line">		baz = var;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		bar = var;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_attribute baz_attribute =</div><div class="line">	__ATTR(baz, <span class="number">0666</span>, b_show, b_store);</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_attribute bar_attribute =</div><div class="line">	__ATTR(bar, <span class="number">0666</span>, b_show, b_store);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Create a group of attributes so that we can create and destroy them all</div><div class="line"> * at once.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *attrs[] = &#123;</div><div class="line">	&amp;foo_attribute.attr,</div><div class="line">	&amp;baz_attribute.attr,</div><div class="line">	&amp;bar_attribute.attr,</div><div class="line">	<span class="literal">NULL</span>,	<span class="comment">/* need to NULL terminate the list of attributes */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * An unnamed attribute group will put all of the attributes directly in</div><div class="line"> * the kobject directory.  If we specify a name, a subdirectory will be</div><div class="line"> * created for the attributes with the directory being the name of the</div><div class="line"> * attribute group.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute_group attr_group = &#123;</div><div class="line">	.attrs = attrs,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobject *example_kobj;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Create a simple kobject with the name of "kobject_example",</div><div class="line">	 * located under /sys/kernel/</div><div class="line">	 *</div><div class="line">	 * As this is a simple directory, no uevent will be sent to</div><div class="line">	 * userspace.  That is why this function should not be used for</div><div class="line">	 * any type of dynamic kobjects, where the name and number are</div><div class="line">	 * not known ahead of time.</div><div class="line">	 */</div><div class="line">	example_kobj = kobject_create_and_add(<span class="string">"kobject_example"</span>, kernel_kobj);</div><div class="line">	<span class="keyword">if</span> (!example_kobj)</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">	<span class="comment">/* Create the files associated with this kobject */</span></div><div class="line">	retval = sysfs_create_group(example_kobj, &amp;attr_group);</div><div class="line">	<span class="keyword">if</span> (retval)</div><div class="line">		kobject_put(example_kobj);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> retval;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	kobject_put(example_kobj);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(example_init);</div><div class="line">module_exit(example_exit);</div><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"Greg Kroah-Hartman &lt;greg@kroah.com&gt;"</span>);</div></pre></td></tr></table></figure></p>
<p>samples/kobject/kset-example.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Sample kset and ktype implementation</div><div class="line"> *</div><div class="line"> * Copyright (C) 2004-2007 Greg Kroah-Hartman &lt;greg@kroah.com&gt;</div><div class="line"> * Copyright (C) 2007 Novell Inc.</div><div class="line"> *</div><div class="line"> * Released under the GPL version 2 only.</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * This module shows how to create a kset in sysfs called</div><div class="line"> * /sys/kernel/kset-example</div><div class="line"> * Then tree kobjects are created and assigned to this kset, "foo", "baz",</div><div class="line"> * and "bar".  In those kobjects, attributes of the same name are also</div><div class="line"> * created and if an integer is written to these files, it can be later</div><div class="line"> * read out of it.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * This is our "object" that we will create a few of and register them with</div><div class="line"> * sysfs.</div><div class="line"> */</div><div class="line"><span class="keyword">struct</span> foo_obj &#123;</div><div class="line">	<span class="keyword">struct</span> kobject kobj;</div><div class="line">	<span class="keyword">int</span> foo;</div><div class="line">	<span class="keyword">int</span> baz;</div><div class="line">	<span class="keyword">int</span> bar;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> to_foo_obj(x) container_of(x, struct foo_obj, kobj)</span></div><div class="line"></div><div class="line"><span class="comment">/* a custom attribute that works just for a struct foo_obj. */</span></div><div class="line"><span class="keyword">struct</span> foo_attribute &#123;</div><div class="line">	<span class="keyword">struct</span> attribute attr;</div><div class="line">	<span class="keyword">ssize_t</span> (*show)(<span class="keyword">struct</span> foo_obj *foo, <span class="keyword">struct</span> foo_attribute *attr, <span class="keyword">char</span> *buf);</div><div class="line">	<span class="keyword">ssize_t</span> (*store)(<span class="keyword">struct</span> foo_obj *foo, <span class="keyword">struct</span> foo_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> to_foo_attr(x) container_of(x, struct foo_attribute, attr)</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * The default show function that must be passed to sysfs.  This will be</div><div class="line"> * called by sysfs for whenever a show function is called by the user on a</div><div class="line"> * sysfs file associated with the kobjects we have registered.  We need to</div><div class="line"> * transpose back from a "default" kobject to our custom struct foo_obj and</div><div class="line"> * then call the show function for that specific object.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span></div><div class="line">			     <span class="keyword">struct</span> attribute *attr,</div><div class="line">			     <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> foo_attribute *attribute;</div><div class="line">	<span class="keyword">struct</span> foo_obj *foo;</div><div class="line"></div><div class="line">	attribute = to_foo_attr(attr);</div><div class="line">	foo = to_foo_obj(kobj);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!attribute-&gt;show)</div><div class="line">		<span class="keyword">return</span> -EIO;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> attribute-&gt;show(foo, attribute, buf);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Just like the default show function above, but this one is for when the</div><div class="line"> * sysfs "store" is requested (when a value is written to a file.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_attr_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span></div><div class="line">			      <span class="keyword">struct</span> attribute *attr,</div><div class="line">			      <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> foo_attribute *attribute;</div><div class="line">	<span class="keyword">struct</span> foo_obj *foo;</div><div class="line"></div><div class="line">	attribute = to_foo_attr(attr);</div><div class="line">	foo = to_foo_obj(kobj);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!attribute-&gt;store)</div><div class="line">		<span class="keyword">return</span> -EIO;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> attribute-&gt;store(foo, attribute, buf, len);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Our custom sysfs_ops that we will associate with our ktype later on */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> sysfs_ops foo_sysfs_ops = &#123;</div><div class="line">	.show = foo_attr_show,</div><div class="line">	.store = foo_attr_store,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * The release function for our object.  This is REQUIRED by the kernel to</div><div class="line"> * have.  We free the memory held in our object here.</div><div class="line"> *</div><div class="line"> * NEVER try to get away with just a "blank" release function to try to be</div><div class="line"> * smarter than the kernel.  Turns out, no one ever is...</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo_release</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> foo_obj *foo;</div><div class="line"></div><div class="line">	foo = to_foo_obj(kobj);</div><div class="line">	kfree(foo);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * The "foo" file where the .foo variable is read from and written to.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_show</span><span class="params">(<span class="keyword">struct</span> foo_obj *foo_obj, <span class="keyword">struct</span> foo_attribute *attr,</span></span></div><div class="line">			<span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, foo_obj-&gt;foo);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">foo_store</span><span class="params">(<span class="keyword">struct</span> foo_obj *foo_obj, <span class="keyword">struct</span> foo_attribute *attr,</span></span></div><div class="line">			 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">sscanf</span>(buf, <span class="string">"%du"</span>, &amp;foo_obj-&gt;foo);</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_attribute foo_attribute =</div><div class="line">	__ATTR(foo, <span class="number">0666</span>, foo_show, foo_store);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * More complex function where we determine which variable is being accessed by</div><div class="line"> * looking at the attribute for the "baz" and "bar" files.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">b_show</span><span class="params">(<span class="keyword">struct</span> foo_obj *foo_obj, <span class="keyword">struct</span> foo_attribute *attr,</span></span></div><div class="line">		      <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> var;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(attr-&gt;attr.name, <span class="string">"baz"</span>) == <span class="number">0</span>)</div><div class="line">		var = foo_obj-&gt;baz;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		var = foo_obj-&gt;bar;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, var);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">b_store</span><span class="params">(<span class="keyword">struct</span> foo_obj *foo_obj, <span class="keyword">struct</span> foo_attribute *attr,</span></span></div><div class="line">		       <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> var;</div><div class="line"></div><div class="line">	<span class="built_in">sscanf</span>(buf, <span class="string">"%du"</span>, &amp;var);</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(attr-&gt;attr.name, <span class="string">"baz"</span>) == <span class="number">0</span>)</div><div class="line">		foo_obj-&gt;baz = var;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		foo_obj-&gt;bar = var;</div><div class="line">	<span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_attribute baz_attribute =</div><div class="line">	__ATTR(baz, <span class="number">0666</span>, b_show, b_store);</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_attribute bar_attribute =</div><div class="line">	__ATTR(bar, <span class="number">0666</span>, b_show, b_store);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Create a group of attributes so that we can create and destroy them all</div><div class="line"> * at once.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *foo_default_attrs[] = &#123;</div><div class="line">	&amp;foo_attribute.attr,</div><div class="line">	&amp;baz_attribute.attr,</div><div class="line">	&amp;bar_attribute.attr,</div><div class="line">	<span class="literal">NULL</span>,	<span class="comment">/* need to NULL terminate the list of attributes */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Our own ktype for our kobjects.  Here we specify our sysfs ops, the</div><div class="line"> * release function, and the set of default attributes we want created</div><div class="line"> * whenever a kobject of this type is registered with the kernel.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_type foo_ktype = &#123;</div><div class="line">	.sysfs_ops = &amp;foo_sysfs_ops,</div><div class="line">	.release = foo_release,</div><div class="line">	.default_attrs = foo_default_attrs,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kset *example_kset;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_obj *foo_obj;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_obj *bar_obj;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> foo_obj *baz_obj;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> foo_obj *<span class="title">create_foo_obj</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> foo_obj *foo;</div><div class="line">	<span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">	<span class="comment">/* allocate the memory for the whole object */</span></div><div class="line">	foo = kzalloc(<span class="keyword">sizeof</span>(*foo), GFP_KERNEL);</div><div class="line">	<span class="keyword">if</span> (!foo)</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * As we have a kset for this kobject, we need to set it before calling</div><div class="line">	 * the kobject core.</div><div class="line">	 */</div><div class="line">	foo-&gt;kobj.kset = example_kset;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Initialize and add the kobject to the kernel.  All the default files</div><div class="line">	 * will be created here.  As we have already specified a kset for this</div><div class="line">	 * kobject, we don't have to set a parent for the kobject, the kobject</div><div class="line">	 * will be placed beneath that kset automatically.</div><div class="line">	 */</div><div class="line">	retval = kobject_init_and_add(&amp;foo-&gt;kobj, &amp;foo_ktype, <span class="literal">NULL</span>, <span class="string">"%s"</span>, name);</div><div class="line">	<span class="keyword">if</span> (retval) &#123;</div><div class="line">		kobject_put(&amp;foo-&gt;kobj);</div><div class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * We are always responsible for sending the uevent that the kobject</div><div class="line">	 * was added to the system.</div><div class="line">	 */</div><div class="line">	kobject_uevent(&amp;foo-&gt;kobj, KOBJ_ADD);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> foo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy_foo_obj</span><span class="params">(<span class="keyword">struct</span> foo_obj *foo)</span></span></div><div class="line">&#123;</div><div class="line">	kobject_put(&amp;foo-&gt;kobj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">example_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Create a kset with the name of "kset_example",</div><div class="line">	 * located under /sys/kernel/</div><div class="line">	 */</div><div class="line">	example_kset = kset_create_and_add(<span class="string">"kset_example"</span>, <span class="literal">NULL</span>, kernel_kobj);</div><div class="line">	<span class="keyword">if</span> (!example_kset)</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Create three objects and register them with our kset</div><div class="line">	 */</div><div class="line">	foo_obj = create_foo_obj(<span class="string">"foo"</span>);</div><div class="line">	<span class="keyword">if</span> (!foo_obj)</div><div class="line">		<span class="keyword">goto</span> foo_error;</div><div class="line"></div><div class="line">	bar_obj = create_foo_obj(<span class="string">"bar"</span>);</div><div class="line">	<span class="keyword">if</span> (!bar_obj)</div><div class="line">		<span class="keyword">goto</span> bar_error;</div><div class="line"></div><div class="line">	baz_obj = create_foo_obj(<span class="string">"baz"</span>);</div><div class="line">	<span class="keyword">if</span> (!baz_obj)</div><div class="line">		<span class="keyword">goto</span> baz_error;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">baz_error:</div><div class="line">	destroy_foo_obj(bar_obj);</div><div class="line">bar_error:</div><div class="line">	destroy_foo_obj(foo_obj);</div><div class="line">foo_error:</div><div class="line">	kset_unregister(example_kset);</div><div class="line">	<span class="keyword">return</span> -EINVAL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">example_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	destroy_foo_obj(baz_obj);</div><div class="line">	destroy_foo_obj(bar_obj);</div><div class="line">	destroy_foo_obj(foo_obj);</div><div class="line">	kset_unregister(example_kset);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(example_init);</div><div class="line">module_exit(example_exit);</div><div class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</div><div class="line">MODULE_AUTHOR(<span class="string">"Greg Kroah-Hartman &lt;greg@kroah.com&gt;"</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核代码风格]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3/codingstyle/</url>
      <content type="html"><![CDATA[<p>Chinese translated version of Documentation/CodingStyle</p>
<p>If you have any comment or update to the content, please post to LKML directly.<br>However, if you have problem communicating in English you can also ask the<br>Chinese maintainer for help.  Contact the Chinese maintainer, if this<br>translation is outdated or there is problem with translation.</p>
<h2 id="Chinese-maintainer-Zhang-Le-lt-r0bertz-gentoo-org-gt"><a href="#Chinese-maintainer-Zhang-Le-lt-r0bertz-gentoo-org-gt" class="headerlink" title="Chinese maintainer: Zhang Le &lt;r0bertz@gentoo.org&gt;"></a>Chinese maintainer: Zhang Le &lt;r0bertz@gentoo.org&gt;</h2><p>Documentation/CodingStyle的中文翻译</p>
<p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话，也可<br>以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版维护者。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>中文版维护者：</td>
<td>张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</td>
</tr>
<tr>
<td>中文版翻译者：</td>
<td>张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</td>
</tr>
<tr>
<td>中文版校译者：</td>
<td>王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</td>
</tr>
<tr>
<td></td>
<td>wheelz &lt;kernel.zeng@gmail.com&gt;</td>
</tr>
<tr>
<td></td>
<td>管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</td>
</tr>
<tr>
<td></td>
<td>Li Zefan &lt;lizf@cn.fujitsu.com&gt;</td>
</tr>
<tr>
<td></td>
<td>Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</td>
</tr>
</tbody>
</table>
<h2 id="以下为正文"><a href="#以下为正文" class="headerlink" title="以下为正文"></a>以下为正文</h2><p>这是一个简短的文档，描述了linux内核的首选代码风格。代码风格是因人而异的，而且我<br>不愿意把我的观点强加给任何人，不过这里所讲述的是我必须要维护的代码所遵守的风格，<br>并且我也希望绝大多数其他代码也能遵守这个风格。请在写代码时至少考虑一下本文所述的<br>风格。<br><a id="more"></a></p>
<p>首先，我建议你打印一份GNU代码规范，然后不要读它。烧了它，这是一个具有重大象征性<br>意义的动作。</p>
<p>不管怎样，现在我们开始：</p>
<h2 id="第一章：缩进"><a href="#第一章：缩进" class="headerlink" title="第一章：缩进"></a>第一章：缩进</h2><p>制表符是8个字符，所以缩进也是8个字符。有些异端运动试图将缩进变为4（乃至2）个字符<br>深，这几乎相当于尝试将圆周率的值定义为3。</p>
<p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的屏幕<br>连续看了20小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p>
<p>现在，有些人会抱怨8个字符的缩进会使代码向右边移动的太远，在80个字符的终端屏幕上<br>就很难读这样的代码。这个问题的答案是，如果你需要3级以上的缩进，不管用何种方式你<br>的代码已经有问题了，应该修正你的程序。</p>
<p>简而言之，8个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的<br>时候可以给你警告。留心这个警告。</p>
<p>在<code>switch</code>语句中消除多级缩进的首选的方式是让“<code>switch</code>”和从属于它的“<code>case</code>”标签对齐于同<br>一列，而不要“两次缩进”“<code>case</code>”标签。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (suffix) &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">'G'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'g'</span>:</div><div class="line">	mem &lt;&lt;= <span class="number">30</span>;</div><div class="line">	<span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'M'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'m'</span>:</div><div class="line">	mem &lt;&lt;= <span class="number">20</span>;</div><div class="line">	<span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">'K'</span>:</div><div class="line"><span class="keyword">case</span> <span class="string">'k'</span>:</div><div class="line">	mem &lt;&lt;= <span class="number">10</span>;</div><div class="line">	<span class="comment">/* fall through */</span></div><div class="line"><span class="keyword">default</span>:</div><div class="line">	<span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不要把多个语句放在一行里，除非你有什么东西要隐藏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) do_this;</div><div class="line">  do_something_everytime;</div></pre></td></tr></table></figure></p>
<p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读的表<br>达式。</p>
<p>除了注释、文档和Kconfig之外，不要使用空格来缩进，前面的例子是例外，是有意为之。</p>
<p>选用一个好的编辑器，不要在行尾留空格。</p>
<h2 id="第二章：把长的行和字符串打散"><a href="#第二章：把长的行和字符串打散" class="headerlink" title="第二章：把长的行和字符串打散"></a>第二章：把长的行和字符串打散</h2><p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p>
<p>每一行的长度的限制是80列，我们强烈建议您遵守这个惯例。</p>
<p>长于80列的语句要打散成有意义的片段。每个片段要明显短于原来的语句，而且放置的位置<br>也明显的靠右。同样的规则也适用于有很长参数列表的函数头。长字符串也要打散成较短的<br>字符串。唯一的例外是超过80列可以大幅度提高可读性并且不会隐藏信息的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> (condition)</div><div class="line">		printk(KERN_WARNING <span class="string">"Warning this is a long printk with "</span></div><div class="line">						<span class="string">"3 parameters a: %u b: %u "</span></div><div class="line">						<span class="string">"c: %u \n"</span>, a, b, c);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		next_statement;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="第三章：大括号和空格的放置"><a href="#第三章：大括号和空格的放置" class="headerlink" title="第三章：大括号和空格的放置"></a>第三章：大括号和空格的放置</h2><p>C语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策<br>略并没有多少技术上的原因，不过首选的方式，就像Kernighan和Ritchie展示给我们的，是<br>把起始大括号放在行尾，而把结束大括号放在行首，所以：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x is <span class="literal">true</span>) &#123;</div><div class="line">	we <span class="keyword">do</span> y</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这适用于所有的非函数语句块（if、switch、for、while、do）。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (action) &#123;</div><div class="line"><span class="keyword">case</span> KOBJ_ADD:</div><div class="line">	<span class="keyword">return</span> <span class="string">"add"</span>;</div><div class="line"><span class="keyword">case</span> KOBJ_REMOVE:</div><div class="line">	<span class="keyword">return</span> <span class="string">"remove"</span>;</div><div class="line"><span class="keyword">case</span> KOBJ_CHANGE:</div><div class="line">	<span class="keyword">return</span> <span class="string">"change"</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span></span></div><div class="line">&#123;</div><div class="line">	body of function</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>全世界的异端可能会抱怨这个不一致性是……呃……不一致的，不过所有思维健全的人都知道（<br>a）K&amp;R是<em>正确的</em>，并且（b）K&amp;R是正确的。此外，不管怎样函数都是特殊的（在C语言中<br>，函数是不能嵌套的）。</p>
<p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是<code>do</code>语句中的<br>“<code>while</code>”或者<code>if</code>语句中的“<code>else</code>”，像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">	body of <span class="keyword">do</span>-loop</div><div class="line">&#125; <span class="keyword">while</span> (condition);</div></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (x == y) &#123;</div><div class="line">	..</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">	...</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>理由：K&amp;R。</p>
<p>也请注意这种大括号的放置方式也能使空（或者差不多空的）行的数量最小化，同时不失可<br>读性。因此，由于你的屏幕上的新行是不可再生资源（想想25行的终端屏幕），你将会有更<br>多的空行来放置注释。</p>
<p>当只有一个单独的语句的时候，不用加不必要的大括号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition)</div><div class="line">	action();</div></pre></td></tr></table></figure></p>
<p>这点不适用于本身为某个条件语句的一个分支的单独语句。这时需要在两个分支里都使用大<br>括号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">	do_this();</div><div class="line">	do_that();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	otherwise();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-1：空格"><a href="#3-1：空格" class="headerlink" title="3.1：空格"></a>3.1：空格</h3><p>Linux内核的空格使用方式（主要）取决于它是用于函数还是关键字。（大多数）关键字后<br>要加一个空格。值得注意的例外是<code>sizeof</code>、<code>typeof</code>、<code>alignof</code>和<code>attribute</code>，这些关键字<br>某些程度上看起来更像函数（它们在Linux里也常常伴随小括号而使用，尽管在C语言里这样<br>的小括号不是必需的，就像“<code>struct fileinfo info</code>”声明过后的“<code>sizeof info</code>”）。</p>
<p>所以在这些关键字之后放一个空格：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>, <span class="keyword">switch</span>, <span class="keyword">case</span>, <span class="keyword">for</span>, <span class="keyword">do</span>, <span class="keyword">while</span></div></pre></td></tr></table></figure></p>
<p>但是不要在<code>sizeof</code>、<code>typeof</code>、<code>alignof</code>或者<code>attribute</code>这些关键字之后放空格。例如，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> file);</div></pre></td></tr></table></figure></p>
<p>不要在小括号里的表达式两侧加空格。这是一个反例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = <span class="keyword">sizeof</span>( <span class="keyword">struct</span> file );</div></pre></td></tr></table></figure></p>
<p>当声明指针类型或者返回指针类型的函数时，“*”的首选使用方式是使之靠近变量名或者函<br>数名，而不是靠近类型名。例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *linux_banner;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">memparse</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">char</span> **retptr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">match_strdup</span><span class="params">(<span class="keyword">substring_t</span> *s)</span></span>;</div></pre></td></tr></table></figure></p>
<p>在大多数二元和三元操作符两侧使用一个空格，例如下面所有这些操作符：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</div></pre></td></tr></table></figure></p>
<p>但是一元操作符后不要加空格：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;  *  +  -  ~  !  <span class="keyword">sizeof</span>  typeof  <span class="keyword">alignof</span>  __attribute__  defined</div></pre></td></tr></table></figure></p>
<p>后缀自加和自减一元操作符前不加空格：<br>[cc lang=”c”]<br>    ++  –<br>[/cc]<br>前缀自加和自减一元操作符后不加空格：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">++  --</div></pre></td></tr></table></figure></p>
<p>“<code>.</code>”和“<code>-&gt;</code>”结构体成员操作符前后不加空格。</p>
<p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后你<br>就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器就不<br>会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就这样产<br>生了。</p>
<p>当git发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白；不过<br>如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p>
<h2 id="第四章：命名"><a href="#第四章：命名" class="headerlink" title="第四章：命名"></a>第四章：命名</h2><p>C是一个简朴的语言，你的命名也应该这样。和Modula-2和Pascal程序员不同，C程序员不使<br>用类似ThisVariableIsATemporaryCounter这样华丽的名字。C程序员会称那个变量为“tmp”<br>，这样写起来会更容易，而且至少不会令其难于理解。</p>
<p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字<br>。称一个全局函数为“foo”是一个难以饶恕的错误。</p>
<p>全局变量（只有当你真正需要它们的时候再用它）需要有一个具描述性的名字，就像全局函<br>数。如果你有一个可以计算活动用户数量的函数，你应该叫它“<code>count_active_users()</code>”或者<br>类似的名字，你不应该叫它“<code>cntuser()</code>”。</p>
<p>在函数名中包含函数类型（所谓的匈牙利命名法）是脑子出了问题——编译器知道那些类型而<br>且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p>
<p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器<br>，它应该被称为“i”。叫它“<code>loop_counter</code>”并无益处，如果它没有被误解的可能的话。类似<br>的，“<code>tmp</code>”可以用来称呼任意类型的临时变量。</p>
<p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症<br>。请看第六章（函数）。</p>
<h2 id="第五章：Typedef"><a href="#第五章：Typedef" class="headerlink" title="第五章：Typedef"></a>第五章：Typedef</h2><p>不要使用类似“<code>vps_t</code>”之类的东西。</p>
<p>对结构体和指针使用<code>typedef</code>是一个错误。当你在代码里看到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vps_t</span> a;</div></pre></td></tr></table></figure></p>
<p>这代表什么意思呢？</p>
<p>相反，如果是这样<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> virtual_container *a;</div></pre></td></tr></table></figure></p>
<p>你就知道“<code>a</code>”是什么了。</p>
<p>很多人认为<code>typedef</code>“能提高可读性”。实际不是这样的。它们只在下列情况下有用：</p>
<p> (a) 完全不透明的对象（这种情况下要主动使用<code>typedef</code>来隐藏这个对象实际上是什么）。<br>     例如：“<code>pte_t</code>”等不透明对象，你只能用合适的访问函数来访问它们。<br>     注意！不透明性和“访问函数”本身是不好的。我们使用pte_t等类型的原因在于真的是<br>     完全没有任何共用的可访问信息。</p>
<p> (b) 清楚的整数类型，如此，这层抽象就可以帮助消除到底是“<code>int</code>”还是“<code>long</code>”的混淆。<br>     u8/u16/u32是完全没有问题的typedef，不过它们更符合类别(d)而不是这里。<br>     再次注意！要这样做，必须事出有因。如果某个变量是“<code>unsigned long</code>“，那么没有必要<br>     <code>typedef unsigned long myflags_t;</code><br>     不过如果有一个明确的原因，比如它在某种情况下可能会是一个“<code>unsigned int</code>”而在<br>     其他情况下可能为“<code>unsigned long</code>”，那么就不要犹豫，请务必使用<code>typedef</code>。</p>
<p> (c) 当你使用<code>sparse</code>按字面的创建一个新类型来做类型检查的时候。</p>
<p> (d) 和标准C99类型相同的类型，在某些例外的情况下。<br>     虽然让眼睛和脑筋来适应新的标准类型比如“<code>uint32_t</code>”不需要花很多时间，可是有些<br>     人仍然拒绝使用它们。<br>     因此，Linux特有的等同于标准类型的“u8/u16/u32/u64”类型和它们的有符号类型是被<br>     允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。<br>     当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p>
<p> (e) 可以在用户空间安全使用的类型。<br>     在某些用户空间可见的结构体里，我们不能要求C99类型而且不能用上面提到的“<code>u32</code>”<br>     类型。因此，我们在与用户空间共享的所有结构体中使用<code>__u32</code>和类似的类型。</p>
<p>可能还有其他的情况，不过基本的规则是永远不要使用<code>typedef</code>，除非你可以明确的应用上<br>述某个规则中的一个。</p>
<p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不<br>应该是一个<code>typedef</code>。</p>
<h2 id="第六章：函数"><a href="#第六章：函数" class="headerlink" title="第六章：函数"></a>第六章：函数</h2><p>函数应该简短而漂亮，并且只完成一件事情。函数应该可以一屏或者两屏显示完（我们都知<br>道ISO/ANSI屏幕大小是80x24），只做一件事情，而且把它做好。</p>
<p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上<br>很简单的只有一个很长（但是简单）的<code>case</code>语句的函数，而且你需要在每个<code>case</code>里做很多很<br>小的事情，这样的函数尽管很长，但也是可以的。</p>
<p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至<br>搞不清楚这个函数的目的，你应该严格的遵守前面提到的长度限制。使用辅助函数，并为之<br>取个具描述性的名字（如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的<br>效果往往会比你写一个复杂函数的效果要好。）</p>
<p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过5－10个，否则你的函数就有<br>问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟<br>踪7个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你2<br>个星期前做过的事情。</p>
<p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的<code>EXPORT*</code>宏应该紧贴<br>在它的结束大括号之下。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">system_is_up</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> system_state == SYSTEM_RUNNING;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL(system_is_up);</div></pre></td></tr></table></figure></p>
<p>在函数原型中，包含函数名和它们的数据类型。虽然C语言里没有这样的要求，在Linux里这<br>是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p>
<h2 id="第七章：集中的函数退出途径"><a href="#第七章：集中的函数退出途径" class="headerlink" title="第七章：集中的函数退出途径"></a>第七章：集中的函数退出途径</h2><p>虽然被某些人声称已经过时，但是<code>goto</code>语句的等价物还是经常被编译器所使用，具体形式是<br>无条件跳转指令。</p>
<p>当一个函数从多个位置退出并且需要做一些通用的清理工作的时候，<code>goto</code>的好处就显现出来<br>了。</p>
<p>理由是：</p>
<ul>
<li>无条件语句容易理解和跟踪</li>
<li>嵌套程度减小</li>
<li>可以避免由于修改时忘记更新某个单独的退出点而导致的错误</li>
<li>减轻了编译器的工作，无需删除冗余代码;)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">	<span class="keyword">char</span> *buffer = kmalloc(SIZE);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (buffer == <span class="literal">NULL</span>)</div><div class="line">		<span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (condition1) &#123;</div><div class="line">		<span class="keyword">while</span> (loop1) &#123;</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">		result = <span class="number">1</span>;</div><div class="line">		<span class="keyword">goto</span> out;</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">out:</div><div class="line">	kfree(buffer);</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="第八章：注释"><a href="#第八章：注释" class="headerlink" title="第八章：注释"></a>第八章：注释</h2><p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的：更好<br>的做法是让别人一看你的代码就可以明白，解释写的很差的代码是浪费时间。</p>
<p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释<br>放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到<br>第六章看一看。你可以做一些小注释来注明或警告某些很聪明（或者槽糕）的做法，但不要<br>加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么，也可以加上它做这<br>些事情的原因。</p>
<p>当注释内核API函数时，请使用kernel-doc格式。请看<br>Documentation/kernel-doc-nano-HOWTO.txt和scripts/kernel-doc以获得详细信息。</p>
<p>Linux的注释风格是C89“<code>/* ... */</code>”风格。不要使用C99风格“<code>// ...</code>”注释。</p>
<p>长（多行）的首选注释风格是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This is the preferred style for multi-line</div><div class="line"> * comments in the Linux kernel source code.</div><div class="line"> * Please use it consistently.</div><div class="line"> *</div><div class="line"> * Description:  A column of asterisks on the left side,</div><div class="line"> * with beginning and ending almost-blank lines.</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行应只<br>声明一个数据（不要使用逗号来一次声明多个数据）。这样你就有空间来为每个数据写一段<br>小注释来解释它们的用途了。</p>
<h2 id="第九章：你已经把事情弄糟了"><a href="#第九章：你已经把事情弄糟了" class="headerlink" title="第九章：你已经把事情弄糟了"></a>第九章：你已经把事情弄糟了</h2><p>这没什么，我们都是这样。可能你的使用了很长时间Unix的朋友已经告诉你“GNU emacs”能<br>自动帮你格式化C源代码，而且你也注意到了，确实是这样，不过它所使用的默认值和我们<br>想要的相去甚远（实际上，甚至比随机打的还要差——无数个猴子在GNU emacs里打字永远不<br>会创造出一个好程序）（译注：请参考Infinite Monkey Theorem）</p>
<p>所以你要么放弃GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案，你可<br>以把下面这段粘贴到你的.emacs文件里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(defun linux-c-mode ()</div><div class="line">  &quot;C mode with adjusted defaults for use with the Linux kernel.&quot;</div><div class="line">  (interactive)</div><div class="line">  (c-mode)</div><div class="line">  (c-set-style &quot;K&amp;R&quot;)</div><div class="line">  (setq tab-width 8)</div><div class="line">  (setq indent-tabs-mode t)</div><div class="line">  (setq c-basic-offset 8))</div></pre></td></tr></table></figure></p>
<p>这样就定义了M-x linux-c-mode命令。当你hack一个模块的时候，如果你把字符串<br>-<em>- linux-c -</em>-放在头两行的某个位置，这个模式将会被自动调用。如果你希望在你修改<br>/usr/src/linux里的文件时魔术般自动打开linux-c-mode的话，你也可能需要添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(setq auto-mode-alist (cons &apos;(&quot;/usr/src/linux.*/.*\\.[ch]$&quot; . linux-c-mode)</div><div class="line">			auto-mode-alist))</div></pre></td></tr></table></figure></p>
<p>到你的.emacs文件里。</p>
<p>不过就算你尝试让emacs正确的格式化代码失败了，也并不意味着你失去了一切：还可以用“<br>indent”。</p>
<p>不过，GNU indent也有和GNU emacs一样有问题的设定，所以你需要给它一些命令选项。不<br>过，这还不算太糟糕，因为就算是GNU indent的作者也认同K&amp;R的权威性（GNU的人并不是坏<br>人，他们只是在这个问题上被严重的误导了），所以你只要给indent指定选项“<code>-kr -i8</code>”<br>（代表“K&amp;R，8个字符缩进”），或者使用“scripts/Lindent”，这样就可以以最时髦的方式<br>缩进源代码。</p>
<p>“indent”有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册页。不过<br>记住：“indent”不能修正坏的编程习惯。</p>
<h2 id="第十章：Kconfig配置文件"><a href="#第十章：Kconfig配置文件" class="headerlink" title="第十章：Kconfig配置文件"></a>第十章：Kconfig配置文件</h2><p>对于遍布源码树的所有Kconfig*配置文件来说，它们缩进方式与C代码相比有所不同。紧挨<br>在“config”定义下面的行缩进一个制表符，帮助信息则再多缩进2个空格。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">config AUDIT</div><div class="line">	bool &quot;Auditing support&quot;</div><div class="line">	depends on NET</div><div class="line">	help</div><div class="line">	  Enable auditing infrastructure that can be used with another</div><div class="line">	  kernel subsystem, such as SELinux (which requires this for</div><div class="line">	  logging of avc messages output).  Does not do system-call</div><div class="line">	  auditing without CONFIG_AUDITSYSCALL.</div></pre></td></tr></table></figure></p>
<p>而那些危险的功能（比如某些文件系统的写支持）应该在它们的提示字符串里显著的声明这<br>一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">config ADFS_FS_RW</div><div class="line">	bool &quot;ADFS write support (DANGEROUS)&quot;</div><div class="line">	depends on ADFS_FS</div><div class="line">	...</div></pre></td></tr></table></figure></p>
<p>要查看配置文件的完整文档，请看Documentation/kbuild/kconfig-language.txt。</p>
<h2 id="第十一章：数据结构"><a href="#第十一章：数据结构" class="headerlink" title="第十一章：数据结构"></a>第十一章：数据结构</h2><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计<br>数器。内核里没有垃圾收集（并且内核之外的垃圾收集慢且效率低下），这意味着你绝对需<br>要记录你对这种数据结构的使用情况。</p>
<p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心<br>这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一<br>些其他事情而已。</p>
<p>注意上锁不能取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管<br>理技巧。通常二者都需要，不要把两个搞混了。</p>
<p>很多数据结构实际上有2级引用计数，它们通常有不同“类”的用户。子类计数器统计子类用<br>户的数量，每当子类计数器减至零时，全局计数器减一。</p>
<p>这种“多级引用计数”的例子可以在内存管理（“<code>struct mm_struct</code>”：<code>mm_users</code>和<code>mm_count</code>）<br>和文件系统（“<code>struct super_block</code>”：<code>s_count</code>和<code>s_active</code>）中找到。</p>
<p>记住：如果另一个执行线索可以找到你的数据结构，但是这个数据结构没有引用计数器，这<br>里几乎肯定是一个bug。</p>
<h2 id="第十二章：宏，枚举和RTL"><a href="#第十二章：宏，枚举和RTL" class="headerlink" title="第十二章：宏，枚举和RTL"></a>第十二章：宏，枚举和RTL</h2><p>用于定义常量的宏的名字及枚举里的标签需要大写。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANT 0x12345</span></div></pre></td></tr></table></figure></p>
<p>在定义几个相关的常量时，最好用枚举。</p>
<p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p>
<p>一般的，如果能写成内联函数就不要写成像函数的宏。</p>
<p>含有多个语句的宏应该被包含在一个do-while代码块里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> macrofun(a, b, c) 			\</span></div><div class="line">	do &#123;					\</div><div class="line">		<span class="meta-keyword">if</span> (a == 5)			\</div><div class="line">			do_this(b, c);		\</div><div class="line">	&#125; while (0)</div></pre></td></tr></table></figure></p>
<p>使用宏的时候应避免的事情：</p>
<p>1) 影响控制流程的宏：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define FOO(x)					\</div><div class="line">	do &#123;					\</div><div class="line">		if (blah(x) &lt; 0)		\</div><div class="line">			return -EBUGGERED;	\</div><div class="line">	&#125; while(0)</div></pre></td></tr></table></figure></p>
<p>非常不好。它看起来像一个函数，不过却能导致“调用”它的函数退出；不要打乱读者大脑里<br>的语法分析器。</p>
<p>2) 依赖于一个固定名字的本地变量的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO(val) bar(index, val)</span></div></pre></td></tr></table></figure></p>
<p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来<br>不相关的改动带来错误。</p>
<p>3) 作为左值的带参数的宏：<code>FOO(x) = y；</code>如果有人把FOO变成一个内联函数的话，这种用<br>法就会出错了。</p>
<p>4) 忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数的<br>宏也要注意此类问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTANT 0x4000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CONSTEXP (CONSTANT | 3)</span></div></pre></td></tr></table></figure></p>
<p>cpp手册对宏的讲解很详细。Gcc internals手册也详细讲解了RTL（译注：register<br>transfer language），内核里的汇编语言经常用到它。</p>
<h2 id="第十三章：打印内核消息"><a href="#第十三章：打印内核消息" class="headerlink" title="第十三章：打印内核消息"></a>第十三章：打印内核消息</h2><p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。不要<br>用不规范的单词比如“dont”，而要用“do not”或者“don’t”。保证这些信息简单、明了、无<br>歧义。</p>
<p>内核信息不必以句号（译注：英文句号，即点）结束。</p>
<p>在小括号里打印数字(<code>%d</code>)没有任何价值，应该避免这样做。</p>
<p><linux device.h="">里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的<br>设备和驱动，并且被标记了正确的消息级别。这些宏有：<code>dev_err()</code>,<code>dev_warn()</code>,<br><code>dev_info()</code>等等。对于那些不和某个特定设备相关连的信息，<linux kernel.h="">定义了<br><code>pr_debug()</code>和<code>pr_info()</code>。</linux></linux></p>
<p>写出好的调试信息可以是一个很大的挑战；当你写出来之后，这些信息在远程除错的时候<br>就会成为极大的帮助。当DEBUG符号没有被定义的时候，这些信息不应该被编译进内核里<br>（也就是说，默认地，它们不应该被包含在内）。如果你使用<code>dev_dbg()</code>或者<code>pr_debug()</code>，<br>就能自动达到这个效果。很多子系统拥有Kconfig选项来启用-DDEBUG。还有一个相关的惯例<br>是使用<code>VERBOSE_DEBUG</code>来添加<code>dev_vdbg()</code>消息到那些已经由DEBUG启用的消息之上。</p>
<h2 id="第十四章：分配内存"><a href="#第十四章：分配内存" class="headerlink" title="第十四章：分配内存"></a>第十四章：分配内存</h2><p>内核提供了下面的一般用途的内存分配函数：<code>kmalloc()</code>，<code>kzalloc()</code>，<code>kcalloc()</code>和<br><code>vmalloc()</code>。请参考API文档以获取有关它们的详细信息。</p>
<p>传递结构体大小的首选形式是这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = kmalloc(<span class="keyword">sizeof</span>(*p), ...);</div></pre></td></tr></table></figure></p>
<p>另外一种传递方式中，<code>sizeof</code>的操作数是结构体的名字，这样会降低可读性，并且可能会引<br>入bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的<code>sizeof</code>的结果不变。</p>
<p>强制转换一个<code>void</code>指针返回值是多余的。C语言本身保证了从<code>void</code>指针到其他任何指针类型<br>的转换是没有问题的。</p>
<h2 id="第十五章：内联弊病"><a href="#第十五章：内联弊病" class="headerlink" title="第十五章：内联弊病"></a>第十五章：内联弊病</h2><p>有一个常见的误解是内联函数是gcc提供的可以让代码运行更快的一个选项。虽然使用内联<br>函数有时候是恰当的（比如作为一种替代宏的方式，请看第十二章），不过很多情况下不是<br>这样。<code>inline</code>关键字的过度使用会使内核变大，从而使整个系统运行速度变慢。因为大内核<br>会占用更多的指令高速缓存（译注：一级缓存通常是指令缓存和数据缓存分开的）而且会导<br>致pagecache的可用内存减少。想象一下，一次pagecache未命中就会导致一次磁盘寻址，将<br>耗时5毫秒。5毫秒的时间内CPU能执行很多很多指令。</p>
<p>一个基本的原则是如果一个函数有3行以上，就不要把它变成内联函数。这个原则的一个例<br>外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能<br>优化掉你的函数的大部分代码，那仍然可以给它加上<code>inline</code>关键字。<code>kmalloc()</code>内联函数就<br>是一个很好的例子。</p>
<p>人们经常主张给<code>static</code>的而且只用了一次的函数加上<code>inline</code>，如此不会有任何损失，因为没<br>有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加<code>inline</code> gcc<br>也可以自动使其内联。而且其他用户可能会要求移除<code>inline</code>，由此而来的争论会抵消<code>inline</code><br>自身的潜在价值，得不偿失。</p>
<h2 id="第十六章：函数返回值及命名"><a href="#第十六章：函数返回值及命名" class="headerlink" title="第十六章：函数返回值及命名"></a>第十六章：函数返回值及命名</h2><p>函数可以返回很多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样<br>的一个值可以表示为一个错误代码整数（-Exxx＝失败，0＝成功）或者一个“成功”布尔值（<br>0＝失败，非0＝成功）。</p>
<p>混合使用这两种表达方式是难于发现的bug的来源。如果C语言本身严格区分整形和布尔型变<br>量，那么编译器就能够帮我们发现这些错误……不过C语言不区分。为了避免产生这种bug，请<br>遵循下面的惯例：</p>
<blockquote>
<p>如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代码整<br>数。如果是一个判断，那么函数应该返回一个“成功”布尔值。</p>
</blockquote>
<p>比如，“<code>add work</code>”是一个命令，所以<code>add_work()</code>函数在成功时返回0，在失败时返回<code>-EBUSY</code>。<br>类似的，因为“<code>PCI device present</code>”是一个判断，所以<code>pci_dev_present()</code>函数在成功找到<br>一个匹配的设备时应该返回1，如果找不到时应该返回0。</p>
<p>所有导出（译注：EXPORT）的函数都必须遵守这个惯例，所有的公共函数也都应该如此。私<br>有（static）函数不需要如此，但是我们也推荐这样做。</p>
<p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的，他们<br>通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数，他们使用<br><code>NULL</code>或者<code>ERR_PTR</code>机制来报告错误。</p>
<h2 id="第十七章：不要重新发明内核宏"><a href="#第十七章：不要重新发明内核宏" class="headerlink" title="第十七章：不要重新发明内核宏"></a>第十七章：不要重新发明内核宏</h2><p>头文件include/linux/kernel.h包含了一些宏，你应该使用它们，而不要自己写一些它们的<br>变种。比如，如果你需要计算一个数组的长度，使用这个宏<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</span></div><div class="line">``</div><div class="line">类似的，如果你要计算某结构体成员的大小，使用</div><div class="line">```c</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span></div></pre></td></tr></table></figure></p>
<p>还有可以做严格的类型检查的<code>min()</code>和<code>max()</code>宏，如果你需要可以使用它们。你可以自己看看<br>那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里<br>自己重新定义。</p>
<h2 id="第十八章：编辑器模式行和其他需要罗嗦的事情"><a href="#第十八章：编辑器模式行和其他需要罗嗦的事情" class="headerlink" title="第十八章：编辑器模式行和其他需要罗嗦的事情"></a>第十八章：编辑器模式行和其他需要罗嗦的事情</h2><p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs<br>能够解释被标记成这样的行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-*- mode: c -*-</div></pre></td></tr></table></figure></p>
<p>或者这样的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">Local Variables:</div><div class="line">compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"</div><div class="line">End:</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>Vim能够解释这样的标记：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/* vim:set sw=8 noet */</div></pre></td></tr></table></figure></p>
<p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应<br>该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模<br>式，或者使用其他可以产生正确的缩进的巧妙方法。</p>
<h2 id="附录-I：参考"><a href="#附录-I：参考" class="headerlink" title="附录 I：参考"></a>附录 I：参考</h2><p>The C Programming Language, 第二版, 作者Brian W. Kernighan和Denni<br>M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮),<br>0-13-110370-9 (硬皮). URL: <a href="http://cm.bell-labs.com/cm/cs/cbook/" target="_blank" rel="external">http://cm.bell-labs.com/cm/cs/cbook/</a></p>
<p>The Practice of Programming 作者Brian W. Kernighan和Rob Pike.  Addison-Wesley,<br>Inc., 1999.  ISBN 0-201-61586-X.  URL: <a href="http://cm.bell-labs.com/cm/cs/tpop/" target="_blank" rel="external">http://cm.bell-labs.com/cm/cs/tpop/</a></p>
<p>cpp，gcc，gcc internals和indent的GNU手册——和K&amp;R及本文相符合的部分，全部可以在<br><a href="http://www.gnu.org/manual/" target="_blank" rel="external">http://www.gnu.org/manual/</a> 找到</p>
<p>WG14是C语言的国际标准化工作组，URL: <a href="http://www.open-std.org/JTC1/SC22/WG14/" target="_blank" rel="external">http://www.open-std.org/JTC1/SC22/WG14/</a></p>
<p>Kernel CodingStyle，作者greg@kroah.com发表于OLS 2002：<br><a href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/" target="_blank" rel="external">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p>
<p>–<br>最后更新于2007年7月13日。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[serio总线]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/serio-bus/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.chinaunix.net/uid-20543183-id-1930815.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930815.html</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>serio总线同之前分析的platform总线一样，也是一种虚拟总线。它是Serial I/O的缩写，表示串行的输入输出设备，很多输入输出设备都是以此为基础的。同前面几篇笔记一样，下面的代码分析是基于linux kernel 2.6.25版本。<br><a id="more"></a></p>
<h3 id="serio总线的初始化"><a href="#serio总线的初始化" class="headerlink" title="serio总线的初始化"></a>serio总线的初始化</h3><p>serio总线的初始化是在<code>linux2.6.25/drivers/input/serio/serio.c</code>中完成的。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">serio_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     error = bus_register(&amp;serio_bus);</div><div class="line">     <span class="keyword">if</span> (error) &#123;</div><div class="line">         printk(KERN_ERR <span class="string">"serio: failed to register serio bus, error: %d\n"</span>, error);</div><div class="line">         <span class="keyword">return</span> error;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     serio_task = kthread_run(serio_thread, <span class="literal">NULL</span>, <span class="string">"kseriod"</span>);</div><div class="line">     <span class="keyword">if</span> (IS_ERR(serio_task)) &#123;</div><div class="line">         bus_unregister(&amp;serio_bus);</div><div class="line">         error = PTR_ERR(serio_task);</div><div class="line"></div><div class="line">         printk(KERN_ERR <span class="string">"serio: Failed to start kseriod, error: %d\n"</span>, error);</div><div class="line">         <span class="keyword">return</span> error;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，创建了对应<code>bus_type</code>为<code>serio_bus</code>的总线，还创建了一个名为“<code>kseriod</code>”的内核线程。我们暂且不管它是做什么的，等以后的代码涉及到再来进行分析。</p>
<h3 id="serio设备注册"><a href="#serio设备注册" class="headerlink" title="serio设备注册"></a>serio设备注册</h3><p>serio设备对应的数据结构为<code>struct serio</code>, 对应的注册接口为：<code>serio_register_port()</code>。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">serio_register_port</span><span class="params">(<span class="keyword">struct</span> serio *serio)</span></span></div><div class="line">&#123;</div><div class="line">     __serio_register_port(serio, THIS_MODULE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它是<code>__serio_register_port()</code>的一个封装函数。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __serio_register_port(<span class="keyword">struct</span> serio *serio, <span class="keyword">struct</span> <span class="keyword">module</span> *owner)</div><div class="line">&#123;</div><div class="line">     serio_init_port(serio);</div><div class="line">     serio_queue_event(serio, owner, SERIO_REGISTER_PORT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它先初始化一个serio设备，在<code>serio_init_port()</code>中，它指定了设备的总线类型为<code>serio_bus</code>。之后，调用<code>serio_queue_event()</code>。看这个函数的名称好像是产生了什么事件，来看一下它的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_queue_event</span><span class="params">(<span class="keyword">void</span> *object, <span class="keyword">struct</span> <span class="keyword">module</span> *owner,</span></span></div><div class="line">                   <span class="keyword">enum</span> serio_event_type event_type)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">     <span class="keyword">struct</span> serio_event *event;</div><div class="line">     <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">     spin_lock_irqsave(&amp;serio_event_lock, flags);</div><div class="line"></div><div class="line">     <span class="comment">/*</span></div><div class="line">      * Scan event list for the other events for the same serio port,</div><div class="line">      * starting with the most recent one. If event is the same we</div><div class="line">      * do not need add new one. If event is of different type we</div><div class="line">      * need to add this event and should not look further because</div><div class="line">      * we need to preseve sequence of distinct events.</div><div class="line">      */</div><div class="line"></div><div class="line">     list_for_each_entry_reverse(event, &amp;serio_event_list, node) &#123;</div><div class="line">         <span class="keyword">if</span> (event-&gt;object == object) &#123;</div><div class="line">              <span class="keyword">if</span> (event-&gt;type == event_type)</div><div class="line">                   <span class="keyword">goto</span> out;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     event = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> serio_event), GFP_ATOMIC);</div><div class="line">     <span class="keyword">if</span> (!event) &#123;</div><div class="line">         printk(KERN_ERR</div><div class="line">              <span class="string">"serio: Not enough memory to queue event %d\n"</span>,</div><div class="line">              event_type);</div><div class="line">         retval = -ENOMEM;</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!try_module_get(owner)) &#123;</div><div class="line">         printk(KERN_WARNING</div><div class="line">              <span class="string">"serio: Can't get module reference, dropping event %d\n"</span>,</div><div class="line">              event_type);</div><div class="line">         kfree(event);</div><div class="line">         retval = -EINVAL;</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     event-&gt;type = event_type;</div><div class="line">     event-&gt;object = object;</div><div class="line">     event-&gt;owner = owner;</div><div class="line"></div><div class="line">     list_add_tail(&amp;event-&gt;node, &amp;serio_event_list);</div><div class="line">     wake_up(&amp;serio_wait);</div><div class="line">out:</div><div class="line">     spin_unlock_irqrestore(&amp;serio_event_lock, flags);</div><div class="line">     <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数比较简单，就是根据参数信息生成了一个<code>struct serio_event</code>结构，再将此结构链接至<code>serio_event_list</code>末尾。</p>
<p>接着就要来寻找<code>serio_event_list</code>这个链表的处理。这个就是<code>serio_thread</code>的工作了，还记得初始化的时候所创建的线程么，不错，就是它。Kernel可能认为对serio的操作比较频繁，所以对一些操作事件化，将它以多线程处理。<br><code>serio_thread()</code>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_thread</span><span class="params">(<span class="keyword">void</span> *nothing)</span></span></div><div class="line">&#123;</div><div class="line">     set_freezable();</div><div class="line">     <span class="keyword">do</span> &#123;</div><div class="line">         serio_handle_event();</div><div class="line">         wait_event_freezable(serio_wait,</div><div class="line">              kthread_should_stop() || !list_empty(&amp;serio_event_list));</div><div class="line">     &#125; <span class="keyword">while</span> (!kthread_should_stop());</div><div class="line"></div><div class="line">     printk(KERN_DEBUG <span class="string">"serio: kseriod exiting\n"</span>);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的核心处理是<code>serio_handle_event()</code>, 代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serio_handle_event</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> serio_event *event;</div><div class="line">     mutex_lock(&amp;serio_mutex);</div><div class="line"></div><div class="line">     <span class="comment">/*</span></div><div class="line">      * Note that we handle only one event here to give swsusp</div><div class="line">      * a chance to freeze kseriod thread. Serio events should</div><div class="line">      * be pretty rare so we are not concerned about taking</div><div class="line">      * performance hit.</div><div class="line">      */</div><div class="line">     <span class="keyword">if</span> ((event = serio_get_event())) &#123;</div><div class="line">         <span class="keyword">switch</span> (event-&gt;type) &#123;</div><div class="line">              <span class="keyword">case</span> SERIO_REGISTER_PORT:</div><div class="line">                   serio_add_port(event-&gt;object);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">case</span> SERIO_RECONNECT_PORT:</div><div class="line">                   serio_reconnect_port(event-&gt;object);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">case</span> SERIO_RESCAN_PORT:</div><div class="line">                   serio_disconnect_port(event-&gt;object);</div><div class="line">                   serio_find_driver(event-&gt;object);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">case</span> SERIO_ATTACH_DRIVER:</div><div class="line">                   serio_attach_driver(event-&gt;object);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">              <span class="keyword">default</span>:</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         serio_remove_duplicate_events(event);</div><div class="line">         serio_free_event(event);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     mutex_unlock(&amp;serio_mutex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数的流程大致是这样的：<br>调用<code>serio_get_event()</code>从链表中取出<code>struct serio_event</code>元素，然后对这个元素的事件类型做不同的处理，处理完了之后，调用<code>serio_remove_duplicate_events()</code>在链表中删除相同请求的<code>event</code>.<br>对应之前的<code>serio_register_port()</code>函数，它产生的事件类型是<code>SERIO_REGISTER_PORT</code>。也就是说，对于注册serio设备来说，流程会转入<code>serio_add_port()</code>。<br>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serio_add_port</span><span class="params">(<span class="keyword">struct</span> serio *serio)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (serio-&gt;parent) &#123;</div><div class="line">         serio_pause_rx(serio-&gt;parent);</div><div class="line">         serio-&gt;parent-&gt;child = serio;</div><div class="line">         serio_continue_rx(serio-&gt;parent);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     list_add_tail(&amp;serio-&gt;node, &amp;serio_list);</div><div class="line">     <span class="keyword">if</span> (serio-&gt;start)</div><div class="line">         serio-&gt;start(serio);</div><div class="line">     error = device_add(&amp;serio-&gt;dev);</div><div class="line">     <span class="keyword">if</span> (error)</div><div class="line">         printk(KERN_ERR</div><div class="line">              <span class="string">"serio: device_add() failed for %s (%s), error: %d\n"</span>,</div><div class="line">              serio-&gt;phys, serio-&gt;name, error);</div><div class="line">     <span class="keyword">else</span> &#123;</div><div class="line">         serio-&gt;registered = <span class="number">1</span>;</div><div class="line"></div><div class="line">         error = sysfs_create_group(&amp;serio-&gt;dev.kobj, &amp;serio_id_attr_group);</div><div class="line">         <span class="keyword">if</span> (error)</div><div class="line">              printk(KERN_ERR</div><div class="line">                   <span class="string">"serio: sysfs_create_group() failed for %s (%s), error: %d\n"</span>,</div><div class="line">                   serio-&gt;phys, serio-&gt;name, error);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们终于看到serio device注册的庐山真面目了，它会调用设备的<code>start()</code>函数，然后调用<code>device_add()</code>将设备注册到总线上。</p>
<p>同platform总线一样，这里的serio device注册的时候也会产生一个hotplug事件，对应就会调用总线的<code>uenvent</code>函数，<code>serio_bus</code>的<code>event</code>接口为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_uevent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> serio *serio;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!dev)</div><div class="line">         <span class="keyword">return</span> -ENODEV;</div><div class="line"></div><div class="line">     serio = to_serio_port(dev);</div><div class="line"></div><div class="line">     SERIO_ADD_UEVENT_VAR(<span class="string">"SERIO_TYPE=%02x"</span>, serio-&gt;id.type);</div><div class="line">     SERIO_ADD_UEVENT_VAR(<span class="string">"SERIO_PROTO=%02x"</span>, serio-&gt;id.proto);</div><div class="line">     SERIO_ADD_UEVENT_VAR(<span class="string">"SERIO_ID=%02x"</span>, serio-&gt;id.id);</div><div class="line">     SERIO_ADD_UEVENT_VAR(<span class="string">"SERIO_EXTRA=%02x"</span>, serio-&gt;id.extra);</div><div class="line">     SERIO_ADD_UEVENT_VAR(<span class="string">"MODALIAS=serio:ty%02Xpr%02Xid%02Xex%02X"</span>,</div><div class="line">                   serio-&gt;id.type, serio-&gt;id.proto, serio-&gt;id.id, serio-&gt;id.extra);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见, 会在hotplug的环境变量中添加几项值。记得我们之前分析设备驱动模型的时候，在总线下面的设备都有一个属性文件，这个文件的内容就是对应<code>bus</code>和<code>kset</code>所添加的环境变量。在<code>/sys</code>文件系统中就可以看到这此环境变量。做个测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@localhost serio0]<span class="comment"># cat /sys/bus/serio/devices/serio0/uevent</span></div><div class="line">DRIVER=atkbd</div><div class="line">PHYSDEVBUS=serio</div><div class="line">PHYSDEVDRIVER=atkbd</div><div class="line">SERIO_TYPE=06</div><div class="line">SERIO_PROTO=00</div><div class="line">SERIO_ID=00</div><div class="line">SERIO_EXTRA=00</div><div class="line">MODALIAS=serio:ty06pr00id00ex00</div></pre></td></tr></table></figure></p>
<h3 id="serio-driver的注册"><a href="#serio-driver的注册" class="headerlink" title="serio driver的注册"></a>serio driver的注册</h3><p>对应serio driver注册的接口<code>serio_register_driver()</code>。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">serio_register_driver</span><span class="params">(<span class="keyword">struct</span> serio_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> __serio_register_driver(drv, THIS_MODULE, KBUILD_MODNAME);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它是<code>__serio_register_driver()</code>的封装函数，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __serio_register_driver(<span class="keyword">struct</span> serio_driver *drv, <span class="keyword">struct</span> <span class="keyword">module</span> *owner, <span class="keyword">const</span> <span class="keyword">char</span> *mod_name)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> manual_bind = drv-&gt;manual_bind;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     drv-&gt;driver.bus = &amp;serio_bus;</div><div class="line">     drv-&gt;driver.owner = owner;</div><div class="line">     drv-&gt;driver.mod_name = mod_name;</div><div class="line"></div><div class="line">     <span class="comment">/*</span></div><div class="line">      * Temporarily disable automatic binding because probing</div><div class="line">      * takes long time and we are better off doing it in kseriod</div><div class="line">      */</div><div class="line">     drv-&gt;manual_bind = <span class="number">1</span>;</div><div class="line"></div><div class="line">     error = driver_register(&amp;drv-&gt;driver);</div><div class="line">     <span class="keyword">if</span> (error) &#123;</div><div class="line">         printk(KERN_ERR</div><div class="line">              <span class="string">"serio: driver_register() failed for %s, error: %d\n"</span>,</div><div class="line">              drv-&gt;driver.name, error);</div><div class="line">         <span class="keyword">return</span> error;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">/*</span></div><div class="line">      * Restore original bind mode and let kseriod bind the</div><div class="line">      * driver to free ports</div><div class="line">      */</div><div class="line">     <span class="keyword">if</span> (!manual_bind) &#123;</div><div class="line">         drv-&gt;manual_bind = <span class="number">0</span>;</div><div class="line"></div><div class="line">         error = serio_queue_event(drv, <span class="literal">NULL</span>, SERIO_ATTACH_DRIVER);</div><div class="line">         <span class="keyword">if</span> (error) &#123;</div><div class="line">              driver_unregister(&amp;drv-&gt;driver);</div><div class="line">              <span class="keyword">return</span> error;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段代码比较简单，在注册驱动的时候，将驱动的总线指定为<code>serio_bus</code>，然后调用<code>driver_register()</code>将驱动注册到总线。如果<code>drv-&gt;manual_bind</code>不为<code>1</code>，还会产生一个<code>SERIO_ATTACH_DRIVER</code>事件。<code>drv-&gt;manual_bind</code>成员的含义应该是要手动进行驱动与设备的绑定。</p>
<p>在注册驱动的时候，会产生一次驱动与设备的匹配过程，这过程会调用<code>bus-&gt;match --&gt; bus-&gt;probe</code>，看下serio总线是怎么样处理的。<br><code>serio_bus.match</code>的函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_bus_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> serio *serio = to_serio_port(dev);</div><div class="line">     <span class="keyword">struct</span> serio_driver *serio_drv = to_serio_driver(drv);</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (serio-&gt;manual_bind || serio_drv-&gt;manual_bind)</div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> serio_match_port(serio_drv-&gt;id_table, serio);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果驱动或者设备指定了手动绑定，那么这次绑定是不成功的，否则调用<code>serio_match_port()</code>进行更细致的判断。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_match_port</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> serio_device_id *ids, <span class="keyword">struct</span> serio *serio)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">while</span> (ids-&gt;type || ids-&gt;proto) &#123;</div><div class="line">         <span class="keyword">if</span> ((ids-&gt;type == SERIO_ANY || ids-&gt;type == serio-&gt;id.type) &amp;&amp;</div><div class="line">             (ids-&gt;proto == SERIO_ANY || ids-&gt;proto == serio-&gt;id.proto) &amp;&amp;</div><div class="line">             (ids-&gt;extra == SERIO_ANY || ids-&gt;extra == serio-&gt;id.extra) &amp;&amp;</div><div class="line">             (ids-&gt;id == SERIO_ANY || ids-&gt;id == serio-&gt;id.id))</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">         ids++;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此看出，只有serio device信息与serio driver的<code>id_table</code>中的信息匹配的时候，才会将设备和驱动绑定起来。</p>
<p><code>serio_bus.probe</code>的接口函数如下示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_driver_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> serio *serio = to_serio_port(dev);</div><div class="line">     <span class="keyword">struct</span> serio_driver *drv = to_serio_driver(dev-&gt;driver);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> serio_connect_driver(serio, drv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">serio_connect_driver</span><span class="params">(<span class="keyword">struct</span> serio *serio, <span class="keyword">struct</span> serio_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">     mutex_lock(&amp;serio-&gt;drv_mutex);</div><div class="line">     retval = drv-&gt;connect(serio, drv);</div><div class="line">     mutex_unlock(&amp;serio-&gt;drv_mutex);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即会调用设备驱动的<code>connect()</code>函数。</p>
<p>在注册serio driver的时候，还会产生<code>SERIO_ATTACH_DRIVER</code>事件，这个事件的处理是在<code>serio_handle_event()</code>中完成的。相应的处理接口为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serio_attach_driver</span><span class="params">(<span class="keyword">struct</span> serio_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     error = driver_attach(&amp;drv-&gt;driver);</div><div class="line">     <span class="keyword">if</span> (error)</div><div class="line">         printk(KERN_WARNING</div><div class="line">              <span class="string">"serio: driver_attach() failed for %s with error %d\n"</span>,</div><div class="line">              drv-&gt;driver.name, error);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，这里也是执行一次设备与驱动的匹配过程。</p>
<h3 id="serio-的中断处理函数分析"><a href="#serio-的中断处理函数分析" class="headerlink" title="serio 的中断处理函数分析"></a>serio 的中断处理函数分析</h3><p><code>serio_interrupt()</code>在serio bus构造的驱动也是一个常用的接口，这个接口用来处理serio 设备的中断。我们来看下它的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">irqreturn_t</span> serio_interrupt(<span class="keyword">struct</span> serio *serio,</div><div class="line">                   <span class="keyword">unsigned</span> <span class="keyword">char</span> data, <span class="keyword">unsigned</span> <span class="keyword">int</span> dfl)</div><div class="line">&#123;</div><div class="line">         <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">         <span class="keyword">irqreturn_t</span> ret = IRQ_NONE;</div><div class="line"></div><div class="line">         spin_lock_irqsave(&amp;serio-&gt;lock, flags);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (likely(serio-&gt;drv)) &#123;</div><div class="line">                ret = serio-&gt;drv-&gt;interrupt(serio, data, dfl);</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dfl &amp;&amp; serio-&gt;registered) &#123;</div><div class="line">                   serio_rescan(serio);</div><div class="line">                   ret = IRQ_HANDLED;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         spin_unlock_irqrestore(&amp;serio-&gt;lock, flags);</div><div class="line">         <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，先判断当前设备是否已经关联到了驱动程序。如果已经被关联了，那么调用驱动的中断处理函数。如果没有，就会转入<code>serio_rescan()</code>中执行。该函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">serio_rescan</span><span class="params">(<span class="keyword">struct</span> serio *serio)</span></span></div><div class="line">&#123;</div><div class="line">         serio_queue_event(serio, <span class="literal">NULL</span>, SERIO_RESCAN_PORT);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见，它是执行了一个<code>SERIO_RESCAN_PORT</code>动作。同样，这个动作是在<code>serio_handle_event()</code>中处理的。相应的处理接口为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> SERIO_RESCAN_PORT:</div><div class="line">        serio_disconnect_port(event-&gt;object);</div><div class="line">        serio_find_driver(event-&gt;object);</div><div class="line">        <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p>首先调用<code>serio_disconnect_port()</code>解除serio设备与驱动绑定，然后调用<code>serio_find_driver()</code>重新执行一次设备与驱动的匹配过程。<br><code>serio_find_driver()</code> 代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serio_find_driver</span><span class="params">(<span class="keyword">struct</span> serio *serio)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> error;</div><div class="line"></div><div class="line">	error = device_attach(&amp;serio-&gt;dev);</div><div class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</div><div class="line">		printk(KERN_WARNING</div><div class="line">			<span class="string">"serio: device_attach() failed for %s (%s), error: %d\n"</span>,</div><div class="line">			serio-&gt;phys, serio-&gt;name, error);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果有合适的驱动，就会将之与设备关联起来。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>来小结一下，在serio总线中，注册一个serio设备时，除了将其注册到所属的<code>serio_bus</code>上，还会调用设备的<code>start()</code>函数。在中断处理的时候，如果serio设备已经关联到驱动，则调用驱动的<code>interrupt</code>函数。如果没有关联，则重新匹配驱动并将其注册到总线。<br>总的说来，serio 总线的代码很简单。到这里，我们已经分析过platform, serio两种虚拟总线，应该结合这两个虚拟总线的例子好好体会一下结构封装的技巧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[platform总线]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/platform-bus/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.chinaunix.net/uid-20543183-id-1930814.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930814.html</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>platform</code>总线是kernel中最近加入的一种虚拟总线.在近版的2.6kernel中,很多驱动都用<code>platform</code>改写了.只有在分析完<code>platform</code>总线之后,才能继续深入下去分析.在分析完<code>sysfs</code>和设备驱动模型之后,这部份应该很简单了.闲言少叙.步入正题.GO.GO!以下的源代码分析是基于2.6.25的.<br><a id="more"></a></p>
<h2 id="platform概貌"><a href="#platform概貌" class="headerlink" title="platform概貌"></a>platform概貌</h2><p>在分析源代码之前,先在内核代码中找一个<code>platform</code>架构的驱动程序.下面以<code>i8042</code>芯片的驱动为例进行分析.<br>在<code>linux-2.6.25/drivers/input/serio/i8042.c</code>的<code>intel 8042</code>的初始化入口中,有以下代码分段:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i8042_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">     ……</div><div class="line"></div><div class="line">  err = platform_driver_register(&amp;i8042_driver);</div><div class="line">  <span class="keyword">if</span> (err)</div><div class="line">       <span class="keyword">goto</span> err_platform_exit;</div><div class="line"></div><div class="line">  i8042_platform_device = platform_device_alloc(<span class="string">"i8042"</span>, <span class="number">-1</span>);</div><div class="line">     <span class="keyword">if</span> (!i8042_platform_device) &#123;</div><div class="line">         err = -ENOMEM;</div><div class="line">         <span class="keyword">goto</span> err_unregister_driver;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     err = platform_device_add(i8042_platform_device);</div><div class="line">     <span class="keyword">if</span> (err)</div><div class="line">         <span class="keyword">goto</span> err_free_device;</div><div class="line">     ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在上面的程序片段中看到,驱动程序先注册了一个<code>platform driver</code>,然后又添加了一个<code>platform device</code>.这里就涉及到了<code>platform</code>的两个最主要的操作：一个设备驱动注册，一个设备注册。</p>
<p>要了解<code>platform</code>总线的来龙去脉.得从它的初始化开始.</p>
<h2 id="platform初始化"><a href="#platform初始化" class="headerlink" title="platform初始化"></a>platform初始化</h2><p><code>platform</code>总线的初始化是在<code>linux-2.6.25/drivers/base/platform.c</code>中的<code>platform_bus_init()</code>完成的,代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">platform_bus_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     error = device_register(&amp;platform_bus);</div><div class="line">     <span class="keyword">if</span> (error)</div><div class="line">         <span class="keyword">return</span> error;</div><div class="line"></div><div class="line">     error =  bus_register(&amp;platform_bus_type);</div><div class="line">     <span class="keyword">if</span> (error)</div><div class="line">         device_unregister(&amp;platform_bus);</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中调用的子函数在<a href="/kernel/设备驱动/probe-of-linux-kernel-driver-module/" title="linux设备模型深探">linux设备模型深探</a>中已经分析过了。这段初始化代码创建了一个名为 “<code>platform</code>”的设备，后续<code>platform</code>的设备都会以此为<code>parent</code>。在<code>sysfs</code>中表示为：所有<code>platform</code>类型的设备都会添加在<code>platform_bus</code>所代表的目录下，即 <code>/sys/devices/platform</code> 下面.<br>接着,这段初始化代码又创建了一个名为“<code>platform</code>”的总线.<br><code>platform_bus_type</code>的定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> bus_type platform_bus_type = &#123;</div><div class="line">     .name         = <span class="string">"platform"</span>,</div><div class="line">     .dev_attrs    = platform_dev_attrs,</div><div class="line">     .match        = platform_match,</div><div class="line">     .uevent       = platform_uevent,</div><div class="line">     .suspend      = platform_suspend,</div><div class="line">     .suspend_late = platform_suspend_late,</div><div class="line">     .resume_early = platform_resume_early,</div><div class="line">     .resume       = platform_resume,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们知道，在<code>bus_type</code>中包含了诸如设备与驱动匹配，<code>hotplug</code>事件等很多重要的操作。这些操作在分析<code>platform</code>设备注册与<code>platform</code>驱动注册的时候依次分析。</p>
<h2 id="platform-device注册"><a href="#platform-device注册" class="headerlink" title="platform device注册"></a>platform device注册</h2><p>在<code>intel 8042</code>的驱动代码中,我们看到注册一个<code>platform device</code>分为了两部分,一部份是创建一个<code>platform device</code>结构,另一部份是将其注册到总线中.先来看第一个接口.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> platform_device *<span class="title">platform_device_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> id)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> platform_object *pa;</div><div class="line"></div><div class="line">     pa = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> platform_object) + <span class="built_in">strlen</span>(name), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (pa) &#123;</div><div class="line">         <span class="built_in">strcpy</span>(pa-&gt;name, name);</div><div class="line">         pa-&gt;pdev.name = pa-&gt;name;</div><div class="line">         pa-&gt;pdev.id = id;</div><div class="line">         device_initialize(&amp;pa-&gt;pdev.dev);</div><div class="line"></div><div class="line">         pa-&gt;pdev.dev.release = platform_device_release;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> pa ? &amp;pa-&gt;pdev : <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码主要初始化了封装在<code>struct platform_object</code>中的<code>struct device</code>.</p>
<p><code>struct platform_object</code>结构定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_object &#123;</div><div class="line">     <span class="keyword">struct</span> platform_device pdev;</div><div class="line">     <span class="keyword">char</span> name[<span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在定义中,定义<code>name</code>长度为<code>1</code>,所以,才有了<code>platform_device_alloc()</code>中分配<code>struct platform_object</code>的时候多加了名称的长度:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pa = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> platform_object) + <span class="built_in">strlen</span>(name), GFP_KERNEL);</div></pre></td></tr></table></figure></p>
<p><code>struct device</code>结构如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_device &#123;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span>    * name;</div><div class="line">     <span class="keyword">int</span>      id;</div><div class="line">     <span class="keyword">struct</span> device dev;</div><div class="line">     u32      num_resources;</div><div class="line">     <span class="keyword">struct</span> resource    * resource;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这个结构里封装了<code>struct device</code>、<code>struct resource</code>，<code>struct resource</code>这个结构在此之前没有接触过,这个结构表示设备所拥有的资源，即I/O端口或者是I/O映射内存。</p>
<p><code>platform_device_add()</code>代码分段分析如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_device_add</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> i, ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!pdev)</div><div class="line">         <span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!pdev-&gt;dev.parent)</div><div class="line">         pdev-&gt;dev.parent = &amp;platform_bus;</div><div class="line"></div><div class="line">     pdev-&gt;dev.bus = &amp;platform_bus_type;</div></pre></td></tr></table></figure></p>
<p>初始化设备的<code>parent</code>为<code>platform_bus</code>, 初始化驱备的总线为<code>platform_bus_type</code>. 回忆<code>platform</code>初始化的时候, 这两个东东这里终于派上用场了.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (pdev-&gt;id != <span class="number">-1</span>)</div><div class="line">    <span class="built_in">snprintf</span>(pdev-&gt;dev.bus_id, BUS_ID_SIZE, <span class="string">"%s.%d"</span>, pdev-&gt;name,</div><div class="line">          pdev-&gt;id);</div><div class="line"><span class="keyword">else</span></div><div class="line">    strlcpy(pdev-&gt;dev.bus_id, pdev-&gt;name, BUS_ID_SIZE);</div></pre></td></tr></table></figure></p>
<p>设置设备<code>struct device</code>的<code>bus_id</code>成员, 留心这个地方, 在以后还需要用到这个的.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pdev-&gt;num_resources; i++) &#123;</div><div class="line">    <span class="keyword">struct</span> resource *p, *r = &amp;pdev-&gt;resource[i];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (r-&gt;name == <span class="literal">NULL</span>)</div><div class="line">         r-&gt;name = pdev-&gt;dev.bus_id;</div><div class="line"></div><div class="line">    p = r-&gt;parent;</div><div class="line">    <span class="keyword">if</span> (!p) &#123;</div><div class="line">         <span class="keyword">if</span> (r-&gt;flags &amp; IORESOURCE_MEM)</div><div class="line">              p = &amp;iomem_resource;</div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;flags &amp; IORESOURCE_IO)</div><div class="line">              p = &amp;ioport_resource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (p &amp;&amp; insert_resource(p, r)) &#123;</div><div class="line">         printk(KERN_ERR</div><div class="line">                <span class="string">"%s: failed to claim resource %d\n"</span>,</div><div class="line">                pdev-&gt;dev.bus_id, i);</div><div class="line">         ret = -EBUSY;</div><div class="line">         <span class="keyword">goto</span> failed;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果设备指定了它所拥有的资源, 将这些资源分配给它. 如果分配失败, 则失败退出. 从代码中可以看出, 如果<code>struct resource</code>的<code>flags</code>域被指定为<code>IORESOURCE_MEM</code>, 则所表示的资源为I/O映射内存; 如果指定为<code>IORESOURCE_IO</code>, 则所表示的资源为I/O端口.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">     pr_debug(<span class="string">"Registering platform device '%s'. Parent at %s\n"</span>,</div><div class="line">          pdev-&gt;dev.bus_id, pdev-&gt;dev.parent-&gt;bus_id);</div><div class="line"></div><div class="line">     ret = device_add(&amp;pdev-&gt;dev);</div><div class="line">     <span class="keyword">if</span> (ret == <span class="number">0</span>)</div><div class="line">         <span class="keyword">return</span> ret;</div><div class="line"></div><div class="line"> failed:</div><div class="line">     <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</div><div class="line">         <span class="keyword">if</span> (pdev-&gt;resource[i].flags &amp; (IORESOURCE_MEM|IORESOURCE_IO))</div><div class="line">              release_resource(&amp;pdev-&gt;resource[i]);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>device_add()</code>已经很熟悉了吧, 没错, 它就是将设备注册到指定的<code>bus_type</code>.</p>
<p>在分析linux设备模型的时候, 曾说过, 调用<code>device_add()</code>会产生一个<code>hotplug</code>事件. <code>platform device</code>的<code>hotplug</code>与一般的<code>device</code>事件相比, 它还要它所属<code>bus_type</code>的<code>uevent()</code>.对这个流程不熟悉的可以参照<a href="/kernel/设备驱动/probe-of-linux-kernel-driver-module/" title="linux设备模型深探">linux设备模型深探</a>. <code>platform device</code>所属的<code>bus_type</code>为<code>platform_bus_type</code>, 它的<code>uevent()</code>接口代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_uevent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> platform_device *pdev = to_platform_device(dev);</div><div class="line"></div><div class="line">     add_uevent_var(env, <span class="string">"MODALIAS=platform:%s"</span>, pdev-&gt;name);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码很简单,它就是在环境变量中添加一项<code>MODALIAS</code>.</p>
<h2 id="platform-driver的注册"><a href="#platform-driver的注册" class="headerlink" title="platform driver的注册"></a>platform driver的注册</h2><p>在<code>intel 8024</code>的驱动代码中看到，<code>platform driver</code>注册的接口为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_driver_register</span><span class="params">(<span class="keyword">struct</span> platform_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     drv-&gt;driver.bus = &amp;platform_bus_type;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;probe)</div><div class="line">         drv-&gt;driver.probe = platform_drv_probe;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;remove)</div><div class="line">         drv-&gt;driver.remove = platform_drv_remove;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;shutdown)</div><div class="line">         drv-&gt;driver.shutdown = platform_drv_shutdown;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;suspend)</div><div class="line">         drv-&gt;driver.suspend = platform_drv_suspend;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;resume)</div><div class="line">         drv-&gt;driver.resume = platform_drv_resume;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> driver_register(&amp;drv-&gt;driver);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>struct platform_driver</code>主要封装了<code>struct device_driver</code>结构, 如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_driver &#123;</div><div class="line">     <span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</div><div class="line">     <span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</div><div class="line">     <span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</div><div class="line">     <span class="keyword">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="keyword">pm_message_t</span> state);</div><div class="line">     <span class="keyword">int</span> (*suspend_late)(<span class="keyword">struct</span> platform_device *, <span class="keyword">pm_message_t</span> state);</div><div class="line">     <span class="keyword">int</span> (*resume_early)(<span class="keyword">struct</span> platform_device *);</div><div class="line">     <span class="keyword">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</div><div class="line">     <span class="keyword">struct</span> device_driver driver;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这个接口里, 它指定<code>platform driver</code>的所属总线. 如果在<code>struct platform_driver</code>指定了各项接口的操作, 就会为<code>struct device_driver</code>中的相应接口赋值.</p>
<p>不要被上面的<code>platform_drv_XXX</code>吓倒了, 它们其实很简单, 就是将<code>struct device</code>转换为<code>struct platform_device</code>和<code>struct platform_driver</code>, 然后调用<code>platform_driver</code>中的相应接口函数.</p>
<p>最后, <code>platform_driver_register()</code>将驱动注册到总线上.<br>这样, 总线上有设备, 又有驱动, 就会进行设备与驱动匹配的过程, 调用的相应接口为：<br><code>bus -&gt;match --- &gt; bus-&gt;probe/driver-&gt;probe</code> (如果总线的<code>probe</code>操作不存在,就会调用设备的<code>probe</code>接口)。<br>这样，我们又回到<code>platform_bus_type</code>中的各项操作了。<br>对应的<code>match</code>接口如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> platform_device *pdev;</div><div class="line"></div><div class="line">     pdev = container_of(dev, <span class="keyword">struct</span> platform_device, dev);</div><div class="line">     <span class="keyword">return</span> (<span class="built_in">strncmp</span>(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中看出，如果要匹配成功，那么设备与驱动的名称必须要一致。</p>
<p><code>platform_bus_type</code> 中没有指定<code>probe</code>接口，所以，会转至驱动的<code>probe</code>接口。在<code>platform_driver_register()</code>中，将其<code>probe</code>接口指定为了<code>platform_drv_probe</code>，这个函数又会将操作回溯到<code>struct platform_driver</code>的<code>probe</code>接口中。</p>
<p>到这里，<code>platform driver</code>的注册过程就会析完了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本小节里，我们以linux设备模型为基础，分析虚拟总线<code>platform</code>的架构，对其<code>hotplug</code>事件，以及设备与驱动的匹配过程做了非常详细的分析，这部份知识是我们深入理解具体设备驱动的基础.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux文件系统之sysfs]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/linux-sysfs/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.chinaunix.net/uid-20543183-id-1930812.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930812.html</a></p>
<p>源码文件：<br><code>./fs/sysfs/</code></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在设备模型中，sysfs文件系统用来表示设备的结构，将设备的层次结构形象的反应到用户空间中。用户空间可以修改sysfs中的文件属性来修改设备的属性值，今天我们就来详细分析一下sysfs的实现。<br><a id="more"></a></p>
<h2 id="sysfs的初始化和挂载"><a href="#sysfs的初始化和挂载" class="headerlink" title="sysfs的初始化和挂载"></a>sysfs的初始化和挂载</h2><p>sysfs文件系统的初始化是在<code>sysfs_init()</code>中完成的,代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">sysfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">int</span> err = -ENOMEM;</div><div class="line">       <span class="comment">//创建一个分配sysfs_dirent的cache</span></div><div class="line">       sysfs_dir_cachep = kmem_cache_create(<span class="string">"sysfs_dir_cache"</span>,</div><div class="line">                                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sysfs_dirent),</div><div class="line">                                         <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">       <span class="keyword">if</span> (!sysfs_dir_cachep)</div><div class="line">              <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">       err = sysfs_inode_init();</div><div class="line">       <span class="keyword">if</span> (err)</div><div class="line">              <span class="keyword">goto</span> out_err;</div><div class="line">       <span class="comment">//注册sysfs文件系统s</span></div><div class="line">       err = register_filesystem(&amp;sysfs_fs_type);</div><div class="line">       <span class="keyword">if</span> (!err) &#123;</div><div class="line">              <span class="comment">//挂载sysfs文件系统</span></div><div class="line">              sysfs_mount = kern_mount(&amp;sysfs_fs_type);</div><div class="line">              <span class="keyword">if</span> (IS_ERR(sysfs_mount)) &#123;</div><div class="line">                     printk(KERN_ERR <span class="string">"sysfs: could not mount!\n"</span>);</div><div class="line">                     err = PTR_ERR(sysfs_mount);</div><div class="line">                     sysfs_mount = <span class="literal">NULL</span>;</div><div class="line">                     unregister_filesystem(&amp;sysfs_fs_type);</div><div class="line">                     <span class="keyword">goto</span> out_err;</div><div class="line">              &#125;</div><div class="line">       &#125; <span class="keyword">else</span></div><div class="line">              <span class="keyword">goto</span> out_err;</div><div class="line">out:</div><div class="line">       <span class="keyword">return</span> err;</div><div class="line">out_err:</div><div class="line">       kmem_cache_destroy(sysfs_dir_cachep);</div><div class="line">       sysfs_dir_cachep = <span class="literal">NULL</span>;</div><div class="line">       <span class="keyword">goto</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个<code>kobject</code>对应sysfs中的一个目录，<code>kobject</code>的每个属性对应sysfs文件系统中的文件。<br><code>struct sysfs_dirent</code>就是用来做<code>kobject</code>与<code>dentry</code>的互相转换用的，它们的关系如下图所示:<br><img src="/kernel/内核文件系统/linux-sysfs/sysfs.jpg" alt="sysfs.jpg" title=""><br>上图表示的是一个<code>kobject</code>的层次结构，<code>dentry</code>的<code>d_fsdata</code>字段指定该结点所表示的<code>sysfs_dirent</code>，<code>sysfs_dirent.s_parent</code>表示它的父<code>kobject</code>，<code>sysfs_dirent</code>.<code>s_sibling</code>表示它的兄弟结点，<code>sysfs_dirent.s_dir.children</code>表示它所属的子节点。</p>
<p>从上图可知，如果要遍历一个结点下面的子结点，只需要找到<code>sysfs_dirent.s_dir.children</code>结点，然后按着子节点的<code>s_sibling</code>域遍历即可。当然，有时候也需要从<code>struct sysfs_dirent</code>导出它所属的<code>dentry</code>结点，我们在代码中遇到的时候再进行分析。<br>sysfs文件系统的<code>file_system_type</code>定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> file_system_type sysfs_fs_type = &#123;</div><div class="line">       .name       = <span class="string">"sysfs"</span>,</div><div class="line">       .get_sb     = sysfs_get_sb,</div><div class="line">       .kill_sb    = kill_anon_super,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过前面文件系统的相关分析,我们知道在<code>sys_mount()</code>中最终会调用<code>struct file_system_type</code>的<code>get_sb</code>函数来实现文件系统的挂载.它的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sysfs_get_sb</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type,</span></span></div><div class="line">       <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *dev_name, <span class="keyword">void</span> *data, <span class="keyword">struct</span> vfsmount *mnt)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">return</span> get_sb_single(fs_type, flags, data, sysfs_fill_super, mnt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>get_sb_single()</code>的代码在前面已经涉及到,它对<code>super_block</code>以及挂载的<code>dentry</code>和<code>inode</code>的赋值是在回调函数<code>sysfs_fill_super</code>、<code>mnt</code>中完成的.代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sysfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> inode *inode;</div><div class="line">       <span class="keyword">struct</span> dentry *root;</div><div class="line"></div><div class="line">       sb-&gt;s_blocksize = PAGE_CACHE_SIZE;</div><div class="line">       sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;</div><div class="line">       sb-&gt;s_magic = SYSFS_MAGIC;</div><div class="line">       sb-&gt;s_op = &amp;sysfs_ops;</div><div class="line">       sb-&gt;s_time_gran = <span class="number">1</span>;</div><div class="line">       sysfs_sb = sb;</div><div class="line"></div><div class="line">       <span class="comment">/* get root inode, initialize and unlock it */</span></div><div class="line">       inode = sysfs_get_inode(&amp;sysfs_root);</div><div class="line">       <span class="keyword">if</span> (!inode) &#123;</div><div class="line">              pr_debug(<span class="string">"sysfs: could not get root inode\n"</span>);</div><div class="line">              <span class="keyword">return</span> -ENOMEM;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* instantiate and link root dentry */</span></div><div class="line">       root = d_alloc_root(inode);</div><div class="line">       <span class="keyword">if</span> (!root) &#123;</div><div class="line">              pr_debug(<span class="string">"%s: could not get root dentry!\n"</span>,__FUNCTION__);</div><div class="line">              iput(inode);</div><div class="line">              <span class="keyword">return</span> -ENOMEM;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//将sysfs_root关联到root</span></div><div class="line">       root-&gt;d_fsdata = &amp;sysfs_root;</div><div class="line">       sb-&gt;s_root = root;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里要注意几个全局量. <code>sysfs_sb</code>表示sysfs文件系统的<code>super_block</code>，<code>sysfs_root</code>表示sysfs文件系统根目录的<code>struct sysfs_dirent</code>。<code>sysfs_get_inode(&amp;sysfs_root)</code>用来将<code>sysfs_root</code>导出相应的<code>inode</code>，代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> inode * <span class="title">sysfs_get_inode</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *sd)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> inode *inode;</div><div class="line">       <span class="comment">//以super_block和sd-&gt;s_ino为哈希值,到哈希表中寻找相应的inode.如果不存在,则新建</span></div><div class="line">       inode = iget_locked(sysfs_sb, sd-&gt;s_ino);</div><div class="line">       <span class="comment">//对新生成的inode进行初始化</span></div><div class="line">       <span class="keyword">if</span> (inode &amp;&amp; (inode-&gt;i_state &amp; I_NEW))</div><div class="line">              sysfs_init_inode(sd, inode);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> inode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先,它以sysfs文件系统的<code>super_block</code>和<code>struct sysfs_dirent</code>的<code>s_ino</code>成员的值做为哈希值到哈希表中寻找相应的<code>inode</code>。如果在哈希表中不存在这个<code>inode</code>,那就新建一个,并将它链入到哈希表.之后,调用<code>sysfs_init_inode()</code>对生成的<code>inode</code>进行初始化.显然.在mount的时候是不会生成<code>inode</code>的.必定会进入<code>sysfs_init_inode()</code>函数.代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysfs_init_inode</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *sd, <span class="keyword">struct</span> inode *inode)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> bin_attribute *bin_attr;</div><div class="line"></div><div class="line">       inode-&gt;i_blocks = <span class="number">0</span>;</div><div class="line">       inode-&gt;i_mapping-&gt;a_ops = &amp;sysfs_aops;</div><div class="line">       inode-&gt;i_mapping-&gt;backing_dev_info = &amp;sysfs_backing_dev_info;</div><div class="line">       inode-&gt;i_op = &amp;sysfs_inode_operations;</div><div class="line">       inode-&gt;i_ino = sd-&gt;s_ino;</div><div class="line">       lockdep_set_class(&amp;inode-&gt;i_mutex, &amp;sysfs_inode_imutex_key);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (sd-&gt;s_iattr) &#123;</div><div class="line">              <span class="comment">/* sysfs_dirent has non-default attributes</span></div><div class="line">               * get them for the new inode from persistent copy</div><div class="line">               * in sysfs_dirent</div><div class="line">               */</div><div class="line">              set_inode_attr(inode, sd-&gt;s_iattr);</div><div class="line">       &#125; <span class="keyword">else</span></div><div class="line">              set_default_inode_attr(inode, sd-&gt;s_mode);</div><div class="line"></div><div class="line">       <span class="comment">/* initialize inode according to type */</span></div><div class="line">       <span class="keyword">switch</span> (sysfs_type(sd)) &#123;</div><div class="line">       <span class="keyword">case</span> SYSFS_DIR:</div><div class="line">              inode-&gt;i_op = &amp;sysfs_dir_inode_operations;</div><div class="line">              inode-&gt;i_fop = &amp;sysfs_dir_operations;</div><div class="line">              inode-&gt;i_nlink = sysfs_count_nlink(sd);</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> SYSFS_KOBJ_ATTR:</div><div class="line">              inode-&gt;i_size = PAGE_SIZE;</div><div class="line">              inode-&gt;i_fop = &amp;sysfs_file_operations;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> SYSFS_KOBJ_BIN_ATTR:</div><div class="line">              bin_attr = sd-&gt;s_bin_attr.bin_attr;</div><div class="line">              inode-&gt;i_size = bin_attr-&gt;size;</div><div class="line">              inode-&gt;i_fop = &amp;bin_fops;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> SYSFS_KOBJ_LINK:</div><div class="line">              inode-&gt;i_op = &amp;sysfs_symlink_inode_operations;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">              BUG();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       unlock_new_inode(inode);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里,我们可以看到sysfs文件系统中的各种操作函数了..</p>
<p>在syfs文件系统中,怎么样判断一个目录下是否有这个文件呢?<br>在前面有关文件系统的分析中我们可以看.有关文件的查找实际上都会由<code>inod-&gt;i_op-&gt;lookup()</code>函数进行判断.在sysfs中,这个函数对应为<code>sysfs_lookup()</code>.代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> dentry * <span class="title">sysfs_lookup</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry,</span></span></div><div class="line">                            <span class="keyword">struct</span> nameidata *nd)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> dentry *ret = <span class="literal">NULL</span>;</div><div class="line">       <span class="comment">//取得父结点对应的sysfs_dirent</span></div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *parent_sd = dentry-&gt;d_parent-&gt;d_fsdata;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *sd;</div><div class="line">       <span class="keyword">struct</span> inode *inode;</div><div class="line"></div><div class="line">       mutex_lock(&amp;sysfs_mutex);</div><div class="line">       <span class="comment">//父结点的sysfs_dirent中是否有相应的子结点</span></div><div class="line">       sd = sysfs_find_dirent(parent_sd, dentry-&gt;d_name.name);</div><div class="line"></div><div class="line">       <span class="comment">/* no such entry */</span></div><div class="line">       <span class="comment">//如果没有.这个结点是不存在的</span></div><div class="line">       <span class="keyword">if</span> (!sd) &#123;</div><div class="line">              ret = ERR_PTR(-ENOENT);</div><div class="line">              <span class="keyword">goto</span> out_unlock;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* attach dentry and inode */</span></div><div class="line">       <span class="comment">//如果有这个结点,为之生成inod结构.</span></div><div class="line">       inode = sysfs_get_inode(sd);</div><div class="line">       <span class="keyword">if</span> (!inode) &#123;</div><div class="line">              ret = ERR_PTR(-ENOMEM);</div><div class="line">              <span class="keyword">goto</span> out_unlock;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* instantiate and hash dentry */</span></div><div class="line">       dentry-&gt;d_op = &amp;sysfs_dentry_ops;</div><div class="line">       <span class="comment">//关联dentry与sysfs_dirent</span></div><div class="line">       dentry-&gt;d_fsdata = sysfs_get(sd);</div><div class="line">       d_instantiate(dentry, inode);</div><div class="line">       d_rehash(dentry);</div><div class="line"></div><div class="line"> out_unlock:</div><div class="line">       mutex_unlock(&amp;sysfs_mutex);</div><div class="line">       <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见,它的判断会转入到相应的<code>sysfs_dirent</code>中进行判断.如果设备模型在创建目录/文件的时候并不会创建<code>dentry</code>或者<code>inode</code>.只会操作<code>sysfs_dirent</code>结构. 如果找到了这个结构,就为这个结构生成<code>inode</code>,并将其关联到<code>denry</code>中.<br><code>sysfs_find_dirent()</code>如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> sysfs_dirent *<span class="title">sysfs_find_dirent</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *parent_sd,</span></span></div><div class="line">                                   <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *sd;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (sd = parent_sd-&gt;s_dir.children; sd; sd = sd-&gt;s_sibling)</div><div class="line">              <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sd-&gt;s_name, name))</div><div class="line">                     <span class="keyword">return</span> sd;</div><div class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它用的搜索方法就是我们在之前分析<code>sysfs_dirent</code>结构所讲述的.分析到这里,sysfs的大概轮廓就出现在我们的眼前了.^_^.接下来分析sysfs文件系统中目录的创建过程</p>
<h2 id="在sysfs文件系统中创建目录"><a href="#在sysfs文件系统中创建目录" class="headerlink" title="在sysfs文件系统中创建目录"></a>在sysfs文件系统中创建目录</h2><p>在linux设备模型中,每注册一个<code>kobject</code>.就会为之创建一个目录.具体的流程在分析linux设备模型的时候再给出详细的分析.创建目录的接口为: <code>sysfs_create_dir()</code>。代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_dir</span><span class="params">(<span class="keyword">struct</span> kobject * kobj)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *parent_sd, *sd;</div><div class="line">       <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line"></div><div class="line">       BUG_ON(!kobj);</div><div class="line"></div><div class="line">       <span class="comment">//如果kobject没有指定父结点,则将其父结点指定为sysfs的根目录syfs_root</span></div><div class="line">       <span class="keyword">if</span> (kobj-&gt;parent)</div><div class="line">              parent_sd = kobj-&gt;parent-&gt;sd;</div><div class="line">       <span class="keyword">else</span></div><div class="line">              parent_sd = &amp;sysfs_root;</div><div class="line"></div><div class="line">       <span class="comment">//创建目录</span></div><div class="line">       error = create_dir(kobj, parent_sd, kobject_name(kobj), &amp;sd);</div><div class="line">       <span class="comment">//kobj-&gt;sd 指向对应的sysfs_dirent</span></div><div class="line">       <span class="keyword">if</span> (!error)</div><div class="line">              kobj-&gt;sd = sd;</div><div class="line">       <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里,先为结点指定父目录,然后调用<code>create_dir()</code>在父目录下生成结点.代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_dir</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> sysfs_dirent *parent_sd,</span></span></div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">struct</span> sysfs_dirent **p_sd)</div><div class="line">&#123;</div><div class="line">       <span class="comment">//指定目录的模式</span></div><div class="line">       <span class="keyword">umode_t</span> mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO;</div><div class="line">       <span class="keyword">struct</span> sysfs_addrm_cxt acxt;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *sd;</div><div class="line">       <span class="keyword">int</span> rc;</div><div class="line"></div><div class="line">       <span class="comment">/* allocate */</span></div><div class="line">       <span class="comment">//分配并初始化一个sysfs_dirent</span></div><div class="line">       sd = sysfs_new_dirent(name, mode, SYSFS_DIR);</div><div class="line">       <span class="keyword">if</span> (!sd)</div><div class="line">              <span class="keyword">return</span> -ENOMEM;</div><div class="line">       <span class="comment">//初始化sd-&gt;s_dir.kobj字段</span></div><div class="line">       sd-&gt;s_dir.kobj = kobj;</div><div class="line"></div><div class="line">       <span class="comment">/* link in */</span></div><div class="line">       <span class="comment">//acxt是一个临时变量.它用来存放父结点的相关信息</span></div><div class="line"></div><div class="line">       <span class="comment">//设置acxt-&gt;parent_sd为父结点的sysfs_dirent, acxt-&gt;parent_inode为父结点的inode</span></div><div class="line">       sysfs_addrm_start(&amp;acxt, parent_sd);</div><div class="line">       <span class="comment">//设置sd-&gt;s_parent.并按inod值按顺序链入父结点的children链表</span></div><div class="line">       rc = sysfs_add_one(&amp;acxt, sd);</div><div class="line">       sysfs_addrm_finish(&amp;acxt);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (rc == <span class="number">0</span>)</div><div class="line">              *p_sd = sd;</div><div class="line">       <span class="keyword">else</span></div><div class="line">              sysfs_put(sd);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里,为子节点生成了对应的<code>sysfs_dirent</code>.设置了它的父结点域,并将其链入到父结点的<code>children</code>链表.这样,在文件系统中查找父目录下面的子结点了.</p>
<h2 id="在sysfs中创建一般属性文件"><a href="#在sysfs中创建一般属性文件" class="headerlink" title="在sysfs中创建一般属性文件"></a>在sysfs中创建一般属性文件</h2><p><code>kobject</code>的每一项属性都对应在sysfs文件系统中<code>kobject</code>对应的目录下的一个文件，文件名称与属性名称相同。<br>创建一般属性的接口为<code>sysfs_create_file()</code>，代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="keyword">const</span> <span class="keyword">struct</span> attribute * attr)</span></span></div><div class="line">&#123;</div><div class="line">       BUG_ON(!kobj || !kobj-&gt;sd || !attr);</div><div class="line"></div><div class="line">       <span class="comment">//kobject-&gt;sd: 为kobject表示目录的struct sysfs_dirent结构</span></div><div class="line">       <span class="keyword">return</span> sysfs_add_file(kobj-&gt;sd, attr, SYSFS_KOBJ_ATTR);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终会调用<code>sysfs_add_file()</code>, 参数<code>attr</code>是要生成文件的属性值.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_add_file</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *dir_sd, <span class="keyword">const</span> <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                 <span class="keyword">int</span> type)</div><div class="line">&#123;</div><div class="line">       <span class="comment">//文件对应的属性</span></div><div class="line">       <span class="keyword">umode_t</span> mode = (attr-&gt;mode &amp; S_IALLUGO) | S_IFREG;</div><div class="line">       <span class="keyword">struct</span> sysfs_addrm_cxt acxt;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *sd;</div><div class="line">       <span class="keyword">int</span> rc;</div><div class="line"></div><div class="line">       <span class="comment">//创建一个新的sysfs_dirent.对应的名称为attr-&gt;name.即属性的名称</span></div><div class="line">       sd = sysfs_new_dirent(attr-&gt;name, mode, type);</div><div class="line">       <span class="keyword">if</span> (!sd)</div><div class="line">              <span class="keyword">return</span> -ENOMEM;</div><div class="line">       <span class="comment">//设置属性值</span></div><div class="line">       sd-&gt;s_attr.attr = (<span class="keyword">void</span> *)attr;</div><div class="line"></div><div class="line">       <span class="comment">//将子结点的struct sysfs_dirent结构关链到父结点</span></div><div class="line">       sysfs_addrm_start(&amp;acxt, dir_sd);</div><div class="line">       rc = sysfs_add_one(&amp;acxt, sd);</div><div class="line">       sysfs_addrm_finish(&amp;acxt);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (rc)</div><div class="line">              sysfs_put(sd);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个流程与创建目录的流程大部份相同.不相同的只是创建目录时,它的父目录为上一层结点,创建文件时,它的父目录就是<code>kobject</code>对应的<code>struct sysfs_dirent</code>.<br>这样,在<code>kobject</code>对应的目录下面就可以看到这个文件了.^_^</p>
<p>文件建好之后,要怎么样去读写呢? 回忆一下,在sysfs文件系统中,<code>inode</code>的初始化:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sysfs_init_inode</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *sd, <span class="keyword">struct</span> inode *inode)</span></span></div><div class="line">&#123;</div><div class="line">       ……</div><div class="line">       …….</div><div class="line">       <span class="keyword">case</span> SYSFS_KOBJ_ATTR:</div><div class="line">       inode-&gt;i_size = PAGE_SIZE;</div><div class="line">       inode-&gt;i_fop = &amp;sysfs_file_operations;</div><div class="line">       ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sysfs_file_operations</code>的定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> file_operations sysfs_file_operations = &#123;</div><div class="line">       .read       = sysfs_read_file,</div><div class="line">       .write      = sysfs_write_file,</div><div class="line">       .llseek     = generic_file_llseek,</div><div class="line">       .open       = sysfs_open_file,</div><div class="line">       .release    = sysfs_release,</div><div class="line">       .poll       = sysfs_poll,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>文件的操作全部都在这里了,我们从打开文件说起.<br><code>sysfs_open_file()</code>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sysfs_open_file</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *attr_sd = file-&gt;f_path.dentry-&gt;d_fsdata;</div><div class="line">       <span class="keyword">struct</span> kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj;</div><div class="line">       <span class="keyword">struct</span> sysfs_buffer *buffer;</div><div class="line">       <span class="keyword">struct</span> sysfs_ops *ops;</div><div class="line">       <span class="keyword">int</span> error = -EACCES;</div><div class="line"></div><div class="line">       <span class="comment">/* need attr_sd for attr and ops, its parent for kobj */</span></div><div class="line">       <span class="keyword">if</span> (!sysfs_get_active_two(attr_sd))</div><div class="line">              <span class="keyword">return</span> -ENODEV;</div><div class="line"></div><div class="line">       <span class="comment">/* every kobject with an attribute needs a ktype assigned */</span></div><div class="line">       <span class="comment">//将buffer-&gt;ops设置为kobj-&gt;ktype-&gt;sysfs_ops</span></div><div class="line">       <span class="keyword">if</span> (kobj-&gt;ktype &amp;&amp; kobj-&gt;ktype-&gt;sysfs_ops)</div><div class="line">              ops = kobj-&gt;ktype-&gt;sysfs_ops;</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">              printk(KERN_ERR <span class="string">"missing sysfs attribute operations for "</span></div><div class="line">                     <span class="string">"kobject: %s\n"</span>, kobject_name(kobj));</div><div class="line">              WARN_ON(<span class="number">1</span>);</div><div class="line">              <span class="keyword">goto</span> err_out;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* File needs write support.</span></div><div class="line">        * The inode's perms must say it's ok,</div><div class="line">        * and we must have a store method.</div><div class="line">        */</div><div class="line">       <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_WRITE) &#123;</div><div class="line">              <span class="keyword">if</span> (!(inode-&gt;i_mode &amp; S_IWUGO) || !ops-&gt;store)</div><div class="line">                     <span class="keyword">goto</span> err_out;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* File needs read support.</span></div><div class="line">        * The inode's perms must say it's ok, and we there</div><div class="line">        * must be a show method for it.</div><div class="line">        */</div><div class="line">       <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ) &#123;</div><div class="line">              <span class="keyword">if</span> (!(inode-&gt;i_mode &amp; S_IRUGO) || !ops-&gt;show)</div><div class="line">                     <span class="keyword">goto</span> err_out;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* No error? Great, allocate a buffer for the file, and store it</span></div><div class="line">        * it in file-&gt;private_data for easy access.</div><div class="line">        */</div><div class="line">       error = -ENOMEM;</div><div class="line">       buffer = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sysfs_buffer), GFP_KERNEL);</div><div class="line">       <span class="keyword">if</span> (!buffer)</div><div class="line">              <span class="keyword">goto</span> err_out;</div><div class="line"></div><div class="line">       mutex_init(&amp;buffer-&gt;mutex);</div><div class="line">       buffer-&gt;needs_read_fill = <span class="number">1</span>;</div><div class="line">       buffer-&gt;ops = ops;</div><div class="line">       file-&gt;private_data = buffer;</div><div class="line"></div><div class="line">       <span class="comment">/* make sure we have open dirent struct */</span></div><div class="line">       <span class="comment">//将buffer链至attr_sd-&gt;s_attr.open链表上</span></div><div class="line">       error = sysfs_get_open_dirent(attr_sd, buffer);</div><div class="line">       <span class="keyword">if</span> (error)</div><div class="line">              <span class="keyword">goto</span> err_free;</div><div class="line"></div><div class="line">       <span class="comment">/* open succeeded, put active references */</span></div><div class="line">       sysfs_put_active_two(attr_sd);</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"> err_free:</div><div class="line">       kfree(buffer);</div><div class="line"> err_out:</div><div class="line">       sysfs_put_active_two(attr_sd);</div><div class="line">       <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中,需要注意以下几个操作,<br>1、<code>buffer</code>链接在<code>file-&gt;private_data</code>，<code>buffer</code>还被链接在<code>sysfs_dirent-&gt;s_attr.open</code>，这样，VFS通过<code>file</code>，设备模型通过<code>kobject-&gt;sd-&gt;s_attr.open</code>都能找到这个要操作的 <code>buffer</code>。<br>2、<code>buffer-&gt;ops</code>被设置为了<code>kobject-&gt;ktype-&gt;sysfs_ops</code>。</p>
<p>文件的写操作入口如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t</span></div><div class="line"><span class="title">sysfs_write_file</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_buffer * buffer = file-&gt;private_data;</div><div class="line">       <span class="keyword">ssize_t</span> len;</div><div class="line"></div><div class="line">       mutex_lock(&amp;buffer-&gt;mutex);</div><div class="line">       <span class="comment">//将buf中的内容copy到了buffer-&gt;page</span></div><div class="line">       len = fill_write_buffer(buffer, buf, count);</div><div class="line">       <span class="comment">//与设备模型的交互</span></div><div class="line">       <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">              len = flush_write_buffer(file-&gt;f_path.dentry, buffer, len);</div><div class="line">       <span class="comment">//更新ppos</span></div><div class="line">       <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</div><div class="line">              *ppos += len;</div><div class="line">       mutex_unlock(&amp;buffer-&gt;mutex);</div><div class="line">       <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，调用<code>fill_write_buffer()</code>将用户空间传值下来的数值copy到<code>buffer-&gt;page</code>，然后再调用<code>flush_write_buffer()</code>与设备模型进行交互。<br><code>flush_wirte_buffer()</code>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">flush_write_buffer</span><span class="params">(<span class="keyword">struct</span> dentry * dentry, <span class="keyword">struct</span> sysfs_buffer * buffer, <span class="keyword">size_t</span> count)</span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *attr_sd = dentry-&gt;d_fsdata;</div><div class="line">       <span class="keyword">struct</span> kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj;</div><div class="line">       <span class="keyword">struct</span> sysfs_ops * ops = buffer-&gt;ops;</div><div class="line">       <span class="keyword">int</span> rc;</div><div class="line"></div><div class="line">       <span class="comment">/* need attr_sd for attr and ops, its parent for kobj */</span></div><div class="line">       <span class="keyword">if</span> (!sysfs_get_active_two(attr_sd))</div><div class="line">              <span class="keyword">return</span> -ENODEV;</div><div class="line"></div><div class="line">       rc = ops-&gt;store(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page, count);</div><div class="line"></div><div class="line">       sysfs_put_active_two(attr_sd);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在分析<code>open()</code>操作的时候曾分析到，<code>buffer</code>的<code>ops</code>是<code>kobject-&gt;ktype-&gt;ops</code>.在这里,它相当于调用了<code>kobject-&gt;ktype-&gt;ops-&gt;store()</code>.参数分别为:操作的<code>kobject</code>，文件对应的属性，写入的值和值的长度。<br>Sysfs这样设计,主要是在VFS保持一个统一的接口,因为每一个<code>kobject</code>对应的属性值都不相同,相应的,操作方法也不一样,这样,在<code>ktype</code>中就区别开来了.</p>
<p>文件的读操作相应接口为<code>sysfs_read_file()</code>，代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t</span></div><div class="line"><span class="title">sysfs_read_file</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_buffer * buffer = file-&gt;private_data;</div><div class="line">       <span class="keyword">ssize_t</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">       mutex_lock(&amp;buffer-&gt;mutex);</div><div class="line">       <span class="comment">//从设备模型中将值取出.并存入buffer-&gt;page中</span></div><div class="line">       <span class="keyword">if</span> (buffer-&gt;needs_read_fill) &#123;</div><div class="line">              retval = fill_read_buffer(file-&gt;f_path.dentry,buffer);</div><div class="line">              <span class="keyword">if</span> (retval)</div><div class="line">                     <span class="keyword">goto</span> out;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">//将buffer-&gt;page中的值copy到用户空间的buf</span></div><div class="line">       pr_debug(<span class="string">"%s: count = %zd, ppos = %lld, buf = %s\n"</span>,</div><div class="line">               __FUNCTION__, count, *ppos, buffer-&gt;page);</div><div class="line">       retval = simple_read_from_buffer(buf, count, ppos, buffer-&gt;page,</div><div class="line">                                    buffer-&gt;count);</div><div class="line">out:</div><div class="line">       mutex_unlock(&amp;buffer-&gt;mutex);</div><div class="line">       <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读操作的流程刚好和写操作流程相反.它先从设备模型中取值,然后再copy到用户空间.<br><code>fill_read_buffer</code>的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fill_read_buffer</span><span class="params">(<span class="keyword">struct</span> dentry * dentry, <span class="keyword">struct</span> sysfs_buffer * buffer)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *attr_sd = dentry-&gt;d_fsdata;</div><div class="line">       <span class="keyword">struct</span> kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj;</div><div class="line">       <span class="keyword">struct</span> sysfs_ops * ops = buffer-&gt;ops;</div><div class="line">       <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">       <span class="keyword">ssize_t</span> count;</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!buffer-&gt;page)</div><div class="line">              buffer-&gt;page = (<span class="keyword">char</span> *) get_zeroed_page(GFP_KERNEL);</div><div class="line">       <span class="keyword">if</span> (!buffer-&gt;page)</div><div class="line">              <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">       <span class="comment">/* need attr_sd for attr and ops, its parent for kobj */</span></div><div class="line">       <span class="keyword">if</span> (!sysfs_get_active_two(attr_sd))</div><div class="line">              <span class="keyword">return</span> -ENODEV;</div><div class="line"></div><div class="line">       buffer-&gt;event = atomic_read(&amp;attr_sd-&gt;s_attr.open-&gt;event);</div><div class="line">       count = ops-&gt;show(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page);</div><div class="line"></div><div class="line">       sysfs_put_active_two(attr_sd);</div><div class="line"></div><div class="line">       <span class="comment">/*</span></div><div class="line">        * The code works fine with PAGE_SIZE return but it's likely to</div><div class="line">        * indicate truncated result or overflow in normal use cases.</div><div class="line">        */</div><div class="line">       <span class="keyword">if</span> (count &gt;= (<span class="keyword">ssize_t</span>)PAGE_SIZE) &#123;</div><div class="line">              print_symbol(<span class="string">"fill_read_buffer: %s returned bad count\n"</span>,</div><div class="line">                     (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ops-&gt;show);</div><div class="line">              <span class="comment">/* Try to struggle along */</span></div><div class="line">              count = PAGE_SIZE - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (count &gt;= <span class="number">0</span>) &#123;</div><div class="line">              buffer-&gt;needs_read_fill = <span class="number">0</span>;</div><div class="line">              buffer-&gt;count = count;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">              ret = count;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里,我们看到,最终会调用<code>kobject-&gt;ktype-&gt;ops-&gt;show()</code>方法.参数含义同写操作中是一样的.</p>
<h2 id="在sysfs中创建二进制属性文件"><a href="#在sysfs中创建二进制属性文件" class="headerlink" title="在sysfs中创建二进制属性文件"></a>在sysfs中创建二进制属性文件</h2><p>二制制属性通常用于firmware中，它用来更新firmware的固件。<br>它的接口为<code>sysfs_create_bin_file()</code>，代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_bin_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="keyword">struct</span> bin_attribute * attr)</span></span></div><div class="line">&#123;</div><div class="line">       BUG_ON(!kobj || !kobj-&gt;sd || !attr);</div><div class="line"></div><div class="line">       <span class="keyword">return</span> sysfs_add_file(kobj-&gt;sd, &amp;attr-&gt;attr, SYSFS_KOBJ_BIN_ATTR);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sysfs_add_file()</code>这个函数我们在之前已经分析过,在这个地方,可能会引起迷糊,因为在<code>sysfs_add_file()</code>中有:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_add_file</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *dir_sd, <span class="keyword">const</span> <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                 <span class="keyword">int</span> type)</div><div class="line">&#123;</div><div class="line">       ……</div><div class="line">       sd-&gt;s_attr.attr = (<span class="keyword">void</span> *)attr;</div><div class="line">       ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里为什么是<code>sd-&gt;s_attr</code>呢? 应该是<code>sd-&gt; s_bin_attr</code>才对吧!<br>仔细观察<code>struct sysfs_dirent</code>的结构,如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sysfs_dirent &#123;</div><div class="line">       <span class="keyword">atomic_t</span>         s_count;</div><div class="line">       <span class="keyword">atomic_t</span>         s_active;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent  *s_parent;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent  *s_sibling;</div><div class="line">       <span class="keyword">const</span> <span class="keyword">char</span>           *s_name;</div><div class="line"></div><div class="line">       <span class="keyword">union</span> &#123;</div><div class="line">              <span class="keyword">struct</span> sysfs_elem_dir        s_dir;</div><div class="line">              <span class="keyword">struct</span> sysfs_elem_symlink    s_symlink;</div><div class="line">              <span class="keyword">struct</span> sysfs_elem_attr       s_attr;</div><div class="line">              <span class="keyword">struct</span> sysfs_elem_bin_attr   s_bin_attr;</div><div class="line">       &#125;;</div><div class="line"></div><div class="line">       <span class="keyword">unsigned</span> <span class="keyword">int</span>           s_flags;</div><div class="line">       <span class="keyword">ino_t</span>                  s_ino;</div><div class="line">       <span class="keyword">umode_t</span>                s_mode;</div><div class="line">       <span class="keyword">struct</span> iattr           *s_iattr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>注意中间是一个<code>union</code>结构，实际上只占用一个内存空间，而且<code>s_attr</code>与<code>s_bin_attr</code>的第一个属性都为<code>struct attribute</code>，所以在这里,<code>sd-&gt;s_attr</code>与<code>sd-&gt; s_bin_attr</code>;的效果是一样的。内核这样处理，又少用了一个接口。看来作者在设计的时候,花了很多的心思.</p>
<p>二进制的文件读写与普通属性的文件读写方式大部份都一样，所不同的是，二进制文件的读写接口分别是:<code>sysfs_dirent-&gt;s_bin_attr.bin_attr-&gt;read</code>和<code>sysfs_dirent-&gt;s_bin_attr.bin_attr-&gt;write</code>。</p>
<h2 id="sysfs文件系统中的链接文件"><a href="#sysfs文件系统中的链接文件" class="headerlink" title="sysfs文件系统中的链接文件"></a>sysfs文件系统中的链接文件</h2><p>创建链接文件的接口为:<code>sysfs_create_link()</code>.代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_link</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="keyword">struct</span> kobject * target, <span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *parent_sd = <span class="literal">NULL</span>;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *target_sd = <span class="literal">NULL</span>;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *sd = <span class="literal">NULL</span>;</div><div class="line">       <span class="keyword">struct</span> sysfs_addrm_cxt acxt;</div><div class="line">       <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">       BUG_ON(!name);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (!kobj)</div><div class="line">              parent_sd = &amp;sysfs_root;</div><div class="line">       <span class="keyword">else</span></div><div class="line">              parent_sd = kobj-&gt;sd;</div><div class="line"></div><div class="line">       error = -EFAULT;</div><div class="line">       <span class="keyword">if</span> (!parent_sd)</div><div class="line">              <span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">       <span class="comment">/* target-&gt;sd can go away beneath us but is protected with</span></div><div class="line">        * sysfs_assoc_lock.  Fetch target_sd from it.</div><div class="line">        */</div><div class="line">       spin_lock(&amp;sysfs_assoc_lock);</div><div class="line">       <span class="keyword">if</span> (target-&gt;sd)</div><div class="line">              target_sd = sysfs_get(target-&gt;sd);</div><div class="line">       spin_unlock(&amp;sysfs_assoc_lock);</div><div class="line"></div><div class="line">       error = -ENOENT;</div><div class="line">       <span class="keyword">if</span> (!target_sd)</div><div class="line">              <span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">       error = -ENOMEM;</div><div class="line">       sd = sysfs_new_dirent(name, S_IFLNK|S_IRWXUGO, SYSFS_KOBJ_LINK);</div><div class="line">       <span class="keyword">if</span> (!sd)</div><div class="line">              <span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">       sd-&gt;s_symlink.target_sd = target_sd;</div><div class="line">       target_sd = <span class="literal">NULL</span>; <span class="comment">/* reference is now owned by the symlink */</span></div><div class="line"></div><div class="line">       sysfs_addrm_start(&amp;acxt, parent_sd);</div><div class="line">       error = sysfs_add_one(&amp;acxt, sd);</div><div class="line">       sysfs_addrm_finish(&amp;acxt);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> (error)</div><div class="line">              <span class="keyword">goto</span> out_put;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line"> out_put:</div><div class="line">       sysfs_put(target_sd);</div><div class="line">       sysfs_put(sd);</div><div class="line">       <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的操作大部份都与普通文件的创建相似,所不同的只是下面这段代码的区别:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sd-&gt;s_symlink.target_sd = target_sd;</div></pre></td></tr></table></figure></p>
<p>就是在<code>sd-&gt;s_symlink.target_sd</code>保存到链接目的地的<code>sysfs_dirent</code>.<br>符号链接的操作如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> inode_operations sysfs_symlink_inode_operations = &#123;</div><div class="line">       .readlink = generic_readlink,</div><div class="line">       .follow_link = sysfs_follow_link,</div><div class="line">       .put_link = sysfs_put_link,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在通过符号链接查找文件的时候,在VFS中会调用<code>inod-&gt;i_op-&gt;readlink()</code>进行操作.它的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">generic_readlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">char</span> __user *buffer, <span class="keyword">int</span> buflen)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> nameidata nd;</div><div class="line">       <span class="keyword">void</span> *cookie;</div><div class="line"></div><div class="line">       nd.depth = <span class="number">0</span>;</div><div class="line">       cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);</div><div class="line">       <span class="keyword">if</span> (!IS_ERR(cookie)) &#123;</div><div class="line">              <span class="keyword">int</span> res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd));</div><div class="line">              <span class="keyword">if</span> (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)</div><div class="line">                     dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd, cookie);</div><div class="line">              cookie = ERR_PTR(res);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> PTR_ERR(cookie);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它的操作和其它文件系统一样,都是通用<code>follow_link()</code>取得目的地的路径,然后保存到<code>nd-&gt;saved_names[]</code>中,然后,调用<code>vfs_readlink()</code>将目标路径copy到<code>buffer</code>中.接着,调用<code>put_link</code>进行事后处理工作.</p>
<p><code>follow_link()</code>的操作如下示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sysfs_follow_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> nameidata *nd)</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">int</span> error = -ENOMEM;</div><div class="line">       <span class="keyword">unsigned</span> <span class="keyword">long</span> page = get_zeroed_page(GFP_KERNEL);</div><div class="line">       <span class="keyword">if</span> (page)</div><div class="line">              error = sysfs_getlink(dentry, (<span class="keyword">char</span> *) page);</div><div class="line">       nd_set_link(nd, error ? ERR_PTR(error) : (<span class="keyword">char</span> *)page);</div><div class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>nd_set_link()</code>是将<code>page</code>中的值copy到<code>nd-&gt;saved_name[]</code>中.<br><code>sysfs_getlink()</code>的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sysfs_getlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">char</span> * path)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> sysfs_dirent *sd = dentry-&gt;d_fsdata;</div><div class="line">	<span class="keyword">struct</span> sysfs_dirent *parent_sd = sd-&gt;s_parent;</div><div class="line">	<span class="keyword">struct</span> sysfs_dirent *target_sd = sd-&gt;s_symlink.target_sd;</div><div class="line">	<span class="keyword">int</span> error;</div><div class="line"></div><div class="line">	mutex_lock(&amp;sysfs_mutex);</div><div class="line">	error = sysfs_get_target_path(parent_sd, target_sd, path);</div><div class="line">	mutex_unlock(&amp;sysfs_mutex);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>sysfs_get_target_path()</code>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sysfs_get_target_path</span><span class="params">(<span class="keyword">struct</span> sysfs_dirent *parent_sd,</span></span></div><div class="line">                             <span class="keyword">struct</span> sysfs_dirent *target_sd, <span class="keyword">char</span> *path)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">struct</span> sysfs_dirent *base, *sd;</div><div class="line">       <span class="keyword">char</span> *s = path;</div><div class="line">       <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line"></div><div class="line">       <span class="comment">/* go up to the root, stop at the base */</span></div><div class="line">       base = parent_sd;</div><div class="line">       <span class="keyword">while</span> (base-&gt;s_parent) &#123;</div><div class="line">              sd = target_sd-&gt;s_parent;</div><div class="line">              <span class="keyword">while</span> (sd-&gt;s_parent &amp;&amp; base != sd)</div><div class="line">                     sd = sd-&gt;s_parent;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (base == sd)</div><div class="line">                     <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="built_in">strcpy</span>(s, <span class="string">"../"</span>);</div><div class="line">              s += <span class="number">3</span>;</div><div class="line">              base = base-&gt;s_parent;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/* determine end of target string for reverse fillup */</span></div><div class="line">       sd = target_sd;</div><div class="line">       <span class="keyword">while</span> (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</div><div class="line">              len += <span class="built_in">strlen</span>(sd-&gt;s_name) + <span class="number">1</span>;</div><div class="line">              sd = sd-&gt;s_parent;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">/* check limits */</span></div><div class="line">       <span class="keyword">if</span> (len &lt; <span class="number">2</span>)</div><div class="line">              <span class="keyword">return</span> -EINVAL;</div><div class="line">       len--;</div><div class="line">       <span class="keyword">if</span> ((s - path) + len &gt; PATH_MAX)</div><div class="line">              <span class="keyword">return</span> -ENAMETOOLONG;</div><div class="line">       <span class="comment">/* reverse fillup of target string from target to base */</span></div><div class="line">       sd = target_sd;</div><div class="line">       <span class="keyword">while</span> (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</div><div class="line">              <span class="keyword">int</span> slen = <span class="built_in">strlen</span>(sd-&gt;s_name);</div><div class="line"></div><div class="line">              len -= slen;</div><div class="line">              <span class="built_in">strncpy</span>(s + len, sd-&gt;s_name, slen);</div><div class="line">              <span class="keyword">if</span> (len)</div><div class="line">                     s[--len] = <span class="string">'/'</span>;</div><div class="line"></div><div class="line">              sd = sd-&gt;s_parent;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码的逻辑比较简单.它先是找到目标路径和当前路径相同的父结点,然后再沿着目标结点往相同的父结点向上走,将路径依次从缓存区后面往前面保存.<br>例如: <code>/sys/eric/kernel/test</code>链接到了<code>/sys/sys/device</code>.<br>它先找到两个路径共有的父结点<code>/sys</code>此时缓存区为:<code>/sys</code>然后,沿着<code>/sys/sys/device</code>往<code>/sys</code>移动,路径加从缓存区的后面往前面加.依次为:<br>1: /sys/     /device<br>2:/sys/sys/device<br>这样就找到了目的地的路径. ^_^.<br>后面<code>sysfs_put_link()</code>的操作就不再讲述了,它只是释放掉缓存区.</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本小节里,我们深入探讨了sysfs文件系统的实现机理.这对于我们理解linux设备模型是很有帮助的.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux设备模型深探]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/probe-of-linux-kernel-driver-module/</url>
      <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.chinaunix.net/uid-20543183-id-1930813.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-20543183-id-1930813.html</a></p>
<p>源码文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./lib/kobject.c</div><div class="line">./drivers/base/bus.c</div><div class="line">./drivers/base/driver.c</div><div class="line">./drivers/base/core.c</div></pre></td></tr></table></figure></p>
<p>目录：<br><a href="#1">一：前言</a><br><a href="#2">二：kobject、kset和ktype</a><br><a href="#3">三：kobject、kset和ktype的操作</a>  </p>
<ul>
<li><a href="#3.1">kobject 操作</a></li>
<li><a href="#3.2">kset 操作</a></li>
</ul>
<p><a href="#4">四：bus、device和device_driver</a></p>
<ul>
<li><a href="#4.1">总线注册</a></li>
<li><a href="#4.2">设备注册</a></li>
<li><a href="#4.3">驱动注册</a></li>
</ul>
<p><a href="#5">五：小结</a><br><a id="more"></a></p>
<h2 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a><a name="1">一：前言</a></h2><p>Linux设备模型是一个极其复杂的结构体系，在编写驱动程序的时候，通常不会用到这方面的东西，但是，理解这部份内容，对于我们理解linux设备驱动的结构是大有裨益的。我们不但可以在编写程序程序的时候知其然亦知其所以然，又可以学习到一种极其精致的架构设计方法。由于之前已经详细分析了<code>sysfs</code>文件系统，所以本节的讨论主要集中在设备模型的底层实现上。上层的接口，如<code>pci</code>、<code>usb</code>、网络设备都可以看成是底层的封装。</p>
<h2 id="二：kobject、kset和ktype"><a href="#二：kobject、kset和ktype" class="headerlink" title="二：kobject、kset和ktype "></a><a name="2">二：kobject、kset和ktype </a></h2><p><code>kobject</code>,<code>kset</code>,<code>ktype</code>这三个结构是设备模型中的下层架构。模型中的每一个元素都对应一个<code>kobject</code>，<code>kset</code>和<code>ktype</code>可以看成是<code>kobject</code>在层次结构与属性结构方面的扩充。将三者之间的关系用图的方示描述如下：</p>
 <img src="/kernel/设备驱动/probe-of-linux-kernel-driver-module/kobject-kset-ktype.jpg" alt="kobject-kset-ktype.jpg" title="">
<p>如上图所示：我们知道，在<code>sysfs</code>中每一个目录都对应一个<code>kobject</code>，这些<code>kobject</code>都有自己的<code>parent</code>，在没有指定<code>parent</code>的情况下，都会指向它所属的<code>kset-&gt;object</code>；其次，<code>kset</code>也内嵌了<code>kobject</code>，这个<code>kobject</code>又可以指它上一级的<code>parent</code>。就这样，构成了一个空间层次关系。</p>
<p>其实，每个对象都有属性，例如，电源管理，执插拨事性管理等等。因为大部份的同类设备都有相同的属性，因此将这个属性隔离开来，存放在<code>ktype</code>中。这样就可以灵活的管理了。记得在分析<code>sysfs</code>的时候，对于<code>sysfs</code>中的普通文件读写操作都是由<code>kobject-&gt;ktype-&gt;sysfs_ops</code>来完成的。</p>
<p>经过上面的分析，我们大概了解了<code>kobject</code>、<code>kset</code>与<code>ktype</code>的大概架构与相互之间的关系。下面我们从linux源代码中的分析来详细研究他们的操作。</p>
<h2 id="三：kobject、kset和ktype的操作"><a href="#三：kobject、kset和ktype的操作" class="headerlink" title="三：kobject、kset和ktype的操作"></a><a name="3">三：kobject、kset和ktype的操作</a></h2><p>为了说明<code>kobject</code>的操作，先写一个测试模块，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></div><div class="line"></div><div class="line">MODULE_AUTHOR(<span class="string">"eric xiao"</span>);</div><div class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">obj_test_release</span><span class="params">(<span class="keyword">struct</span> kobject *kobject)</span></span>;</div><div class="line"><span class="keyword">ssize_t</span> eric_test_show(<span class="keyword">struct</span> kobject *kobject, <span class="keyword">struct</span> attribute *attr,<span class="keyword">char</span> *buf);</div><div class="line"><span class="keyword">ssize_t</span> eric_test_store(<span class="keyword">struct</span> kobject *kobject,<span class="keyword">struct</span> attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</div><div class="line"></div><div class="line"><span class="keyword">struct</span> attribute test_attr = &#123;</div><div class="line">        .name = <span class="string">"eric_xiao"</span>,</div><div class="line">        .mode = S_IRWXUGO,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *def_attrs[] = &#123;</div><div class="line">        &amp;test_attr,</div><div class="line">        <span class="literal">NULL</span>,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> sysfs_ops obj_test_sysops =</div><div class="line">&#123;</div><div class="line">        .show = eric_test_show,</div><div class="line">        .store = eric_test_store,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> kobj_type ktype =</div><div class="line">&#123;</div><div class="line">        .release = obj_test_release,</div><div class="line">        .sysfs_ops=&amp;obj_test_sysops,</div><div class="line">        .default_attrs=def_attrs,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">obj_test_release</span><span class="params">(<span class="keyword">struct</span> kobject *kobject)</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"eric_test: release .\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> eric_test_show(<span class="keyword">struct</span> kobject *kobject, <span class="keyword">struct</span> attribute *attr,<span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"have show.\n"</span>);</div><div class="line">        printk(<span class="string">"attrname:%s.\n"</span>, attr-&gt;name);</div><div class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">"%s\n"</span>,attr-&gt;name);</div><div class="line">        <span class="keyword">return</span> <span class="built_in">strlen</span>(attr-&gt;name)+<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">ssize_t</span> eric_test_store(<span class="keyword">struct</span> kobject *kobject,<span class="keyword">struct</span> attribute *attr,<span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"havestore\n"</span>);</div><div class="line">        printk(<span class="string">"write: %s\n"</span>,buf);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> kobject kobj;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_test_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"kboject test init.\n"</span>);</div><div class="line">        kobject_init_and_add(&amp;kobj,&amp;ktype,<span class="literal">NULL</span>,<span class="string">"eric_test"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_test_exit</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"kobject test exit.\n"</span>);</div><div class="line">        kobject_del(&amp;kobj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(kobject_test_init);</div><div class="line">module_exit(kobject_test_exit);</div></pre></td></tr></table></figure></p>
<p>加载模块之后，会发现，在<code>/sys</code>下多了一个<code>eric_test</code>目录。该目录下有一个叫<code>eric_xiao</code>的文件。如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost eric_test]<span class="comment"># ls</span></div><div class="line">eric_xiao</div></pre></td></tr></table></figure></p>
<p>用<code>cat</code>察看此文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@localhost eric_test]<span class="comment"># cat eric_xiao</span></div><div class="line">eric_xiao</div></pre></td></tr></table></figure></p>
<p>再用<code>echo</code>往里面写点东西；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@localhost eric_test]<span class="comment"># echo  hello &gt; eric_xiao</span></div></pre></td></tr></table></figure></p>
<p>Dmesg的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">have show.</div><div class="line">attrname:eric_xiao.</div><div class="line">havestore</div><div class="line">write: hello</div></pre></td></tr></table></figure></p>
<p>如上所示，我们看到了<code>kobject</code>的大概建立过程。</p>
<h3 id="kobject-操作"><a href="#kobject-操作" class="headerlink" title="kobject 操作"></a><a name="3.1">kobject 操作</a></h3><p>我们来看一下<code>kobject_init_and_add()</code>的实现，在这个函数里，包含了对<code>kobject</code>的大部份操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_init_and_add</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobj_type *ktype,</span></span></div><div class="line">               <span class="keyword">struct</span> kobject *parent, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</div><div class="line">&#123;</div><div class="line">     va_list args;</div><div class="line">     <span class="keyword">int</span> retval;</div><div class="line">     <span class="comment">//初始化kobject</span></div><div class="line">     kobject_init(kobj, ktype);</div><div class="line"></div><div class="line">     va_start(args, fmt);</div><div class="line">     <span class="comment">//为kobjcet设置名称，在sysfs中建立相关信息</span></div><div class="line">     retval = kobject_add_varg(kobj, parent, fmt, args);</div><div class="line">     va_end(args);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的流程主要分为两部份：一部份是<code>kobject</code>的初始化，在这一部份，它将<code>kobject</code>与给定的<code>ktype</code>关联起来，初始化<code>kobject</code>中的各项结构；另一部份是<code>kobject</code>的名称设置，空间层次关系的设置，具体表现在<code>sysfs</code>文件系统中。</p>
<p>对于第一部份，代码比较简单，这里不再赘述。跟踪第二部份，也就是<code>kobject_add_varg()</code>的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_varg</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> kobject *parent,</span></span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list vargs)</div><div class="line">&#123;</div><div class="line">     va_list aq;</div><div class="line">     <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">     va_copy(aq, vargs);</div><div class="line">     <span class="comment">//设置kobject的名字。即kobject的name成员</span></div><div class="line">     retval = kobject_set_name_vargs(kobj, fmt, aq);</div><div class="line">     va_end(aq);</div><div class="line">     <span class="keyword">if</span> (retval) &#123;</div><div class="line">         printk(KERN_ERR <span class="string">"kobject: can not set name properly!\n"</span>);</div><div class="line">         <span class="keyword">return</span> retval;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//设置kobject的parent。在上面的例子中，我们没有给它指定父结点</span></div><div class="line">     kobj-&gt;parent = parent;</div><div class="line">     <span class="comment">//在sysfs中添加kobjcet信息</span></div><div class="line">     <span class="keyword">return</span> kobject_add_internal(kobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置好<code>kobject-&gt;name</code>后，转入<code>kobject_add_internal()</code>，在sysfs中创建空间结构。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kobject_add_internal</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line">     <span class="keyword">struct</span> kobject *parent;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!kobj)</div><div class="line">         <span class="keyword">return</span> -ENOENT;</div><div class="line">     <span class="comment">//如果kobject的名字为空.退出</span></div><div class="line">     <span class="keyword">if</span> (!kobj-&gt;name || !kobj-&gt;name[<span class="number">0</span>]) &#123;</div><div class="line">         pr_debug(<span class="string">"kobject: (%p): attempted to be registered with empty "</span></div><div class="line">               <span class="string">"name!\n"</span>, kobj);</div><div class="line">         WARN_ON(<span class="number">1</span>);</div><div class="line">         <span class="keyword">return</span> -EINVAL;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//取kobject的父结点</span></div><div class="line">     parent = kobject_get(kobj-&gt;parent);</div><div class="line">     <span class="comment">//如果kobject的父结点没有指定，就将kset-&gt;kobject做为它的父结点</span></div><div class="line">     <span class="comment">/* join kset if set, use it as parent if we do not already have one */</span></div><div class="line">     <span class="keyword">if</span> (kobj-&gt;kset) &#123;</div><div class="line">         <span class="keyword">if</span> (!parent)</div><div class="line">              parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);</div><div class="line">         kobj_kset_join(kobj);</div><div class="line">         kobj-&gt;parent = parent;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//调试用</span></div><div class="line">     pr_debug(<span class="string">"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\n"</span>,</div><div class="line">          kobject_name(kobj), kobj, __FUNCTION__,</div><div class="line">          parent ? kobject_name(parent) : <span class="string">"&lt;NULL&gt;"</span>,</div><div class="line">          kobj-&gt;kset ? kobject_name(&amp;kobj-&gt;kset-&gt;kobj) : <span class="string">"&lt;NULL&gt;"</span>);</div><div class="line"></div><div class="line">     <span class="comment">//在sysfs中创建kobject的相关元素</span></div><div class="line">     error = create_dir(kobj);</div><div class="line">     <span class="keyword">if</span> (error) &#123;</div><div class="line">         <span class="comment">//如果创建失败。减少相关的引用计数</span></div><div class="line">         kobj_kset_leave(kobj);</div><div class="line">         kobject_put(parent);</div><div class="line">         kobj-&gt;parent = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">         <span class="comment">/* be noisy on error issues */</span></div><div class="line">         <span class="keyword">if</span> (error == -EEXIST)</div><div class="line">              printk(KERN_ERR <span class="string">"%s failed for %s with "</span></div><div class="line">                     <span class="string">"-EEXIST, don't try to register things with "</span></div><div class="line">                     <span class="string">"the same name in the same directory.\n"</span>,</div><div class="line">                     __FUNCTION__, kobject_name(kobj));</div><div class="line">         <span class="keyword">else</span></div><div class="line">              printk(KERN_ERR <span class="string">"%s failed for %s (%d)\n"</span>,</div><div class="line">                     __FUNCTION__, kobject_name(kobj), error);</div><div class="line">         dump_stack();</div><div class="line">     &#125; <span class="keyword">else</span></div><div class="line">         <span class="comment">//如果创建成功。将state_in_sysfs建为1。表示该object已经在sysfs中了</span></div><div class="line">         kobj-&gt;state_in_sysfs = <span class="number">1</span>;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码比较简单，它主要完成<code>kobject</code>父结点的判断和选定，然后再调用<code>create_dir()</code>在<code>sysfs</code>创建相关信息。该函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">create_dir</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line">     <span class="keyword">if</span> (kobject_name(kobj)) &#123;</div><div class="line">          <span class="comment">//为kobject创建目录</span></div><div class="line">         error = sysfs_create_dir(kobj);</div><div class="line">         <span class="keyword">if</span> (!error) &#123;</div><div class="line">              <span class="comment">//为kobject-&gt;ktype中的属性创建文件</span></div><div class="line">              error = populate_dir(kobj);</div><div class="line">              <span class="keyword">if</span> (error)</div><div class="line">                   sysfs_remove_dir(kobj);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在上面的示例中看到的<code>/sys</code>下的<code>eric_test</code>目录，以及该目录下面的<code>eric_xiao</code>的这个文件就是这里被创建的。我们先看一下<code>kobject</code>所表示的目录创建过程，这是在<code>sysfs_create_dir()</code>中完成的。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfs_create_dir</span><span class="params">(<span class="keyword">struct</span> kobject * kobj)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> sysfs_dirent *parent_sd, *sd;</div><div class="line">     <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line"></div><div class="line">     BUG_ON(!kobj);</div><div class="line">     <span class="comment">/*</span></div><div class="line">      *如果kobject的parnet存在，就在目录点的目录下创建这个目录;</div><div class="line">      *如果父结点不存在，就在/sys下面创建结点。</div><div class="line">      *在上面的流程中，我们可能并没有为其指定父结点，也没有为其指定kset。</div><div class="line">      */</div><div class="line">     <span class="keyword">if</span> (kobj-&gt;parent)</div><div class="line">         parent_sd = kobj-&gt;parent-&gt;sd;</div><div class="line">     <span class="keyword">else</span></div><div class="line">         parent_sd = &amp;sysfs_root;</div><div class="line"></div><div class="line">     <span class="comment">//在sysfs中创建目录</span></div><div class="line">     error = create_dir(kobj, parent_sd, kobject_name(kobj), &amp;sd);</div><div class="line">     <span class="keyword">if</span> (!error)</div><div class="line">         kobj-&gt;sd = sd;</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，我们就要联系之前分析过的sysfs文件系统的研究了。如果不太清楚的，可以再找到那篇文章仔细的研读一下。<code>create_dir()</code>就是在<code>sysfs</code>中创建目录的接口，在之前已经详细分析过了。这里不再讲述。</p>
<p>接着看为<code>kobject-&gt;ktype</code>中的属性创建文件，这是在<code>populate_dir()</code>中完成的。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">populate_dir</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kobj_type *t = get_ktype(kobj);</div><div class="line">     <span class="keyword">struct</span> attribute *attr;</div><div class="line">     <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;</div><div class="line">         <span class="keyword">for</span> (i = <span class="number">0</span>; (attr = t-&gt;default_attrs[i]) != <span class="literal">NULL</span>; i++) &#123;</div><div class="line">              error = sysfs_create_file(kobj, attr);</div><div class="line">              <span class="keyword">if</span> (error)</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码比较简单，它遍历<code>ktype</code>中的属性，然后为其建立文件。请注意：文件的操作最后都会回溯到<code>ktype-&gt;sysfs_ops</code>的<code>show</code>和<code>store</code>这两个函数中。</p>
<p><code>kobject</code>的创建已经分析完了，接着分析怎么将一个<code>kobject</code>注销掉。注意过程是在<code>kobject_del()</code>中完成的。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kobject_del</span><span class="params">(<span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (!kobj)</div><div class="line">         <span class="keyword">return</span>;</div><div class="line"></div><div class="line">     sysfs_remove_dir(kobj);</div><div class="line">     kobj-&gt;state_in_sysfs = <span class="number">0</span>;</div><div class="line">     kobj_kset_leave(kobj);</div><div class="line">     kobject_put(kobj-&gt;parent);</div><div class="line">     kobj-&gt;parent = <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数会将在<code>sysfs</code>中的<code>kobject</code>对应的目录删除。请注意，属性文件是建立在这个目录下面的，只需要将这个目录删除，属性文件也随之删除。<br>最后，减少相关的引用计数，如果<code>kobject</code>的引用计数为零。则将其所占空间释放.</p>
<h3 id="kset-操作"><a href="#kset-操作" class="headerlink" title="kset 操作"></a><a name="3.2">kset 操作</a></h3><p><code>kset</code>的操作与<code>kobject</code>类似，因为<code>kset</code>中内嵌了一个<code>kobject</code>结构，所以，大部份操作都是集中在<code>kset-&gt;kobject</code>上。具体分析一下<code>kset_create_and_add()</code>这个接口,类似上面分析的<code>kobject</code>接口，这个接口也包括了<code>kset</code>的大部分操作。代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> kset *<span class="title">kset_create_and_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></div><div class="line">                    <span class="keyword">struct</span> kset_uevent_ops *uevent_ops,</div><div class="line">                    <span class="keyword">struct</span> kobject *parent_kobj)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kset *kset;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line">     <span class="comment">//创建一个kset</span></div><div class="line">     kset = kset_create(name, uevent_ops, parent_kobj);</div><div class="line">     <span class="keyword">if</span> (!kset)</div><div class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">     <span class="comment">//注册kset</span></div><div class="line">     error = kset_register(kset);</div><div class="line">     <span class="keyword">if</span> (error) &#123;</div><div class="line">         <span class="comment">//如果注册失败,释放kset</span></div><div class="line">         kfree(kset);</div><div class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> kset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>kset_create()</code>用来创建一个<code>struct kset</code>结构。代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> kset *<span class="title">kset_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,</span></span></div><div class="line">                   <span class="keyword">struct</span> kset_uevent_ops *uevent_ops,</div><div class="line">                   <span class="keyword">struct</span> kobject *parent_kobj)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kset *kset;</div><div class="line"></div><div class="line">     kset = kzalloc(<span class="keyword">sizeof</span>(*kset), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (!kset)</div><div class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">     kobject_set_name(&amp;kset-&gt;kobj, name);</div><div class="line">     kset-&gt;uevent_ops = uevent_ops;</div><div class="line">     kset-&gt;kobj.parent = parent_kobj;</div><div class="line"></div><div class="line">     kset-&gt;kobj.ktype = &amp;kset_ktype;</div><div class="line">     kset-&gt;kobj.kset = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> kset;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们注意，在这里创建<code>kset</code>时，为其内嵌的<code>kobject</code>指定其<code>ktype</code>结构为<code>kset_ktype</code>。这个结构的定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_type kset_ktype = &#123;</div><div class="line">     .sysfs_ops    = &amp;kobj_sysfs_ops,</div><div class="line">     .release = kset_release,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>属性文件的读写操作全部都包含在<code>sysfs_ops</code>成员里，<code>kobj_sysfs_ops</code>的定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sysfs_ops kobj_sysfs_ops = &#123;</div><div class="line">     .show    = kobj_attr_show,</div><div class="line">     .store   = kobj_attr_store,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>show</code>,<code>store</code>成员对应的函数代码如下所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">kobj_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                    <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kobj_attribute *kattr;</div><div class="line">     <span class="keyword">ssize_t</span> ret = -EIO;</div><div class="line"></div><div class="line">     kattr = container_of(attr, <span class="keyword">struct</span> kobj_attribute, attr);</div><div class="line">     <span class="keyword">if</span> (kattr-&gt;show)</div><div class="line">         ret = kattr-&gt;show(kobj, kattr, buf);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">kobj_attr_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kobj_attribute *kattr;</div><div class="line">     <span class="keyword">ssize_t</span> ret = -EIO;</div><div class="line"></div><div class="line">     kattr = container_of(attr, <span class="keyword">struct</span> kobj_attribute, attr);</div><div class="line">     <span class="keyword">if</span> (kattr-&gt;store)</div><div class="line">         ret = kattr-&gt;store(kobj, kattr, buf, count);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码看以看出，会将<code>struct attribute</code>结构转换为<code>struct kobj_attribte</code>结构，也就是说<code>struct kobj_attribte</code>内嵌了一个<code>struct attribute</code>。实际上，这是和宏<code>__ATTR</code>配合在一起使用的，经常用于<code>group</code>中，在这里并不打算研究<code>group</code>，原理都是一样的，这里列出来只是做个说明而已。</p>
<p>创建好了<code>kset</code>之后，会调用<code>kset_register()</code>，这个函数就是<code>kset</code>操作的核心代码了。如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_register</span><span class="params">(<span class="keyword">struct</span> kset *k)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> err;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!k)</div><div class="line">         <span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">     kset_init(k);</div><div class="line">     err = kobject_add_internal(&amp;k-&gt;kobj);</div><div class="line">     <span class="keyword">if</span> (err)</div><div class="line">         <span class="keyword">return</span> err;</div><div class="line">     kobject_uevent(&amp;k-&gt;kobj, KOBJ_ADD);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>kset_init()</code>里会初始化<code>kset</code>中的其它字段，然后调用<code>kobject_add_internal()</code>为其内嵌的<code>kobject</code>结构建立空间层次结构，之后因为添加了<code>kset</code>，会产生一个事件，这个事件是通过用户空间的<code>hotplug</code>程序处理的，这就是<code>kset</code>明显不同于<code>kobject</code>的地方。详细研究一下这个函数，这对于我们研究<code>hotplug</code>的深层机理是很有帮助的，它的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">enum</span> kobject_action action)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> kobject_uevent_env(kobj, action, <span class="literal">NULL</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后，会调用<code>kobject_uevent_env()</code>。这个函数中的三个参数含义分别为:引起事件的<code>kobject</code>，事件类型(<code>add</code>,<code>remove</code>,<code>change</code>,<code>move</code>,<code>online</code>,<code>offline</code>等)，第三个参数是要添加的环境变量。</p>
<p>代码篇幅较长，我们效仿情景分析的做法，分段分析如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kobject_uevent_env</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">enum</span> kobject_action action,</span></span></div><div class="line">                <span class="keyword">char</span> *envp_ext[])</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kobj_uevent_env *env;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *action_string = kobject_actions[action];</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *devpath = <span class="literal">NULL</span>;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *subsystem;</div><div class="line">     <span class="keyword">struct</span> kobject *top_kobj;</div><div class="line">     <span class="keyword">struct</span> kset *kset;</div><div class="line">     <span class="keyword">struct</span> kset_uevent_ops *uevent_ops;</div><div class="line">     u64 seq;</div><div class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> retval = <span class="number">0</span>;</div><div class="line"></div><div class="line">     pr_debug(<span class="string">"kobject: '%s' (%p): %s\n"</span>,</div><div class="line">          kobject_name(kobj), kobj, __FUNCTION__);</div><div class="line"></div><div class="line">     <span class="comment">/* search the kset we belong to */</span></div><div class="line">     top_kobj = kobj;</div><div class="line">     <span class="keyword">while</span> (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)</div><div class="line">         top_kobj = top_kobj-&gt;parent;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!top_kobj-&gt;kset) &#123;</div><div class="line">         pr_debug(<span class="string">"kobject: '%s' (%p): %s: attempted to send uevent "</span></div><div class="line">               <span class="string">"without kset!\n"</span>, kobject_name(kobj), kobj,</div><div class="line">               __FUNCTION__);</div><div class="line">         <span class="keyword">return</span> -EINVAL;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>因为对事件的处理函数包含在<code>kobject-&gt;kset-&gt;uevent_ops</code>中，要处理事件，就必须要找到上层的一个不为空的<code>kset</code>。上面的代码就是顺着<code>kobject-&gt;parent</code>找不到一个不为空的<code>kset</code>，如果不存在这样的<code>kset</code>，就退出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">kset = top_kobj-&gt;kset;</div><div class="line">uevent_ops = kset-&gt;uevent_ops;</div><div class="line"></div><div class="line"><span class="comment">/* skip the event, if the filter returns zero. */</span></div><div class="line"><span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;filter)</div><div class="line">    <span class="keyword">if</span> (!uevent_ops-&gt;filter(kset, kobj)) &#123;</div><div class="line">         pr_debug(<span class="string">"kobject: '%s' (%p): %s: filter function "</span></div><div class="line">               <span class="string">"caused the event to drop!\n"</span>,</div><div class="line">               kobject_name(kobj), kobj, __FUNCTION__);</div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/* originating subsystem */</span></div><div class="line"><span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;name)</div><div class="line">    subsystem = uevent_ops-&gt;name(kset, kobj);</div><div class="line"><span class="keyword">else</span></div><div class="line">    subsystem = kobject_name(&amp;kset-&gt;kobj);</div><div class="line"><span class="keyword">if</span> (!subsystem) &#123;</div><div class="line">    pr_debug(<span class="string">"kobject: '%s' (%p): %s: unset subsystem caused the "</span></div><div class="line">          <span class="string">"event to drop!\n"</span>, kobject_name(kobj), kobj,</div><div class="line">          __FUNCTION__);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找到了不为空的<code>kset</code>，就跟<code>kset-&gt;uevent_ops-&gt;filter()</code>匹配，看这个事件是否被过滤。如果没有被过滤掉，就会调用<code>kset-&gt;uevent_ops-&gt;name()</code>得到子系统的名称。如果不存在<code>kset-&gt;uevent_ops-&gt;name()</code>，就会以<code>kobject-&gt;name</code>做为子系统名称。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* environment buffer */</span></div><div class="line">env = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kobj_uevent_env), GFP_KERNEL);</div><div class="line"><span class="keyword">if</span> (!env)</div><div class="line">    <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line"><span class="comment">/* complete object path */</span></div><div class="line">devpath = kobject_get_path(kobj, GFP_KERNEL);</div><div class="line"><span class="keyword">if</span> (!devpath) &#123;</div><div class="line">    retval = -ENOENT;</div><div class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* default keys */</span></div><div class="line">retval = add_uevent_var(env, <span class="string">"ACTION=%s"</span>, action_string);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">retval = add_uevent_var(env, <span class="string">"DEVPATH=%s"</span>, devpath);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">retval = add_uevent_var(env, <span class="string">"SUBSYSTEM=%s"</span>, subsystem);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line"></div><div class="line"><span class="comment">/* keys passed in from the caller */</span></div><div class="line"><span class="keyword">if</span> (envp_ext) &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; envp_ext[i]; i++) &#123;</div><div class="line">         retval = add_uevent_var(env, envp_ext[i]);</div><div class="line">         <span class="keyword">if</span> (retval)</div><div class="line">              <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来,就应该设置为调用<code>hotplug</code>设置环境变量了。首先,分配一个<code>struct kobj_uevent_env</code>结构用来存放环境变量的值；然后调用<code>kobject_get_path()</code>用来获得引起事件的<code>kobject</code>在<code>sysfs</code>中的路径；再调用<code>add_uevent_var()</code>将动作代表的字串、<code>kobject</code>路径、子系统名称填充到<code>struct kobj_uevent_env</code>中。如果有指定环境变量,也将其添加进去。 <code>kobject_get_path()</code>和<code>add_uevent_var()</code>都比较简单.这里不再详细分析了.请自行查看源代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* let the kset specific function add its stuff */</span></div><div class="line"><span class="keyword">if</span> (uevent_ops &amp;&amp; uevent_ops-&gt;uevent) &#123;</div><div class="line">    retval = uevent_ops-&gt;uevent(kset, kobj, env);</div><div class="line">    <span class="keyword">if</span> (retval) &#123;</div><div class="line">         pr_debug(<span class="string">"kobject: '%s' (%p): %s: uevent() returned "</span></div><div class="line">               <span class="string">"%d\n"</span>, kobject_name(kobj), kobj,</div><div class="line">               __FUNCTION__, retval);</div><div class="line">         <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Mark "add" and "remove" events in the object to ensure proper</div><div class="line"> * events to userspace during automatic cleanup. If the object did</div><div class="line"> * send an "add" event, "remove" will automatically generated by</div><div class="line"> * the core, if not already done by the caller.</div><div class="line"> */</div><div class="line"><span class="keyword">if</span> (action == KOBJ_ADD)</div><div class="line">    kobj-&gt;state_add_uevent_sent = <span class="number">1</span>;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (action == KOBJ_REMOVE)</div><div class="line">    kobj-&gt;state_remove_uevent_sent = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/* we will send an event, so request a new sequence number */</span></div><div class="line">spin_lock(&amp;sequence_lock);</div><div class="line">seq = ++uevent_seqnum;</div><div class="line">spin_unlock(&amp;sequence_lock);</div><div class="line">retval = add_uevent_var(env, <span class="string">"SEQNUM=%llu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)seq);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> <span class="built_in">exit</span>;</div></pre></td></tr></table></figure></p>
<p>在这里还会调用<code>kobject-&gt;kset-&gt;uevent_ops-&gt;uevent()</code>，让产生事件的<code>kobject</code>添加环境变量，最后将事件序列添加到环境变量中去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_NET)</span></div><div class="line">     <span class="comment">/* send netlink message */</span></div><div class="line">     <span class="keyword">if</span> (uevent_sock) &#123;</div><div class="line">         <span class="keyword">struct</span> sk_buff *skb;</div><div class="line">         <span class="keyword">size_t</span> len;</div><div class="line"></div><div class="line">         <span class="comment">/* allocate message with the maximum possible size */</span></div><div class="line">         len = <span class="built_in">strlen</span>(action_string) + <span class="built_in">strlen</span>(devpath) + <span class="number">2</span>;</div><div class="line">         skb = alloc_skb(len + env-&gt;buflen, GFP_KERNEL);</div><div class="line">         <span class="keyword">if</span> (skb) &#123;</div><div class="line">              <span class="keyword">char</span> *scratch;</div><div class="line"></div><div class="line">              <span class="comment">/* add header */</span></div><div class="line">              scratch = skb_put(skb, len);</div><div class="line">              <span class="built_in">sprintf</span>(scratch, <span class="string">"%s@%s"</span>, action_string, devpath);</div><div class="line"></div><div class="line">              <span class="comment">/* copy keys to our continuous event payload buffer */</span></div><div class="line">              <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; env-&gt;envp_idx; i++) &#123;</div><div class="line">                   len = <span class="built_in">strlen</span>(env-&gt;envp[i]) + <span class="number">1</span>;</div><div class="line">                   scratch = skb_put(skb, len);</div><div class="line">                   <span class="built_in">strcpy</span>(scratch, env-&gt;envp[i]);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              NETLINK_CB(skb).dst_group = <span class="number">1</span>;</div><div class="line">              netlink_broadcast(uevent_sock, skb, <span class="number">0</span>, <span class="number">1</span>, GFP_KERNEL);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">     <span class="comment">/* call uevent_helper, usually only enabled during early boot */</span></div><div class="line">     <span class="keyword">if</span> (uevent_helper[<span class="number">0</span>]) &#123;</div><div class="line">         <span class="keyword">char</span> *argv [<span class="number">3</span>];</div><div class="line"></div><div class="line">         argv [<span class="number">0</span>] = uevent_helper;</div><div class="line">         argv [<span class="number">1</span>] = (<span class="keyword">char</span> *)subsystem;</div><div class="line">         argv [<span class="number">2</span>] = <span class="literal">NULL</span>;</div><div class="line">         retval = add_uevent_var(env, <span class="string">"HOME=/"</span>);</div><div class="line">         <span class="keyword">if</span> (retval)</div><div class="line">              <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line">         retval = add_uevent_var(env,</div><div class="line">                        <span class="string">"PATH=/sbin:/bin:/usr/sbin:/usr/bin"</span>);</div><div class="line">         <span class="keyword">if</span> (retval)</div><div class="line">              <span class="keyword">goto</span> <span class="built_in">exit</span>;</div><div class="line"></div><div class="line">         call_usermodehelper(argv[<span class="number">0</span>], argv, env-&gt;envp, UMH_WAIT_EXEC);</div><div class="line">     &#125;</div><div class="line"></div><div class="line"><span class="built_in">exit</span>:</div><div class="line">     kfree(devpath);</div><div class="line">     kfree(env);</div><div class="line">     <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>忽略一段选择编译的代码，再后就是调用用户空间的<code>hotplug</code>了。添加最后两个环境变量：<code>HOME</code>和<code>PATH</code>。然后调用<code>hotplug</code>，以子系统名称为参数。<br>现在我们终于知道<code>hotplug</code>处理程序中的参数和环境变量是怎么来的了.^_^</p>
<p>使用完了<code>kset</code>，再调用<code>kset_unregister()</code>将其注销。这个函数很简单,请自行查阅代码.<br>为了印证一下上面的分析，写一个测试模块。如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sysfs.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/stat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kobject.h&gt;</span></span></div><div class="line"></div><div class="line">MODULE_AUTHOR(<span class="string">"eric xiao"</span>);</div><div class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_filter</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj)</span></span>;</div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">kset_name</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_uevent</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</span></span></div><div class="line">                      <span class="keyword">struct</span> kobj_uevent_env *env);</div><div class="line"></div><div class="line"><span class="keyword">struct</span> kset kset_p;</div><div class="line"><span class="keyword">struct</span> kset kset_c;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> kset_uevent_ops uevent_ops =</div><div class="line">&#123;</div><div class="line">        .filter = kset_filter,</div><div class="line">        .name   = kset_name,</div><div class="line">        .uevent = kset_uevent,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_filter</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"UEVENT: filter. kobj %s.\n"</span>,kobj-&gt;name);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">kset_name</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">20</span>];</div><div class="line">        printk(<span class="string">"UEVENT: name. kobj %s.\n"</span>,kobj-&gt;name);</div><div class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">"%s"</span>,<span class="string">"kset_test"</span>);</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_uevent</span><span class="params">(<span class="keyword">struct</span> kset *kset, <span class="keyword">struct</span> kobject *kobj,</span></span></div><div class="line">                      <span class="keyword">struct</span> kobj_uevent_env *env)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        printk(<span class="string">"UEVENT: uevent. kobj %s.\n"</span>,kobj-&gt;name);</div><div class="line"></div><div class="line">        <span class="keyword">while</span>( i&lt; env-&gt;envp_idx)&#123;</div><div class="line">                printk(<span class="string">"%s.\n"</span>,env-&gt;envp[i]);</div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_test_init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"kset test init.\n"</span>);</div><div class="line">        kobject_set_name(&amp;kset_p.kobj,<span class="string">"kset_p"</span>);</div><div class="line">        kset_p.uevent_ops = &amp;uevent_ops;</div><div class="line">        kset_register(&amp;kset_p);</div><div class="line"></div><div class="line">       kobject_set_name(&amp;kset_c.kobj,<span class="string">"kset_c"</span>);</div><div class="line">        kset_c.kobj.kset = &amp;kset_p;</div><div class="line">        kset_register(&amp;kset_c);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kset_test_exit</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"kset test exit.\n"</span>);</div><div class="line">        kset_unregister(&amp;kset_p);</div><div class="line">        kset_unregister(&amp;kset_c);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init(kset_test_init);</div><div class="line">module_exit(kset_test_exit);</div></pre></td></tr></table></figure></p>
<p>在这里，定义并注册了二个<code>kset</code>，第二个<code>kset</code>的<code>kobj-&gt;kset</code>域指向第一个<code>kset</code>。这样，当第二个<code>kset</code>注册或者卸载的时候就会调用第一个<code>kset</code>中的<code>uevent_ops</code>的相关操作.<br><code>kset_p.uevent_ops-&gt;filter</code>函数中，使其返回<code>1</code>.使其匹配成功。<br>在<code>kset_p.uevent_ops-&gt;name</code>中，使其返回的子系统名为引起事件的<code>kobject</code>的名称，即：<code>kset_c</code>.<br>最后在<code>kset_p.uevent_ops-&gt;uevent</code>中将环境变量全部打印出来。<br>下面是<code>dmesg</code>的输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">kset test init.</div><div class="line">UEVENT: filter. kobj kset_c.</div><div class="line">UEVENT: name. kobj kset_c.</div><div class="line">UEVENT: uevent. kobj kset_c.</div><div class="line">ACTION=add.</div><div class="line">DEVPATH=/kset_p/kset_c.</div><div class="line">SUBSYSTEM=kset_test.</div></pre></td></tr></table></figure></p>
<p>输出结果跟我们的分析是吻合的，在这里，值得我们注意的是：注册一个<code>kobject</code>不会产生事件，只有注册<code>kset</code>才会。</p>
<h2 id="四：bus、device和device-driver"><a href="#四：bus、device和device-driver" class="headerlink" title="四：bus、device和device_driver"></a><a name="4">四：bus、device和device_driver</a></h2><p>上面分析了<code>kobject</code>、<code>kset</code>、<code>ktype</code>，这三个结构联合起来一起构成了整个设备模型的基石。而<code>bus</code>、<code>device</code>、<code>device_driver</code>，则是基于<code>kobject</code>、<code>kset</code>、<code>ktype</code>之上的架构。在这里,总线、设备、驱动被有序的组合在一起。<code>bus</code>、<code>device</code>、<code>device_driver</code>三者之间的关系如下图所示:</p>
<img src="/kernel/设备驱动/probe-of-linux-kernel-driver-module/bus-device-driver.jpg" alt="bus-device-driver.jpg" title="">
<p>如上图所示，<code>struct bus_type</code>的<code>p-&gt;drivers_kset</code>指向注册在上面的驱动程序，它的<code>p-&gt;device_kset</code>上挂着注册在上面的设备。每次有一个新的设备注册到上面，都会去匹配右边的驱动，看是否能匹配上。如果匹配成功，则将设备结构的<code>is_registerd</code>域置为<code>0</code>，然后将设备添加到驱动的<code>p-&gt;klist_devices</code>域。同理,每注册一个驱动,都会去匹配左边的设备。如果匹配成功,将则设备加到驱动的<code>p-&gt;klist_devices</code>域，再将设备的<code>is_registerd</code>置为<code>0</code>。<br>这就是linux设备模型用来管理设备和驱动的基本架构，我们来跟踪一下代码来看下详细的操作。</p>
<h3 id="总线注册"><a href="#总线注册" class="headerlink" title="总线注册"></a><a name="4.1">总线注册</a></h3><p>注册一个总线的接口为<code>bus_register()</code>，我们照例分段分析:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_register</span><span class="params">(<span class="keyword">struct</span> bus_type *bus)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> retval;</div><div class="line">     <span class="keyword">struct</span> bus_type_private *priv;</div><div class="line"></div><div class="line">     priv = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bus_type_private), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (!priv)</div><div class="line">         <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">     priv-&gt;bus = bus;</div><div class="line">     bus-&gt;p = priv;</div><div class="line"></div><div class="line">     BLOCKING_INIT_NOTIFIER_HEAD(&amp;priv-&gt;bus_notifier);</div><div class="line"></div><div class="line">     retval = kobject_set_name(&amp;priv-&gt;subsys.kobj, <span class="string">"%s"</span>, bus-&gt;name);</div><div class="line">     <span class="keyword">if</span> (retval)</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">     priv-&gt;subsys.kobj.kset = bus_kset;</div><div class="line">     priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</div><div class="line">     priv-&gt;drivers_autoprobe = <span class="number">1</span>;</div><div class="line"></div><div class="line">     retval = kset_register(&amp;priv-&gt;subsys);</div><div class="line">     <span class="keyword">if</span> (retval)</div><div class="line">         <span class="keyword">goto</span> out;</div></pre></td></tr></table></figure></p>
<p>首先,先为<code>struct bus_type</code>的私有区分配空间,然后将其和<code>struct bus_type</code>关联起来。由于<code>struct bus_type</code>也要在<code>sysfs</code>文件中表示一个节点,因此,它也内嵌一个<code>kset</code>的结构，这就是<code>priv-&gt;subsys</code>。</p>
<p>首先,它为这个<code>kset</code>的名称赋值为<code>bus</code>的名称，然后将<code>priv-&gt;subsys.kobj.kset</code>指向<code>bus_kset</code>，<code>priv-&gt;subsys.kobj.ktype</code>指向<code>bus_ktype</code>;然后调用<code>kset_reqister()</code>将<code>priv-&gt;subsys</code>注册。这里涉及到的接口都在之前分析过，注册过后，应该会在<code>bus_kset</code>所表示的目录下创建一个总线名称的目录，并且用户空间的<code>hotplug</code>应该会检测到一个<code>add</code>事件。我们来看一下<code>bus_kset</code>到底指向的是什么:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bus_kset = kset_create_and_add(<span class="string">"bus"</span>, &amp;bus_uevent_ops, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p>从此可以看出，这个<code>bus_kset</code>在<code>sysfs</code>中的结点就是<code>/sys/bus</code>，在这里注册的<code>struct bus_types</code>就会在<code>/sys/bus/</code>下面出现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">retval = bus_create_file(bus, &amp;bus_attr_uevent);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> bus_uevent_fail;</div></pre></td></tr></table></figure></p>
<p><code>bus_create_file()</code>就是在<code>priv-&gt;subsys.kobj</code>的这个<code>kobject</code>上建立一个普通属性的文件，这个文件的属性对应在<code>bus_attr_uevent</code>，读写操作对应在<code>priv-&gt;subsys.ktype</code>中，我们到后面才统一分析<code>bus</code>注册时候的文件创建。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">priv-&gt;devices_kset = kset_create_and_add(<span class="string">"devices"</span>, <span class="literal">NULL</span>,</div><div class="line">                        &amp;priv-&gt;subsys.kobj);</div><div class="line"><span class="keyword">if</span> (!priv-&gt;devices_kset) &#123;</div><div class="line">    retval = -ENOMEM;</div><div class="line">    <span class="keyword">goto</span> bus_devices_fail;</div><div class="line">&#125;</div><div class="line"></div><div class="line">priv-&gt;drivers_kset = kset_create_and_add(<span class="string">"drivers"</span>, <span class="literal">NULL</span>,</div><div class="line">                        &amp;priv-&gt;subsys.kobj);</div><div class="line"><span class="keyword">if</span> (!priv-&gt;drivers_kset) &#123;</div><div class="line">    retval = -ENOMEM;</div><div class="line">    <span class="keyword">goto</span> bus_drivers_fail;</div><div class="line">&#125;</div><div class="line"></div><div class="line">klist_init(&amp;priv-&gt;klist_devices, klist_devices_get, klist_devices_put);</div><div class="line">klist_init(&amp;priv-&gt;klist_drivers, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p>这段代码会在<code>bus</code>所在的目录下建立两个目录，分别为<code>devices</code>和<code>drivers</code>，并初始化挂载设备和驱动的链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">retval = add_probe_files(bus);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> bus_probe_files_fail;</div><div class="line"></div><div class="line">retval = bus_add_attrs(bus);</div><div class="line"><span class="keyword">if</span> (retval)</div><div class="line">    <span class="keyword">goto</span> bus_attrs_fail;</div><div class="line"></div><div class="line">pr_debug(<span class="string">"bus: '%s': registered\n"</span>, bus-&gt;name);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>在这里,会为<code>bus_attr_drivers_probe</code>, <code>bus_attr_drivers_autoprobe</code>.注册<code>bus_type</code>中的属性建立文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">bus_attrs_fail:</div><div class="line">     remove_probe_files(bus);</div><div class="line">bus_probe_files_fail:</div><div class="line">     kset_unregister(bus-&gt;p-&gt;drivers_kset);</div><div class="line">bus_drivers_fail:</div><div class="line">     kset_unregister(bus-&gt;p-&gt;devices_kset);</div><div class="line">bus_devices_fail:</div><div class="line">     bus_remove_file(bus, &amp;bus_attr_uevent);</div><div class="line">bus_uevent_fail:</div><div class="line">     kset_unregister(&amp;bus-&gt;p-&gt;subsys);</div><div class="line">     kfree(bus-&gt;p);</div><div class="line">out:</div><div class="line">     <span class="keyword">return</span> retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码为出错处理</p>
<p>这段代码中比较繁锁的就是<code>bus_type</code>对应目录下的属性文件建立,为了直观的说明,将属性文件的建立统一放到一起分析。从上面的代码中可以看,创建属性文件对应的属性分别为:<code>bus_attr_uevent</code>、<code>bus_attr_drivers_probe</code>、<code>bus_attr_drivers_autoprobe</code>。<br>分别定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">BUS_ATTR</span><span class="params">(uevent, S_IWUSR, <span class="literal">NULL</span>, bus_uevent_store)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">BUS_ATTR</span><span class="params">(drivers_probe, S_IWUSR, <span class="literal">NULL</span>, store_drivers_probe)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">BUS_ATTR</span><span class="params">(drivers_autoprobe, S_IWUSR | S_IRUGO,</span></span></div><div class="line">         show_drivers_autoprobe, store_drivers_autoprobe);</div></pre></td></tr></table></figure></p>
<p><code>BUS_ATTR</code>定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR(_name, _mode, _show, _store)  \</span></div><div class="line">struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __ATTR(_name,_mode,_show,_store) &#123; \</span></div><div class="line">     .attr = &#123;.name = __stringify(_name), .mode = _mode &#125;,   \</div><div class="line">     .show    = _show,                    \</div><div class="line">     .store   = _store,                   \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可见.上面这三个属性对应的名称为别为<code>uevent</code>、<code>drivers_probe</code>、<code>drivers_autoprobe</code>。也就是说，会在<code>bus_types</code>目录下生成三个文件，分别为<code>uevent</code>、<code>probe</code>、<code>autoprobe</code>。<br>根据之前的分析,我们知道在<code>sysfs</code>文件系统中,对普通属性文件的读写都会回溯到<code>kobject-&gt;ktype-&gt;sysfs_ops</code>中.在这里,注意到有:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">priv-&gt;subsys.kobj.kset = bus_kset;</div><div class="line">priv-&gt;subsys.kobj.ktype = &amp;bus_ktype;</div></pre></td></tr></table></figure></p>
<p>显然,读写操作就回溯到了<code>bus_ktype</code>中.定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kobj_type bus_ktype = &#123;</div><div class="line">     .sysfs_ops    = &amp;bus_sysfs_ops,</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> sysfs_ops bus_sysfs_ops = &#123;</div><div class="line">     .show    = bus_attr_show,</div><div class="line">     .store   = bus_attr_store,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>show</code>和<code>store</code>函数对应的代码为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">bus_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                   <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_attribute *bus_attr = to_bus_attr(attr);</div><div class="line">     <span class="keyword">struct</span> bus_type_private *bus_priv = to_bus(kobj);</div><div class="line">     <span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (bus_attr-&gt;show)</div><div class="line">         ret = bus_attr-&gt;show(bus_priv-&gt;bus, buf);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">bus_attr_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span></div><div class="line">                    <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_attribute *bus_attr = to_bus_attr(attr);</div><div class="line">     <span class="keyword">struct</span> bus_type_private *bus_priv = to_bus(kobj);</div><div class="line">     <span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (bus_attr-&gt;store)</div><div class="line">         ret = bus_attr-&gt;store(bus_priv-&gt;bus, buf, count);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码可以看出.读写操作又会回溯到<code>bus_attribute</code>中的<code>show</code>和<code>store</code>中.在自定义结构里嵌入<code>struct attribute</code>,.然后再操作回溯到自定义结构中,这是一种比较高明的架构设计手法.</p>
<p>闲言少叙.我们对应看一下上面三个文件对应的最终操作:<br><code>uevent</code>对应的读写操作为：<code>NULL</code>、<code>bus_uevent_store</code>。对于这个文件没有读操作，只有写操作，用<code>cat</code> 命令去查看这个文件的时候,可能会返回“设备不存在”的错误。<br><code>bus_uevent_store()</code>代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">bus_uevent_store</span><span class="params">(<span class="keyword">struct</span> bus_type *bus,</span></span></div><div class="line">                   <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">enum</span> kobject_action action;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (kobject_action_type(buf, count, &amp;action) == <span class="number">0</span>)</div><div class="line">         kobject_uevent(&amp;bus-&gt;p-&gt;subsys.kobj, action);</div><div class="line">     <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看到,可以在用户空间控制事件的发生,如<code>echo add &gt; event</code>就会产生一个<code>add</code>的事件。</p>
<p><code>probe</code>文件对应的读写操作为：<code>NULL</code>、<code>store_drivers_probe</code>。 <code>store_drivers_probe()</code>这个函数的代码涉及到<code>struct device</code>，等分析完<code>struct device</code>可以自行回过来看下这个函数的实现。实际上,这个函数是将用户输入的设备名称对应的设备与驱动匹配一次。</p>
<p><code>autoprobe</code>文件对应的读写操作为<code>show_drivers_autoprobe</code>, <code>store_drivers_autoprobe</code>.对应读的代码为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">show_drivers_autoprobe</span><span class="params">(<span class="keyword">struct</span> bus_type *bus, <span class="keyword">char</span> *buf)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%d\n"</span>, bus-&gt;p-&gt;drivers_autoprobe);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它将总线对应的<code>drivers_autoprobe</code>的值输出到用户空间，这个值为<code>1</code>时，自动将驱动与设备进行匹配，否则，反之。</p>
<p>写操作的代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">store_drivers_autoprobe</span><span class="params">(<span class="keyword">struct</span> bus_type *bus,</span></span></div><div class="line">                          <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'0'</span>)</div><div class="line">         bus-&gt;p-&gt;drivers_autoprobe = <span class="number">0</span>;</div><div class="line">     <span class="keyword">else</span></div><div class="line">         bus-&gt;p-&gt;drivers_autoprobe = <span class="number">1</span>;</div><div class="line">     <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写操作就会改变<code>bus-&gt;p-&gt;drivers_autoprobe</code>的值，就这样，通过<code>sysfs</code>就可以控制总线是否要进行自动匹配了。<br>从这里也可以看出，内核开发者的思维是何等的灵活。我们从<code>sysfs</code>中找个例子来印证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span>  / sys/bus/usb</div></pre></td></tr></table></figure></p>
<p>用ls命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devices  drivers  drivers_autoprobe  drivers_probe  uevent</div></pre></td></tr></table></figure></p>
<p>与上面分析的相吻合</p>
<h3 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a><a name="4.2">设备注册</a></h3><p>设备的注册接口为: <code>device_register()</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_register</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     device_initialize(dev);</div><div class="line">     <span class="keyword">return</span> device_add(dev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>device_initialize()</code>中有几个很重要的操作,如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_initialize</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     dev-&gt;kobj.kset = devices_kset;</div><div class="line">     kobject_init(&amp;dev-&gt;kobj, &amp;device_ktype);</div><div class="line">     klist_init(&amp;dev-&gt;klist_children, klist_children_get,</div><div class="line">            klist_children_put);</div><div class="line">     INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);</div><div class="line">     INIT_LIST_HEAD(&amp;dev-&gt;node);</div><div class="line">     init_MUTEX(&amp;dev-&gt;sem);</div><div class="line">     spin_lock_init(&amp;dev-&gt;devres_lock);</div><div class="line">     INIT_LIST_HEAD(&amp;dev-&gt;devres_head);</div><div class="line">     device_init_wakeup(dev, <span class="number">0</span>);</div><div class="line">     set_dev_node(dev, <span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里,它为<code>device</code>的内嵌<code>kobject</code>指定了<code>ktype</code>和<code>kset</code>。<code>device_kset</code>的值如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devices_kset = kset_create_and_add(<span class="string">"devices"</span>, &amp;device_uevent_ops, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p>即对应<code>sysfs</code>中的<code>/sys/devices</code>。<br><code>device_ktype</code>中对属性的读写操作同<code>bus</code>中的类似,被回溯到了<code>struct device_attribute</code>中的<code>show</code>和<code>store</code>。</p>
<p>接着往下看<code>device_add()</code>的实现.这个函数比较长,分段分析如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_add</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> device *parent = <span class="literal">NULL</span>;</div><div class="line">     <span class="keyword">struct</span> class_interface *class_intf;</div><div class="line">     <span class="keyword">int</span> error;</div><div class="line"></div><div class="line">     dev = get_device(dev);</div><div class="line">     <span class="keyword">if</span> (!dev || !<span class="built_in">strlen</span>(dev-&gt;bus_id)) &#123;</div><div class="line">         error = -EINVAL;</div><div class="line">         <span class="keyword">goto</span> Done;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     pr_debug(<span class="string">"device: '%s': %s\n"</span>, dev-&gt;bus_id, __FUNCTION__);</div><div class="line"></div><div class="line">     parent = get_device(dev-&gt;parent);</div><div class="line">     setup_parent(dev, parent);</div><div class="line"></div><div class="line">     <span class="comment">/* first, register with generic layer. */</span></div><div class="line">     error = kobject_add(&amp;dev-&gt;kobj, dev-&gt;kobj.parent, <span class="string">"%s"</span>, dev-&gt;bus_id);</div><div class="line">     <span class="keyword">if</span> (error)</div><div class="line">         <span class="keyword">goto</span> Error;</div></pre></td></tr></table></figure></p>
<p>如果注册<code>device</code>的时候,没有指定父结点,在<code>kobject_add</code>将会在<code>/sys/device/</code>下建立相同名称的目录<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* notify platform of device entry */</span></div><div class="line"><span class="keyword">if</span> (platform_notify)</div><div class="line">    platform_notify(dev);</div><div class="line"></div><div class="line"><span class="comment">/* notify clients of device entry (new way) */</span></div><div class="line"><span class="keyword">if</span> (dev-&gt;bus)</div><div class="line">    blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</div><div class="line">                       BUS_NOTIFY_ADD_DEVICE, dev);</div></pre></td></tr></table></figure></p>
<p>忽略<code>notify</code>部份,这部份不会影响本函数的流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">error = device_create_file(dev, &amp;uevent_attr);</div><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> attrError;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (MAJOR(dev-&gt;devt)) &#123;</div><div class="line">    error = device_create_file(dev, &amp;devt_attr);</div><div class="line">    <span class="keyword">if</span> (error)</div><div class="line">         <span class="keyword">goto</span> ueventattrError;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建立属性为<code>uevent_attr</code>的属性文件,如果<code>device</code>中指定了设备号,则建立属性为<code>devt_attr</code>的属性文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">error = device_add_class_symlinks(dev);</div><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> SymlinkError;</div><div class="line">error = device_add_attrs(dev);</div><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> AttrsError;</div><div class="line">error = dpm_sysfs_add(dev);</div><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> PMError;</div><div class="line">device_pm_add(dev);</div></pre></td></tr></table></figure></p>
<p>在这里,不打算讨论<code>class</code>的部份,<code>dpm</code>、<code>pm</code>是选择编译部份,不讨论.<code>device_add_attrs</code>中涉及到了<code>group</code>的部分,暂不讨论<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">error = bus_add_device(dev);</div><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> BusError;</div><div class="line">kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</div><div class="line">bus_attach_device(dev);</div><div class="line"><span class="keyword">if</span> (parent)</div><div class="line">    klist_add_tail(&amp;dev-&gt;knode_parent, &amp;parent-&gt;klist_children);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (dev-&gt;<span class="keyword">class</span>) &#123;</div><div class="line">    down(&amp;dev-&gt;<span class="keyword">class</span>-&gt;sem);</div><div class="line">    <span class="comment">/* tie the class to the device */</span></div><div class="line">    list_add_tail(&amp;dev-&gt;node, &amp;dev-&gt;<span class="keyword">class</span>-&gt;devices);</div><div class="line"></div><div class="line">    <span class="comment">/* notify any interfaces that the device is here */</span></div><div class="line">    list_for_each_entry(class_intf, &amp;dev-&gt;<span class="keyword">class</span>-&gt;interfaces, node)</div><div class="line">         <span class="keyword">if</span> (class_intf-&gt;add_dev)</div><div class="line">              class_intf-&gt;add_dev(dev, class_intf);</div><div class="line">    up(&amp;dev-&gt;<span class="keyword">class</span>-&gt;sem);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>bus_add_device()</code>在对应总线代表目录的<code>device</code>目录下创建几个到<code>device</code>的链接，然后调用<code>kobject_uevent()</code>产生一个<code>add</code>事件，再调用<code>bus_attach_device()</code>去匹配已经注册到总线的驱动程序。全部做完之后，将设备挂到父结点的子链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> Done:</div><div class="line">     put_device(dev);</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line"> BusError:</div><div class="line">     device_pm_remove(dev);</div><div class="line"> PMError:</div><div class="line">     <span class="keyword">if</span> (dev-&gt;bus)</div><div class="line">         blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</div><div class="line">                            BUS_NOTIFY_DEL_DEVICE, dev);</div><div class="line">     device_remove_attrs(dev);</div><div class="line"> AttrsError:</div><div class="line">     device_remove_class_symlinks(dev);</div><div class="line"> SymlinkError:</div><div class="line">     <span class="keyword">if</span> (MAJOR(dev-&gt;devt))</div><div class="line">         device_remove_file(dev, &amp;devt_attr);</div><div class="line"> ueventattrError:</div><div class="line">     device_remove_file(dev, &amp;uevent_attr);</div><div class="line"> attrError:</div><div class="line">     kobject_uevent(&amp;dev-&gt;kobj, KOBJ_REMOVE);</div><div class="line">     kobject_del(&amp;dev-&gt;kobj);</div><div class="line"> Error:</div><div class="line">     cleanup_device_parent(dev);</div><div class="line">     <span class="keyword">if</span> (parent)</div><div class="line">         put_device(parent);</div><div class="line">     <span class="keyword">goto</span> Done;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>出错处理部份.</p>
<p><code>bus_attach_device()</code>是一个很重要的函数。它将设备自动与挂在总线上面的驱动进行匹配。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bus_attach_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_type *bus = dev-&gt;bus;</div><div class="line">     <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (bus) &#123;</div><div class="line">         dev-&gt;is_registered = <span class="number">1</span>;</div><div class="line">         <span class="keyword">if</span> (bus-&gt;p-&gt;drivers_autoprobe)</div><div class="line">              ret = device_attach(dev);</div><div class="line">         WARN_ON(ret &lt; <span class="number">0</span>);</div><div class="line">         <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</div><div class="line">              klist_add_tail(&amp;dev-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);</div><div class="line">         <span class="keyword">else</span></div><div class="line">              dev-&gt;is_registered = <span class="number">0</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码我们可以看出。只有在<code>bus-&gt;p-&gt;drivers_autoprobe</code>为<code>1</code>的情况下，才会去自己匹配。这也就是<code>bus</code>目录下的<code>drivers_probe</code> 文件的作用.然后，将设备挂到总线的设备链表。<br><code>device_attach()</code>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">device_attach</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     down(&amp;dev-&gt;sem);</div><div class="line">     <span class="keyword">if</span> (dev-&gt;driver) &#123;</div><div class="line">         ret = device_bind_driver(dev);</div><div class="line">         <span class="keyword">if</span> (ret == <span class="number">0</span>)</div><div class="line">              ret = <span class="number">1</span>;</div><div class="line">         <span class="keyword">else</span> &#123;</div><div class="line">              dev-&gt;driver = <span class="literal">NULL</span>;</div><div class="line">              ret = <span class="number">0</span>;</div><div class="line">         &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         ret = bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, dev, __device_attach);</div><div class="line">     &#125;</div><div class="line">     up(&amp;dev-&gt;sem);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于设备自己已经指定驱动的情况，只需要将其直接和驱动绑定即可。如果没有指定驱动,就匹配总线之上的驱动，这是在<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bus_for_each_drv(dev-&gt;bus, <span class="literal">NULL</span>, dev, __device_attach);</div></pre></td></tr></table></figure></p>
<p>完成的。代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,</div><div class="line">              void *data, int (*fn)(struct device_driver *, void *))</div><div class="line">&#123;</div><div class="line">     struct klist_iter i;</div><div class="line">     struct device_driver *drv;</div><div class="line">     int error = 0;</div><div class="line"></div><div class="line">     if (!bus)</div><div class="line">         return -EINVAL;</div><div class="line"></div><div class="line">     klist_iter_init_node(&amp;bus-&gt;p-&gt;klist_drivers, &amp;i,</div><div class="line">                   start ? &amp;start-&gt;p-&gt;knode_bus : NULL);</div><div class="line">     while ((drv = next_driver(&amp;i)) &amp;&amp; !error)</div><div class="line">         error = fn(drv, data);</div><div class="line">     klist_iter_exit(&amp;i);</div><div class="line">     return error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，这个函数就是遍历总线之上的驱动。每遍历一个驱动就调用一次回调函数进行判断，如果回调函数返回不为<code>0</code>，就说明匹配已经成功了，不需要再匹配剩余的，退出。在这里调用的回调函数是<code>__device_attach()</code>，在这里，完成了设备与驱动匹配的最核心的动作。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __device_attach(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> device *dev = data;</div><div class="line">     <span class="keyword">return</span> driver_probe_device(drv, dev);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>转到<code>driver_probe_device()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_probe_device</span><span class="params">(<span class="keyword">struct</span> device_driver *drv, <span class="keyword">struct</span> device *dev)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (!device_is_registered(dev))</div><div class="line">         <span class="keyword">return</span> -ENODEV;</div><div class="line">     <span class="keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))</div><div class="line">         <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line">     pr_debug(<span class="string">"bus: '%s': %s: matched device %s with driver %s\n"</span>,</div><div class="line">          drv-&gt;bus-&gt;name, __FUNCTION__, dev-&gt;bus_id, drv-&gt;name);</div><div class="line"></div><div class="line">     ret = really_probe(dev, drv);</div><div class="line"></div><div class="line">done:</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果设备没有注册到总线之上，即<code>dev-&gt;is_registered</code>不为<code>1</code>， 就直接返回。然后，再调用总线的<code>match()</code>函数进行匹配。如果<code>match()</code>函数返回<code>0</code>，说明匹配失败，那退出此函数。如果<code>match</code>函数返回<code>1</code>，说明初步的检查已经通过了，可以进入<code>really_probe()</code>再进行细致的检查。如果匹配成功，这个函数会返回<code>1</code>。此函数比较长而且比较重要，分段列出代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">really_probe</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"></div><div class="line">     atomic_inc(&amp;probe_count);</div><div class="line">     pr_debug(<span class="string">"bus: '%s': %s: probing driver %s with device %s\n"</span>,</div><div class="line">          drv-&gt;bus-&gt;name, __FUNCTION__, drv-&gt;name, dev-&gt;bus_id);</div><div class="line">     WARN_ON(!list_empty(&amp;dev-&gt;devres_head));</div><div class="line"></div><div class="line">     dev-&gt;driver = drv;</div><div class="line">     <span class="keyword">if</span> (driver_sysfs_add(dev)) &#123;</div><div class="line">         printk(KERN_ERR <span class="string">"%s: driver_sysfs_add(%s) failed\n"</span>,</div><div class="line">              __FUNCTION__, dev-&gt;bus_id);</div><div class="line">         <span class="keyword">goto</span> probe_failed;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>先假设驱动和设备是匹配的，为设备结构设置驱动成员，使其指向匹配的驱动，然后再调用<code>driver_sysfs_add()</code>建立几个符号链接。这几个链接分别为：<br>1、在驱动目录下建立一个到设备的同名链接；<br>2、在设备目录下建立一个名为driver到驱动的链接。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</div><div class="line">    ret = dev-&gt;bus-&gt;probe(dev);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">         <span class="keyword">goto</span> probe_failed;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</div><div class="line">    ret = drv-&gt;probe(dev);</div><div class="line">    <span class="keyword">if</span> (ret)</div><div class="line">         <span class="keyword">goto</span> probe_failed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，再调用总线的<code>probe</code>函数，如果总线的此函数不存在，就会调用驱动的<code>probe</code>函数。如果匹配成功，返回<code>0</code>；如果不成功，就会跳转到<code>probe_failed</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">driver_bound(dev);</div><div class="line">ret = <span class="number">1</span>;</div><div class="line">pr_debug(<span class="string">"bus: '%s': %s: bound device %s to driver %s\n"</span>,</div><div class="line">     drv-&gt;bus-&gt;name, __FUNCTION__, dev-&gt;bus_id, drv-&gt;name);</div><div class="line"><span class="keyword">goto</span> done;</div></pre></td></tr></table></figure></p>
<p>到这里，设备和驱动已经匹配成功，调用<code>driver_bound()</code>将其关联起来，在这个函数里会将设备加至驱动的设备链表，这在我们之前分析<code>bus</code>、<code>device</code>、<code>driver</code>中分析到的。相关的代码如下示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">klist_add_tail(&amp;dev-&gt;knode_driver, &amp;dev-&gt;driver-&gt;p-&gt;klist_devices);</div></pre></td></tr></table></figure></p>
<p>至此，这个匹配过程已经圆满结束了，返回<code>1</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">probe_failed:</div><div class="line">     devres_release_all(dev);</div><div class="line">     driver_sysfs_remove(dev);</div><div class="line">     dev-&gt;driver = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (ret != -ENODEV &amp;&amp; ret != -ENXIO) &#123;</div><div class="line">         <span class="comment">/* driver matched but the probe failed */</span></div><div class="line">         printk(KERN_WARNING</div><div class="line">                <span class="string">"%s: probe of %s failed with error %d\n"</span>,</div><div class="line">                drv-&gt;name, dev-&gt;bus_id, ret);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">/*</span></div><div class="line">      * Ignore errors returned by -&gt;probe so that the next driver can try</div><div class="line">      * its luck.</div><div class="line">      */</div><div class="line">     ret = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>这里是匹配不成功的处理，在这里，删除之前建立的几个链接文件，然后将设备的<code>driver</code>域置空。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">done:</div><div class="line">     atomic_dec(&amp;probe_count);</div><div class="line">     wake_up(&amp;probe_waitqueue);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的分析可以看到，对应创建的属性文件分别为：<code>uevent_attr</code>, <code>devt_attr</code>。它们的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> device_attribute uevent_attr =</div><div class="line">     __ATTR(uevent, S_IRUGO | S_IWUSR, show_uevent, store_uevent);</div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> device_attribute devt_attr =</div><div class="line">     __ATTR(dev, S_IRUGO, show_dev, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure></p>
<p><code>uevent_attr</code>对应的读写函数分别为：<code>show_uevent</code>、<code>store_uevent</code>。先分析读操作。它的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">show_uevent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span></div><div class="line">                 <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> kobject *top_kobj;</div><div class="line">     <span class="keyword">struct</span> kset *kset;</div><div class="line">     <span class="keyword">struct</span> kobj_uevent_env *env = <span class="literal">NULL</span>;</div><div class="line">     <span class="keyword">int</span> i;</div><div class="line">     <span class="keyword">size_t</span> count = <span class="number">0</span>;</div><div class="line">     <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">     <span class="comment">/* search the kset, the device belongs to */</span></div><div class="line">     top_kobj = &amp;dev-&gt;kobj;</div><div class="line">     <span class="keyword">while</span> (!top_kobj-&gt;kset &amp;&amp; top_kobj-&gt;parent)</div><div class="line">         top_kobj = top_kobj-&gt;parent;</div><div class="line">     <span class="keyword">if</span> (!top_kobj-&gt;kset)</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">     kset = top_kobj-&gt;kset;</div><div class="line">     <span class="keyword">if</span> (!kset-&gt;uevent_ops || !kset-&gt;uevent_ops-&gt;uevent)</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">     <span class="comment">/* respect filter */</span></div><div class="line">     <span class="keyword">if</span> (kset-&gt;uevent_ops &amp;&amp; kset-&gt;uevent_ops-&gt;filter)</div><div class="line">         <span class="keyword">if</span> (!kset-&gt;uevent_ops-&gt;filter(kset, &amp;dev-&gt;kobj))</div><div class="line">              <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">     env = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kobj_uevent_env), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (!env)</div><div class="line">         <span class="keyword">return</span> -ENOMEM;</div><div class="line"></div><div class="line">     <span class="comment">/* let the kset specific function add its keys */</span></div><div class="line">     retval = kset-&gt;uevent_ops-&gt;uevent(kset, &amp;dev-&gt;kobj, env);</div><div class="line">     <span class="keyword">if</span> (retval)</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">     <span class="comment">/* copy keys to file */</span></div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; env-&gt;envp_idx; i++)</div><div class="line">         count += <span class="built_in">sprintf</span>(&amp;buf[count], <span class="string">"%s\n"</span>, env-&gt;envp[i]);</div><div class="line">out:</div><div class="line">     kfree(env);</div><div class="line">     <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码可以看出，这里会显示出由设备对应的<code>kset</code>，也就是由<code>devices_kset</code>所产生的环境变量。例如，在shell中输入如下指令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /sys/devices/LNXSYSTM:00/uevent</div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PHYSDEVBUS=acpi</div><div class="line">MODALIAS=acpi:LNXSYSTM:</div></pre></td></tr></table></figure></p>
<p>这就是由<code>devices_kset</code>所添加的环境变量</p>
<p>写操作对应的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">store_uevent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span></div><div class="line">                  <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">enum</span> kobject_action action;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (kobject_action_type(buf, count, &amp;action) == <span class="number">0</span>) &#123;</div><div class="line">         kobject_uevent(&amp;dev-&gt;kobj, action);</div><div class="line">         <span class="keyword">goto</span> out;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     dev_err(dev, <span class="string">"uevent: unsupported action-string; this will "</span></div><div class="line">              <span class="string">"be ignored in a future kernel version\n"</span>);</div><div class="line">     kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);</div><div class="line">out:</div><div class="line">     <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，这个文件的作用是输入一个字符字串，如果字符不合法，就会默认产生一个<code>add</code>事件。</p>
<p><code>devt_attr</code>对应的读写函数为<code>show_dev</code>、<code>NULL</code>。写函数为空，也就是说这个属性文件不允许写，只允许读。读操作的代码如下示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">show_dev</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span></div><div class="line">              <span class="keyword">char</span> *buf)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">print_dev_t</span>(buf, dev-&gt;devt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也就是说，会将设备号显示出来.</p>
<h3 id="驱动注册"><a href="#驱动注册" class="headerlink" title="驱动注册"></a><a name="4.3">驱动注册</a></h3><p>分析完了<code>bus</code>、<code>device</code>，再接着分析<code>driver</code>。这里我们要分析的最后一个元素了，耐着性子往下看，快要完了^_^<br>驱动注册的接口为：<code>driver_register()</code>。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">driver_register</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> ((drv-&gt;bus-&gt;probe &amp;&amp; drv-&gt;probe) ||</div><div class="line">         (drv-&gt;bus-&gt;remove &amp;&amp; drv-&gt;remove) ||</div><div class="line">         (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown))</div><div class="line">         printk(KERN_WARNING <span class="string">"Driver '%s' needs updating - please use "</span></div><div class="line">              <span class="string">"bus_type methods\n"</span>, drv-&gt;name);</div><div class="line">     ret = bus_add_driver(drv);</div><div class="line">     <span class="keyword">if</span> (ret)</div><div class="line">         <span class="keyword">return</span> ret;</div><div class="line">     ret = driver_add_groups(drv, drv-&gt;groups);</div><div class="line">     <span class="keyword">if</span> (ret)</div><div class="line">         bus_remove_driver(drv);</div><div class="line">     <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果设备与总线定义了相同的成员的函数，内核是优先使用<code>bus</code>中定义的，这一点我们在分析<code>device</code>注册的时候已经分析过。所以，这里打印出警告信息，用来提醒代码编写者。在这里，忽略有关<code>group</code>的东西，剩余的便只剩下<code>bus_add_driver()</code>。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bus_add_driver</span><span class="params">(<span class="keyword">struct</span> device_driver *drv)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_type *bus;</div><div class="line">     <span class="keyword">struct</span> driver_private *priv;</div><div class="line">     <span class="keyword">int</span> error = <span class="number">0</span>;</div><div class="line"></div><div class="line">     bus = bus_get(drv-&gt;bus);</div><div class="line">     <span class="keyword">if</span> (!bus)</div><div class="line">         <span class="keyword">return</span> -EINVAL;</div><div class="line"></div><div class="line">     pr_debug(<span class="string">"bus: '%s': add driver %s\n"</span>, bus-&gt;name, drv-&gt;name);</div><div class="line"></div><div class="line">     priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</div><div class="line">     <span class="keyword">if</span> (!priv) &#123;</div><div class="line">         error = -ENOMEM;</div><div class="line">         <span class="keyword">goto</span> out_put_bus;</div><div class="line">     &#125;</div><div class="line">     klist_init(&amp;priv-&gt;klist_devices, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">     priv-&gt;driver = drv;</div><div class="line">     drv-&gt;p = priv;</div><div class="line">     priv-&gt;kobj.kset = bus-&gt;p-&gt;drivers_kset;</div><div class="line">     error = kobject_init_and_add(&amp;priv-&gt;kobj, &amp;driver_ktype, <span class="literal">NULL</span>,</div><div class="line">                        <span class="string">"%s"</span>, drv-&gt;name);</div></pre></td></tr></table></figure></p>
<p>初始化驱动的<code>driver_private</code>域，使其内嵌的<code>kobject</code>的<code>kset</code>指bus中的<code>drivers_kset</code>，这样，这个内嵌的<code>kobject</code>所生成的目录就会存在于<code>bus</code>对应目录的<code>driver</code>目录之下。这里还要注意的是,为内嵌<code>kobject</code>指定的<code>ktype</code>是<code>driver_ktype</code>，属性文件的读写操作都回回溯到<code>struct driver_attribute</code>中，这在之后再分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (error)</div><div class="line">    <span class="keyword">goto</span> out_unregister;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (drv-&gt;bus-&gt;p-&gt;drivers_autoprobe) &#123;</div><div class="line">    error = driver_attach(drv);</div><div class="line">    <span class="keyword">if</span> (error)</div><div class="line">         <span class="keyword">goto</span> out_unregister;</div><div class="line">&#125;</div><div class="line">klist_add_tail(&amp;priv-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_drivers);</div><div class="line"></div><div class="line">module_add_driver(drv-&gt;owner, drv);</div></pre></td></tr></table></figure></p>
<p>如果总线允许自动进行匹配，就会调用<code>driver_attach()</code>进行这个自己匹配过程。这个函数跟我们在上面分析的<code>device</code>自动匹配过程是一样的，请自行分析。最后，将驱动挂到<code>bus</code>对应的驱动链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">error = driver_create_file(drv, &amp;driver_attr_uevent);</div><div class="line"><span class="keyword">if</span> (error) &#123;</div><div class="line">    printk(KERN_ERR <span class="string">"%s: uevent attr (%s) failed\n"</span>,</div><div class="line">         __FUNCTION__, drv-&gt;name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成一个属性为<code>driver_attr_uevent</code>的属性文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">error = driver_add_attrs(bus, drv);</div><div class="line"><span class="keyword">if</span> (error) &#123;</div><div class="line">    <span class="comment">/* How the hell do we get out of this pickle? Give up */</span></div><div class="line">    printk(KERN_ERR <span class="string">"%s: driver_add_attrs(%s) failed\n"</span>,</div><div class="line">         __FUNCTION__, drv-&gt;name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为<code>bus</code>中的<code>driver</code>属性生成属性文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">error = add_bind_files(drv);</div><div class="line"><span class="keyword">if</span> (error) &#123;</div><div class="line">    <span class="comment">/* Ditto */</span></div><div class="line">    printk(KERN_ERR <span class="string">"%s: add_bind_files(%s) failed\n"</span>,</div><div class="line">         __FUNCTION__, drv-&gt;name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成属性为<code>driver_attr_unbind</code>和<code>driver_attr_bind</code>的属性文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kobject_uevent(&amp;priv-&gt;kobj, KOBJ_ADD);</div></pre></td></tr></table></figure></p>
<p>生成一个<code>add</code>事件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">return</span> error;</div><div class="line">out_unregister:</div><div class="line">     kobject_put(&amp;priv-&gt;kobj);</div><div class="line">out_put_bus:</div><div class="line">     bus_put(bus);</div><div class="line">     <span class="keyword">return</span> error;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总的来说，这个函数比较简单，其中涉及到的子函数大部份都在之前分析过。我们接下来分析一下，它所创建的几个属性文件的含义。<br>如上所述，在这里会创建三个属性文件，对应属性分别为：<code>driver_attr_uevent</code>，<code>driver_attr_unbind</code>，<code>driver_attr_bind</code>。这几个属性的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DRIVER_ATTR</span><span class="params">(uevent, S_IWUSR, <span class="literal">NULL</span>, driver_uevent_store)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DRIVER_ATTR</span><span class="params">(unbind, S_IWUSR, <span class="literal">NULL</span>, driver_unbind)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">DRIVER_ATTR</span><span class="params">(bind, S_IWUSR, <span class="literal">NULL</span>, driver_bind)</span></span>;</div></pre></td></tr></table></figure></p>
<p><code>DRIVER_ATTR</code>宏的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_ATTR(_name, _mode, _show, _store)   \</span></div><div class="line">struct driver_attribute driver_attr_##_name =      \</div><div class="line">     __ATTR(_name, _mode, _show, _store)</div></pre></td></tr></table></figure></p>
<p>对于<code>driver_attr_uevent</code>，它的读写函数分别为：<code>NULL</code>，<code>driver_uevent_store</code>。也就是说这个文件只允许写，不允许读操作。写操作的代码如下示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">driver_uevent_store</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span></div><div class="line">                      <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">enum</span> kobject_action action;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (kobject_action_type(buf, count, &amp;action) == <span class="number">0</span>)</div><div class="line">         kobject_uevent(&amp;drv-&gt;p-&gt;kobj, action);</div><div class="line">     <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显，这是一个手动产生事件的过程。用户可间可以写事件到这个文件来产生事件。<br>对于<code>driver_unbind</code>，它的读写函数分别为：<code>NULL</code>，<code>driver_unbind</code>。这个文件也是不允许读的，写操作代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">driver_unbind</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span></div><div class="line">                   <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_type *bus = bus_get(drv-&gt;bus);</div><div class="line">     <span class="keyword">struct</span> device *dev;</div><div class="line">     <span class="keyword">int</span> err = -ENODEV;</div><div class="line"></div><div class="line">     dev = bus_find_device_by_name(bus, <span class="literal">NULL</span>, buf);</div><div class="line">     <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;driver == drv) &#123;</div><div class="line">         <span class="keyword">if</span> (dev-&gt;parent)   <span class="comment">/* Needed for USB */</span></div><div class="line">              down(&amp;dev-&gt;parent-&gt;sem);</div><div class="line">         device_release_driver(dev);</div><div class="line">         <span class="keyword">if</span> (dev-&gt;parent)</div><div class="line">              up(&amp;dev-&gt;parent-&gt;sem);</div><div class="line">         err = count;</div><div class="line">     &#125;</div><div class="line">     put_device(dev);</div><div class="line">     bus_put(bus);</div><div class="line">     <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，写入文件的是一个设备名称，这个函数对应操作是将这个设备与驱动的绑定分离开来。</p>
<p><code>driver_attr_bind</code>属性对应的读写函数分别为：<code>NULL</code>，<code>driver_attr_bind</code>。 即也是不允许写的。从字面意思和上面分析的<code>driver_attr_unbind</code>操作代码来看，这个属性对应的写函数应该是将写入的设备文件与此驱动绑定起来。我们来看下代码，以证实我们的猜测。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">driver_bind</span><span class="params">(<span class="keyword">struct</span> device_driver *drv,</span></span></div><div class="line">                 <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count)</div><div class="line">&#123;</div><div class="line">     <span class="keyword">struct</span> bus_type *bus = bus_get(drv-&gt;bus);</div><div class="line">     <span class="keyword">struct</span> device *dev;</div><div class="line">     <span class="keyword">int</span> err = -ENODEV;</div><div class="line"></div><div class="line">     dev = bus_find_device_by_name(bus, <span class="literal">NULL</span>, buf);</div><div class="line">     <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;driver == <span class="literal">NULL</span>) &#123;</div><div class="line">         <span class="keyword">if</span> (dev-&gt;parent)   <span class="comment">/* Needed for USB */</span></div><div class="line">              down(&amp;dev-&gt;parent-&gt;sem);</div><div class="line">         down(&amp;dev-&gt;sem);</div><div class="line">         err = driver_probe_device(drv, dev);</div><div class="line">         up(&amp;dev-&gt;sem);</div><div class="line">         <span class="keyword">if</span> (dev-&gt;parent)</div><div class="line">              up(&amp;dev-&gt;parent-&gt;sem);</div><div class="line"></div><div class="line">         <span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">/* success */</span></div><div class="line">              err = count;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">/* driver didn't accept device */</span></div><div class="line">              err = -ENODEV;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     put_device(dev);</div><div class="line">     bus_put(bus);</div><div class="line">     <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>果然，和我们猜测的是一样的。</p>
<h2 id="五：小结"><a href="#五：小结" class="headerlink" title="五：小结"></a><a name="5">五：小结</a></h2><p>在这一节里，分析了设备模型中的最底层的元素和他们之间的关系，也分析了它们建立的几个属性文件的含义。到这里，我们已经可以自己写驱动架构代码了 ^_^</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[文件与内存的桥梁：页缓存]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/page-cache-the-affair-between-memory-and-files/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://duartes.org/gustavo/blog/post/page-cache-the-affair-between-memory-and-files" target="_blank" rel="external">page-cache-the-affair-between-memory-and-files</a><br>作者：Gustavo Duarte</p>
<p>译文：<a href="http://sstompkins.wordpress.com/2011/04/17/%e6%96%87%e4%bb%b6%e4%b8%8e%e5%86%85%e5%ad%98%e7%9a%84%e6%a1%a5%e6%a2%81%ef%bc%9apage-cache/" target="_blank" rel="external">文件与内存的桥梁：Page Cache</a><br>翻译：fleurer</p>
<p>前面我们观察了内核为用户进程管理虚拟内存的方法，简单起见，一时忽略了文件和IO。本文则着重讨论下这块，说说文件和内存之间的暧昧关系，及其对性能的影响。<br><a id="more"></a></p>
<p>关于文件，有两个严肃的问题需要考虑。首先是与内存相比，硬件设备往往是发指的慢，其寻址尤然；其次是某文件只应装入物理内存一次，其内容可为不同 程序所共享。比如用Process Explorer观查Windows进程的话可以发现，有大约15MB的公用DLL在所有进程中都有装载。想下，我的Windows现在有100个进程， 要是没有共享机制，光这些公共DLL就得占去1.5GB的物理内存，显然不靠谱。同样Linux下也是几乎每个程序也都得用到ld.so和libc，一些常用的共享库也是不可或缺的。</p>
<p>幸甚，上述两个问题能够一举解决：Page Cache，即内核以页为单位缓存文件的机制。拿例子说话，我们编写一个Linux程序render，它打开scene.dat文件，每次读取512字节，将其储存于堆里。第一次读取大约即这样：<br><img src="/kernel/内核内存管理/page-cache-the-affair-between-memory-and-files/readFromPageCache.png" alt="readFromPageCache.png" title=""><br>12kb读取完毕，它的堆和相关的页框大约这样：<br><img src="/kernel/内核内存管理/page-cache-the-affair-between-memory-and-files/nonMappedFileRead.png" alt="nonMappedFileRead.png" title=""><br>比较明显了，不过还有些地方待挖掘。首先，这个程序只是使用普通的read调用，即已有三个4kb的页作为Page Cache来存放scene.dat。可能难以置信，但事实如此：任何普通文件的读写都必须经过Page Cache。x86体系结构的Linux将文件看作是n个4kb的块相连而成的序列，即使仅仅读取一个字节，也不得不读入整个4kb大小的块到Page Cache。文件的读写往往不是几个字节就罢，这样设定有助于提升磁盘的吞吐量。每个Page Cache对应文件中的一个4kb块，并一个唯一的编号。Windows中的等价物是256kb的视图（view）。</p>
<p>然而杯具是，普通的一个read之后，内核还要把Page Cache里的内容额外拷贝到用户态的缓冲区，既费CPU时间又污染CPU缓存，还浪费物理内存。如上图所示，scene.dat里同样的内容被储存在了 两个地方，而且每个该程序的实例都会如此重复，进一步白白浪费时间浪费空间。我们缓解了磁盘延时这一重镇的危险，却尽失其它城池。于是下一个方案呼之欲 出，即文件映射(Memory-mapped files)。<br><img src="/kernel/内核内存管理/page-cache-the-affair-between-memory-and-files/mappedFileRead.png" alt="mappedFileRead.png" title=""><br>使用文件映射时，内核会把程序的虚拟页面直接映射到Page Cache上。这一来性能就燃了：《Windows System Programming》有提及说这样比起普通的read方式，性能提升30%。《Unix环境高级编程》里对Linux和Solaris的性能测试的结 果也与之相似。情景合适的话，还可以为程序节省大量的物理内存。</p>
<p>谈及性能，评测至上。而内存映射凭其优良的性能，值得为每个程序员所了解。API也很漂亮，一字节一字节的读内存即访问文件，甚至不用纠结可读性与 性能的trade off。*nix上有mmap，windows有CreateFileMapping，还有其它高级语言的各种封装，都不妨一试，留意下你的地址空间。在 映射文件的时候，其内容并不是一次性装入内存，而是基于Page Fault的请求调页。取一个物理页存放其内容，然后fault handler将这个虚拟页映射到Page Cache。这是缓存之前的第一次读取。</p>
<p>提个问题：在最后一个例子程序在执行结束后，Page Cache里的内容会不会释放？可能直觉该如此，但实际上这样不好。想想，我们经常会在某程序里打开某个文件，它退出了之后第二个程序还得用它—— Page Cache必须对此有所考虑。比如需要跑那个例子程序一星期，一直缓存着scene.dat不就赚大了。既如此，那Page Cache的内容该在什么时候释放呢？永远记着磁盘的读取速度得比内存慢五个量级，能命中Page Cache自是多多益善。所以只要还有空闲的物理内存，内核就总是拿来做缓存使。Page Cache不是某个进程的私有财产，它是为整个系统所共享的资源。这就是为啥内核缓存总是不到极限不休——绝不是因为系统烂吃内存，毕竟物理内存闲着也是 闲着，缓存不嫌多。这是个很好的做法。</p>
<p>Page Cache架构下的write()调用就只是将数据写入Page Cache再把它标记为dirty，而磁盘IO通常并不立即执行，程序也就无需为磁盘而阻塞。这样的不足就是机器一旦意外崩溃，就可能会丢失部分数据。因 此对完整性要求高的文件（比如数据库事务的log）通常会在写入后调用fsync()（唔，还有磁盘驱动器缓存需要纠结）。read通常是阻塞等待数据读 取就绪。为减少这里的阻塞，内核会一次性多读几个页，预先缓存起来，即“贪婪读取”(Eager Loading)。我们可以调整贪婪读取的参数(参见madvise(),readahead(),或windows的cache hints)，告诉内核我们读取起来是顺序还是随机。Linux会为内存映射的文件执行预读取(read-ahead)，Windows则不清楚。跳过 Page Cache也是可以的，数据库经常需要这样：Linux可以O_DIRECT，Windows可以NO_BUFFERING。</p>
<p>文件的映射也可以设为私有，即私有映射中的内存读写不会影响到磁盘中文件的内容，也不会对影响到其它进程中的数据，而不像共享映射那样二者皆同步其 变化。内核在私有映射的实现上应用了写时复制机制。如下面的例子里，render和render3d两个程序都私有映射了同一个文件scene.dat， 随后render修改了一下文件映射的虚拟内存：<br><img src="/kernel/内核内存管理/page-cache-the-affair-between-memory-and-files/copyOnWrite.png" alt="copyOnWrite.png" title=""><br>如上这个页表项是“只读”并不意味着这个映射是只读的。这就是内核用以实现写时复制的小trick，共享物理页，不到万不得已决不复制——这个“万 不得已”由x86把关而不是内核。搞明白所谓“私有映射”仅仅是针对“更改“就好理解了。这样设计的一个结果是：在对私有映射来的页面进行修改前，其他程 序对它的修改都是可见的；一旦经过写时复制，其他程序对它的修改就不可见了。与之相对，共享映射仅仅把page cache映射到位即可，对它的修改对其它进程皆可见，文件在磁盘中也一并修改。若是只读映射就免了写时复制，Page Fault时直接一个segmentation fault。</p>
<p>动态库也是通过文件映射装入程序的地址空间，就是普通的私有文件映射，并无特殊之处。如下是同一例子程序的两个实例，其地址空间和物理内存的样子足已囊括本文出现的很多概念：<br><img src="/kernel/内核内存管理/page-cache-the-affair-between-memory-and-files/virtualToPhysicalMapping.png" alt="virtualToPhysicalMapping.png" title=""><br>以上，内存三部曲已告一段落。希望对大家有帮助，对操作系统的相关概念有个感性认识就好。下周再一篇post说说内存的分配图，也该换换话题了，比如web2.0八卦什么的 :)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内核是如何管理内存的]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/how-the-kernel-manages-your-memory/</url>
      <content type="html"><![CDATA[<p><a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory" target="_blank" rel="external">how-the-kernel-manages-your-memory</a><br><a href="/kernel/内核内存管理/how-the-kernel-manages-your-memory/how-the-kernel-manages-your-memory.pdf" title="【译】内核是如何管理内存的">【译】内核是如何管理内存的</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[进程内存布局剖析]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/anatomy-of-a-program-in-memory/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory" target="_blank" rel="external">anatomy-of-a-program-in-memory</a></p>
<a href="/kernel/内核内存管理/anatomy-of-a-program-in-memory/anatomy-of-a-program-in-memory.pdf" title="【译】进程内存布局剖析">【译】进程内存布局剖析</a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[linux中文件描述符fd和文件指针filp的理解]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/linux-fd/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html" target="_blank" rel="external">http://www.cnblogs.com/Jezze/archive/2011/12/23/2299861.html</a></p>
<p><strong>简单归纳：<code>fd</code>只是一个整数，在<code>open</code>时产生，起到一个索引的作用；进程通过<code>PCB</code>中的文件描述符表找到该<code>fd</code>所指向的文件指针<code>filp</code>。</strong></p>
<p>文件描述符的操作(如:<code>open</code>)返回的是一个文件描述符,内核会在每个进程空间中维护一个文件描述符表, 所有打开的文件都将通过此表中的文件描述符来引用;而流(如:<code>fopen</code>)返回的是一个<code>FILE</code>结构指针, <code>FILE</code>结构是包含有文件描述符的，<code>FILE</code>结构函数可以看作是对<code>fd</code>直接操作的系统调用的封装, 它的优点是带有I/O缓存。<br><a id="more"></a></p>
<p>Linux支持各种各样的文件系统格式，如ext2、ext3、reiserfs、FAT、NTFS、iso9660等等，不同的磁盘分区、光盘或其它存储设备都有不同的文件系统格式，然而这些文件系统都可以mount到某个目录下，使我们看到一个统一的目录树，各种文件系统上的目录和文件我们用ls命令看起来是一样的，读写操作用起来也都是一样的，这是怎么做到的呢？Linux内核在各种不同的文件系统格式之上做了一个抽象层，使得文件、目录、读写访问等概念成为抽象层的概念，因此各种文件系统看起来用起来都一样，这个抽象层称为虚拟文件系统（VFS，Virtual Filesystem）。</p>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>上一节我们介绍了一种典型的文件系统在磁盘上的存储布局，这一节我们介绍运行时文件系统在内核中的表示。</p>
<p>Linux内核的VFS子系统可以图示如下：<br><img src="/kernel/内核文件系统/linux-fd/linux-vfs.png" alt="linux-vfs.png" title=""></p>
<p><strong>每个进程在PCB (Process Control Block) 即进程控制块中都保存着一份文件描述符表，文件描述符就是这个表的索引，文件描述表中每个表项都有一个指向已打开文件的指针</strong>，现在我们明确一下：已打开的文件在内核中用<code>file</code>结构体表示，文件描述符表中的指针指向<code>file</code>结构体。</p>
<p>在<code>file</code>结构体中维护File Status Flag（<code>file</code>结构体的成员<code>f_flags</code>）和当前读写位置（<code>file</code>结构体的成员<code>f_pos</code>）。在上图中，进程1和进程2都打开同一文件，但是对应不同的file结构体，因此可以有不同的File Status Flag和读写位置。<code>file</code>结构体中比较重要的成员还有<code>f_count</code>，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个<code>file</code>结构体，例如有<code>fd1</code>和<code>fd2</code>都引用同一个<code>file</code>结构体，那么它的引用计数就是2，当<code>close(fd1)</code>时并不会释放<code>file</code>结构体，而只是把引用计数减到1，如果再<code>close(fd2)</code>，引用计数就会减到0同时释放<code>file</code>结构体，这才真的关闭了文件。</p>
<p>每个<code>file</code>结构体都指向一个<code>file_operations</code>结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中<code>read</code>一个文件描述符，<code>read</code>通过系统调用进入内核，然后找到这个文件描述符所指向的<code>file</code>结构体，找到<code>file</code>结构体所指向的<code>file_operations</code>结构体，调用它的<code>read</code>成员所指向的内核函数以完成用户请求。在用户程序中调用<code>lseek</code>、<code>read</code>、<code>write</code>、<code>ioctl</code>、<code>open</code>等函数，最终都由内核调用<code>file_operations</code>的各成员所指向的内核函数完成用户请求。<code>file_operations</code>结构体中的<code>release</code>成员用于完成用户程序的<code>close</code>请求，之所以叫<code>release</code>而不叫<code>close</code>是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，<code>read</code>、<code>write</code>等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的<code>file</code>结构体指向同一个<code>file_operations</code>结构体。如果打开一个字符设备文件，那么它的<code>read</code>、<code>write</code>操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以<code>file</code>结构体应该指向不同的<code>file_operations</code>结构体，其中的各种文件操作函数由该设备的驱动程序实现。</p>
<p>每个<code>file</code>结构体都有一个指向<code>dentry</code>结构体的指针，“dentry”是directory entry（目录项）的缩写。我们传给<code>open</code>、<code>stat</code>等函数的参数的是一个路径，例如/home/akaedu/a，需要根据路径找到文件的<code>inode</code>。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个<code>dentry</code>结构体，只要沿着路径各部分的<code>dentry</code>搜索即可，从根目录/找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</p>
<p>每个<code>dentry</code>结构体都有一个指针指向<code>inode</code>结构体。<code>inode</code>结构体保存着从磁盘<code>inode</code>读上来的信息。在上图的例子中，有两个<code>dentry</code>，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个<code>inode</code>，说明这两个文件互为硬链接。<code>inode</code>结构体中保存着从磁盘分区的<code>inode</code>读上来信息，例如所有者、文件大小、文件类型和权限位等。每个<code>inode</code>结构体都有一个指向<code>inode_operations</code>结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。和<code>file_operations</code>不同，<code>inode_operations</code>所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各<code>inode</code>结构体可以指向同一个<code>inode_operations</code>结构体。</p>
<p><code>inode</code>结构体有一个指向<code>super_block</code>结构体的指针。<code>super_block</code>结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。<code>super_block</code>结构体的<code>s_root</code>成员是一个指向<code>dentry</code>的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到/home目录下。</p>
<p><strong>file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。</strong></p>
<p>对于ext2文件系统来说，在磁盘存储布局上也有<code>inode</code>和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有<code>inode</code>或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有<code>inode</code>和权限位的概念，这是硬凑出来的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从文件 I/O 看 Linux 的虚拟文件系统]]></title>
      <url>https://jarsonfang.github.io/kernel/%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/linux-vfs/</url>
      <content type="html"><![CDATA[<p>原文出处：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-vfs/</a></p>
<p><strong>简介：</strong> Linux 允许众多不同的文件系统共存，并支持跨文件系统的文件操作，这是因为有虚拟文件系统的存在。<span style="color: #ff0102;">虚拟文件系统交换器</span>，即VFS（<span style="color: #ff0102;">Virtual Filesystem Switch</span>）是 Linux 内核中的一个软件抽象层。它通过一些数据结构及其方法向实际的文件系统如 ext2，vfat 提供接口机制。本文在简要介绍 VFS 的相关数据结构后，以文件 I/O 为切入点深入 Linux 内核源代码，追踪了 sys_open 和 sys_read 两个系统调用的代码结构，并在追踪的过程中理清了跨文件系统的文件操作的基本原理和“一切皆是文件”的口号得以实现的根本。<br><a id="more"></a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Linux 中允许众多不同的文件系统共存，如 ext2, ext3, vfat 等。通过使用同一套文件 I/O 系统 调用即可对 Linux 中的任意文件进行操作而无需考虑其所在的具体文件系统格式；更进一步，对文件的 操作可以跨文件系统而执行。如图 1 所示，我们可以使用 cp 命令从 vfat 文件系统格式的硬盘拷贝数据到 ext3 文件系统格式的硬盘；而这样的操作涉及到两个不同的文件系统。<br>图 1. 跨文件系统的文件操作<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig1.jpg" alt="vfs-fig1.jpg" title=""><br>“一切皆是文件”是 Unix/Linux 的基本哲学之一。不仅普通的文件，目录、字符设备、块设备、 套接字等在 Unix/Linux 中都是以文件被对待；它们虽然类型不同，但是对其提供的却是同一套操作界面。<br>图 2. 一切皆是文件<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig2.jpg" alt="vfs-fig2.jpg" title=""><br>而虚拟文件系统正是实现上述两点 Linux 特性的关键所在。虚拟文件系统交换器（<span style="color:red">Virtual Filesystem Switch</span>， 简称 VFS）， 是 Linux 内核中的一个软件层，用于给用户空间的程序提供文件系统接口；同时，它也提供了内核中的一个 抽象功能，允许不同的文件系统共存。系统中所有的文件系统不但依赖 VFS 共存，而且也依靠 VFS 协同工作。<br>为了能够支持各种实际文件系统，VFS 定义了所有文件系统都支持的基本的、概念上的接口和数据 结构；同时实际文件系统也提供 VFS 所期望的抽象接口和数据结构，将自身的诸如文件、目录等概念在形式 上与VFS的定义保持一致。换句话说，一个实际的文件系统想要被 Linux 支持，就必须提供一个符合VFS标准 的接口，才能与 VFS 协同工作。实际文件系统在统一的接口和数据结构下隐藏了具体的实现细节，所以在VFS 层和内核的其他部分看来，所有文件系统都是相同的。图3显示了VFS在内核中与实际的文件系统的协同关系。<br>图3. VFS在内核中与其他的内核模块的协同关系<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig3.jpg" alt="vfs-fig3.jpg" title=""><br>我们已经知道，正是由于在内核中引入了VFS，跨文件系统的文件操作才能实现，“一切皆是文件” 的口号才能承诺。而为什么引入了VFS，就能实现这两个特性呢？在接下来，我们将以这样的一个思路来切入文章的正题：我们将先简要介绍下用以描述VFS模型的一些数据结构，总结出这些数据结构相互间的关系；然后 选择两个具有代表性的文件I/O操作<code>sys_open()</code>和<code>sys_read()</code>来详细说明内核是如何借助VFS和具体的文件系统打 交道以实现跨文件系统的文件操作和承诺“一切皆是文件”的口号</p>
<h2 id="VFS数据结构"><a href="#VFS数据结构" class="headerlink" title="VFS数据结构"></a>VFS数据结构</h2><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>从本质上讲，文件系统是特殊的数据分层存储结构，它包含文件、目录和相关的控制信息。为了描述 这个结构，Linux引入了一些基本概念:<br><strong>文件</strong> 一组在逻辑上具有完整意义的信息项的系列。在Linux中，除了普通文件，其他诸如目录、设备、套接字等 也以文件被对待。总之，“一切皆文件”。<br><strong>目录</strong> 目录好比一个文件夹，用来容纳相关文件。因为目录可以包含子目录，所以目录是可以层层嵌套，形成 文件路径。在Linux中，目录也是以一种特殊文件被对待的，所以用于文件的操作同样也可以用在目录上。<br><strong>目录项</strong> 在一个文件路径中，路径中的每一部分都被称为目录项；如路径/home/source/helloworld.c中，目录 /, home, source和文件 helloworld.c都是一个目录项。<br><strong>索引节点</strong> 用于存储文件的元数据的一个数据结构。文件的元数据，也就是文件的相关信息，和文件本身是两个不同 的概念。它包含的是诸如文件的大小、拥有者、创建时间、磁盘位置等和文件相关的信息。<br><strong>超级块</strong> 用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节 点数等，存放于磁盘的特定扇区中。<br>如上的几个概念在磁盘中的位置关系如图4所示。<br>图4. 磁盘与文件系统<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig4.jpg" alt="vfs-fig4.jpg" title=""><br>关于文件系统的三个易混淆的概念：<br><strong>创建</strong> 以某种方式格式化磁盘的过程就是在其之上建立一个文件系统的过程。创建文现系统时，会在磁盘的特定位置写入 关于该文件系统的控制信息。<br><strong>注册</strong> 向内核报到，声明自己能被内核支持。一般在编译内核的时侯注册；也可以加载模块的方式手动注册。注册过程实 际上是将表示各实际文件系统的数据结构<code>struct file_system_type</code>实例化。<br><strong>安装</strong> 也就是我们熟悉的mount操作，将文件系统加入到Linux的根文件系统的目录树结构上；这样文件系统才能被访问。</p>
<h3 id="VFS数据结构-1"><a href="#VFS数据结构-1" class="headerlink" title="VFS数据结构"></a>VFS数据结构</h3><p>VFS依靠四个主要的数据结构和一些辅助的数据结构来描述其结构信息，这些数据结构表现得就像是对象；每个主要对象中都包含由操作函数表构成的操作对象，这些操作对象描述了内核针对这几个主要的对象可以进行的操作。</p>
<h4 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h4><p>存储一个已安装的文件系统的控制信息，代表一个已安装的文件系统；每次一个实际的文件系统被安装时，内核会从磁盘的特定位置读取一些控制信息来填充内存中的超级块对象。一个安装实例和一个超级块对象一一对应。 超级块通过其结构中的一个域<code>s_type</code>记录它所属的文件系统类型。<br>根据第三部分追踪源代码的需要，以下是对该超级块结构的部分相关成员域的描述，（如下同）：<br>清单1. 超级块<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> super_block &#123; <span class="comment">//超级块数据结构</span></div><div class="line">       <span class="keyword">struct</span> list_head s_list;                <span class="comment">/*指向超级块链表的指针*/</span></div><div class="line">        ……</div><div class="line">       <span class="keyword">struct</span> file_system_type  *s_type;       <span class="comment">/*文件系统类型*/</span></div><div class="line">       <span class="keyword">struct</span> super_operations  *s_op;         <span class="comment">/*超级块方法*/</span></div><div class="line">        ……</div><div class="line">        <span class="keyword">struct</span> list_head         s_instances;   <span class="comment">/*该类型文件系统*/</span></div><div class="line">        ……</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> super_operations &#123; <span class="comment">//超级块方法</span></div><div class="line">        ……</div><div class="line">        <span class="comment">//该函数在给定的超级块下创建并初始化一个新的索引节点对象</span></div><div class="line">        <span class="keyword">struct</span> inode *(*alloc_inode)(<span class="keyword">struct</span> super_block *sb);</div><div class="line">       ……</div><div class="line">        <span class="comment">//该函数从磁盘上读取索引节点，并动态填充内存中对应的索引节点对象的剩余部分</span></div><div class="line">        <span class="keyword">void</span> (*read_inode) (<span class="keyword">struct</span> inode *);</div><div class="line">       ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h4><p>索引节点对象存储了文件的相关信息，代表了存储设备上的一个实际的物理文件。当一个文件首次被访问时，内核会在内存中组装相应的索引节点对象，以便向内核提供对一个文件进行操作时所必需的全部信息；这些信息一部分存储在磁盘特定位置，另外一部分是在加载时动态填充的。<br>清单2. 索引节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> inode &#123; <span class="comment">//索引节点结构</span></div><div class="line">      ……</div><div class="line">     <span class="keyword">struct</span> inode_operations  *i_op;     <span class="comment">/*索引节点操作表*/</span></div><div class="line">     <span class="keyword">struct</span> file_operations   *i_fop;	 <span class="comment">/*该索引节点对应文件的文件操作集*/</span></div><div class="line">     <span class="keyword">struct</span> super_block       *i_sb;     <span class="comment">/*相关的超级块*/</span></div><div class="line">     ……</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> inode_operations &#123; <span class="comment">//索引节点方法</span></div><div class="line">     ……</div><div class="line">     <span class="comment">//该函数为dentry对象所对应的文件创建一个新的索引节点，主要是由open()系统调用来调用</span></div><div class="line">     <span class="keyword">int</span> (*create) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *,<span class="keyword">int</span>, <span class="keyword">struct</span> nameidata *);</div><div class="line"></div><div class="line">     <span class="comment">//在特定目录中寻找dentry对象所对应的索引节点</span></div><div class="line">     <span class="keyword">struct</span> dentry * (*lookup) (<span class="keyword">struct</span> inode *,<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</div><div class="line">     ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h4><p>引入目录项的概念主要是出于方便查找文件的目的。一个路径的各个组成部分，不管是目录还是 普通的文件，都是一个目录项对象。如，在路径/home/source/test.c中，目录 /, home, source和文件test.c都对应一个目录项对象。不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，VFS在遍 历路径名的过程中现场将它们逐个地解析成目录项对象。<br>清单3. 目录项<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> dentry &#123; <span class="comment">//目录项结构</span></div><div class="line">     ……</div><div class="line">    <span class="keyword">struct</span> inode *d_inode;           <span class="comment">/*相关的索引节点*/</span></div><div class="line">    <span class="keyword">struct</span> dentry *d_parent;         <span class="comment">/*父目录的目录项对象*/</span></div><div class="line">    <span class="keyword">struct</span> qstr d_name;              <span class="comment">/*目录项的名字*/</span></div><div class="line">    ……</div><div class="line">     <span class="keyword">struct</span> list_head d_subdirs;      <span class="comment">/*子目录*/</span></div><div class="line">    ……</div><div class="line">     <span class="keyword">struct</span> dentry_operations *d_op;  <span class="comment">/*目录项操作表*/</span></div><div class="line">    <span class="keyword">struct</span> super_block *d_sb;        <span class="comment">/*文件超级块*/</span></div><div class="line">    ……</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> dentry_operations &#123;</div><div class="line">    <span class="comment">//判断目录项是否有效;</span></div><div class="line">    <span class="keyword">int</span> (*d_revalidate)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> nameidata *);</div><div class="line">    <span class="comment">//为目录项生成散列值;</span></div><div class="line">    <span class="keyword">int</span> (*d_hash) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> qstr *);</div><div class="line">    ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h4><p>文件对象是已打开的文件在内存中的表示，主要用于建立进程和磁盘上的文件的对应关系。它由<code>sys_open()</code>现场创建，由<code>sys_close()</code>销毁。文件对象和物理文件的关系有点像进程和程序的关系一样。当我们站在用户空间来看待VFS，我们像是只需与文件对象打交道，而无须关心超级块，索引节点或目录项。因为多个进程可以同时打开和操作同一个文件，所以同一个文件也可能存在多个对应的文件对象。文件对象仅仅在进程观点上代表已经打开的文件，它反过来指向目录项对象（反过来指向索引节点）。一个文件对应的文件对象可能不是惟一的，但是其对应的索引节点和目录项对象无疑是惟一的。<br>清单4. 文件对象<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> file &#123;</div><div class="line">    ……</div><div class="line">    <span class="keyword">struct</span> list_head        f_list;        <span class="comment">/*文件对象链表*/</span></div><div class="line">    <span class="keyword">struct</span> dentry          *f_dentry;      <span class="comment">/*相关目录项对象*/</span></div><div class="line">    <span class="keyword">struct</span> vfsmount        *f_vfsmnt;      <span class="comment">/*相关的安装文件系统*/</span></div><div class="line">    <span class="keyword">struct</span> file_operations *f_op;          <span class="comment">/*文件操作表*/</span></div><div class="line">    ……</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> file_operations &#123;</div><div class="line">    ……</div><div class="line">    <span class="comment">//文件读操作</span></div><div class="line">    <span class="keyword">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</div><div class="line">    ……</div><div class="line">    <span class="comment">//文件写操作</span></div><div class="line">    <span class="keyword">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</div><div class="line">    ……</div><div class="line">    <span class="keyword">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="keyword">void</span> *, <span class="keyword">filldir_t</span>);</div><div class="line">    ……</div><div class="line">    <span class="comment">//文件打开操作</span></div><div class="line">    <span class="keyword">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</div><div class="line">    ……</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="其他VFS对象"><a href="#其他VFS对象" class="headerlink" title="其他VFS对象"></a>其他VFS对象</h4><h5 id="和文件系统相关"><a href="#和文件系统相关" class="headerlink" title="和文件系统相关"></a><span style="color:red">和文件系统相关</span></h5><p>根据文件系统所在的物理介质和数据在物理介质上的组织方式来区分不同的文件系统类型的。<code>file_system_type</code>结构用于描述具体的文件系统的类型信息。被Linux支持的文件系统，都有且仅有一个<code>file_system_type</code>结构而不管它有零个或多个实例被安装到系统中。<br>而与此对应的是每当一个文件系统被实际安装，就有一个<code>vfsmount</code>结构体被创建，这个结构体对应一个安装点。<br>清单5. 和文件系统相关<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> file_system_type &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;                <span class="comment">/*文件系统的名字*/</span></div><div class="line">        <span class="keyword">struct</span> subsystem subsys;         <span class="comment">/*sysfs子系统对象*/</span></div><div class="line">        <span class="keyword">int</span> fs_flags;                    <span class="comment">/*文件系统类型标志*/</span></div><div class="line"></div><div class="line">        <span class="comment">/*在文件系统被安装时，从磁盘中读取超级块,在内存中组装超级块对象*/</span></div><div class="line">        <span class="keyword">struct</span> super_block *(*get_sb) (<span class="keyword">struct</span> file_system_type*,</div><div class="line">                                        <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">void</span> *);</div><div class="line"></div><div class="line">        <span class="keyword">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *);  <span class="comment">/*终止访问超级块*/</span></div><div class="line">        <span class="keyword">struct</span> <span class="keyword">module</span> *owner;                    <span class="comment">/*文件系统模块*/</span></div><div class="line">        <span class="keyword">struct</span> file_system_type * next;          <span class="comment">/*链表中的下一个文件系统类型*/</span></div><div class="line">        <span class="keyword">struct</span> list_head fs_supers;              <span class="comment">/*具有同一种文件系统类型的超级块对象链表*/</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> vfsmount</div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> list_head mnt_hash;               <span class="comment">/*散列表*/</span></div><div class="line">        <span class="keyword">struct</span> vfsmount *mnt_parent;             <span class="comment">/*父文件系统*/</span></div><div class="line">        <span class="keyword">struct</span> dentry *mnt_mountpoint;           <span class="comment">/*安装点的目录项对象*/</span></div><div class="line">        <span class="keyword">struct</span> dentry *mnt_root;                 <span class="comment">/*该文件系统的根目录项对象*/</span></div><div class="line">        <span class="keyword">struct</span> super_block *mnt_sb;              <span class="comment">/*该文件系统的超级块*/</span></div><div class="line">        <span class="keyword">struct</span> list_head mnt_mounts;             <span class="comment">/*子文件系统链表*/</span></div><div class="line">        <span class="keyword">struct</span> list_head mnt_child;              <span class="comment">/*子文件系统链表*/</span></div><div class="line">        <span class="keyword">atomic_t</span> mnt_count;                      <span class="comment">/*使用计数*/</span></div><div class="line">        <span class="keyword">int</span> mnt_flags;                           <span class="comment">/*安装标志*/</span></div><div class="line">        <span class="keyword">char</span> *mnt_devname;                       <span class="comment">/*设备文件名*/</span></div><div class="line">        <span class="keyword">struct</span> list_head mnt_list;               <span class="comment">/*描述符链表*/</span></div><div class="line">        <span class="keyword">struct</span> list_head mnt_fslink;             <span class="comment">/*具体文件系统的到期列表*/</span></div><div class="line">        <span class="keyword">struct</span> <span class="keyword">namespace</span> *mnt_namespace;         <span class="comment">/*相关的名字空间*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="和进程相关"><a href="#和进程相关" class="headerlink" title="和进程相关"></a><span style="color:red">和进程相关</span></h5><p>清单6. 打开的文件集<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> files_struct &#123;<span class="comment">//打开的文件集</span></div><div class="line">        <span class="keyword">atomic_t</span> count;              <span class="comment">/*结构的使用计数*/</span></div><div class="line">        ……</div><div class="line">        <span class="keyword">int</span> max_fds;                 <span class="comment">/*文件对象数的上限*/</span></div><div class="line">        <span class="keyword">int</span> max_fdset;               <span class="comment">/*文件描述符的上限*/</span></div><div class="line">        <span class="keyword">int</span> next_fd;                 <span class="comment">/*下一个文件描述符*/</span></div><div class="line">        <span class="keyword">struct</span> file ** fd;           <span class="comment">/*全部文件对象数组*/</span></div><div class="line">        ……</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> fs_struct &#123;<span class="comment">//建立进程与文件系统的关系</span></div><div class="line">         <span class="keyword">atomic_t</span> count;              <span class="comment">/*结构的使用计数*/</span></div><div class="line">        <span class="keyword">rwlock_t</span> lock;               <span class="comment">/*保护该结构体的锁*/</span></div><div class="line">        <span class="keyword">int</span> umask；                  <span class="comment">/*默认的文件访问权限*/</span></div><div class="line">        <span class="keyword">struct</span> dentry * root;        <span class="comment">/*根目录的目录项对象*/</span></div><div class="line">        <span class="keyword">struct</span> dentry * pwd;         <span class="comment">/*当前工作目录的目录项对象*/</span></div><div class="line">        <span class="keyword">struct</span> dentry * altroot；    <span class="comment">/*可供选择的根目录的目录项对象*/</span></div><div class="line">        <span class="keyword">struct</span> vfsmount * rootmnt;   <span class="comment">/*根目录的安装点对象*/</span></div><div class="line">        <span class="keyword">struct</span> vfsmount * pwdmnt;    <span class="comment">/*pwd的安装点对象*/</span></div><div class="line">        <span class="keyword">struct</span> vfsmount * altrootmnt;<span class="comment">/*可供选择的根目录的安装点对象*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="和路径查找相关"><a href="#和路径查找相关" class="headerlink" title="和路径查找相关"></a><span style="color:red">和路径查找相关</span></h5><p>清单7. 辅助查找<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> nameidata &#123;</div><div class="line">        <span class="keyword">struct</span> dentry  *dentry;     <span class="comment">/*目录项对象的地址*/</span></div><div class="line">        <span class="keyword">struct</span> vfsmount  *mnt;      <span class="comment">/*安装点的数据*/</span></div><div class="line">        <span class="keyword">struct</span> qstr  last;          <span class="comment">/*路径中的最后一个component*/</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  flags;        <span class="comment">/*查找标识*/</span></div><div class="line">        <span class="keyword">int</span>  last_type;             <span class="comment">/*路径中的最后一个component的类型*/</span></div><div class="line">        <span class="keyword">unsigned</span>  depth;            <span class="comment">/*当前symbolic link的嵌套深度，不能大于6*/</span></div><div class="line">        <span class="keyword">char</span>   *saved_names[MAX_NESTED_LINKS + <span class="number">1</span>];/</div><div class="line">                                    <span class="comment">/*和嵌套symbolic link 相关的pathname*/</span></div><div class="line">        <span class="keyword">union</span> &#123;</div><div class="line">            <span class="keyword">struct</span> open_intent open; <span class="comment">/*说明文件该如何访问*/</span></div><div class="line">        &#125; intent;   <span class="comment">/*专用数据*/</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="对象间的联系"><a href="#对象间的联系" class="headerlink" title="对象间的联系"></a>对象间的联系</h4><p>如上的数据结构并不是孤立存在的。正是通过它们的有机联系，VFS才能正常工作。如下的几张图是对它们之间的联系的描述。<br>如图5所示，被Linux支持的文件系统，都有且仅有一个<code>file_system_type</code>结构而不管它有零个或多个实例被安装到系统中。每安装一个文件系统，就对应有一个超级块和安装点。超级块通过它的一个域<code>s_type</code>指向其对应的具体的文件系统类型。具体的文件系统通过<code>file_system_type</code>中的一个域<code>fs_supers</code>链接具有同一种文件类型的超级块。同一种文件系统类型的超级块通过域<code>s_instances</code>链接。<br>图5. 超级块、安装点和具体的文件系统的关系<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig5.jpg" alt="vfs-fig5.jpg" title=""><br>从图6可知：进程通过<code>task_struct</code>中的一个域<code>files_struct files</code>来了解它当前所打开的文件对象；而我们通常所说的文件描述符其实是进程打开的文件对象数组的索引值。文件对象通过域<code>f_dentry</code>找到它对应的<code>dentry</code>对象，再由<code>dentry</code>对象的域<code>d_inode</code>找到它对应的索引结点，这样就建立了文件对象与实际的物理文件的关联。最后，还有一点很重要的是,文件对象所对应的文件操作函数列表是通过索引结点的域<code>i_fop</code>得到的。图6对第三部分源码的理解起到很大的作用。<br>图6. 进程与超级块、文件、索引结点、目录项的关系<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig6.jpg" alt="vfs-fig6.jpg" title=""></p>
<h2 id="基于VFS的文件I-O"><a href="#基于VFS的文件I-O" class="headerlink" title="基于VFS的文件I/O"></a>基于VFS的文件I/O</h2><p>到目前为止，文章主要都是从理论上来讲述VFS的运行机制；接下来我们将深入源代码层中，通过阐述两个具有代表性的系统调用<code>sys_open()</code>和<code>sys_read()</code>来更好地理解VFS向具体文件系统提供的接口机制。由于本文更关注的是文件操作的整个流程体制，所以我们在追踪源代码时，对一些细节性的处理不予关心。又由于篇幅所限，只列出相关代码。本文中的源代码来自于linux-2.6.17内核版本。<br>在深入<code>sys_open()</code>和<code>sys_read()</code>之前，我们先概览下调用<code>sys_read()</code>的上下文。图7描述了从用户空间的<code>read()</code>调用到数据从磁盘读出的整个流程。当在用户应用程序调用文件I/O <code>read()</code>操作时，系统调用<code>sys_read()</code>被激发，<code>sys_read()</code>找到文件所在的具体文件系统，把控制权传给该文件系统，最后由具体文件系统与物理介质交互，从介质中读出数据。<br>图7. 从物理介质读数据的过程<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig7.jpg" alt="vfs-fig7.jpg" title=""></p>
<h3 id="sys-open"><a href="#sys-open" class="headerlink" title="sys_open()"></a>sys_open()</h3><p><code>sys_open()</code>系统调用打开或创建一个文件，成功返回该文件的文件描述符。图8是<code>sys_open()</code>实现代码中主要的函数调用关系图<br>图8. <code>sys_open</code>函数调用关系图<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig8.jpg" alt="vfs-fig8.jpg" title=""><br>由于<code>sys_open()</code>的代码量大，函数调用关系复杂，以下主要是对该函数做整体的解析；而对其中的一些关键点，则列出其关键代码。<br><strong>a. 从<code>sys_open()</code>的函数调用关系图可以看到，<code>sys_open()</code>在做了一些简单的参数检验后，就把接力棒传给<code>do_sys_open()</code>：</strong><br>1）、首先，<code>get_unused_fd()</code>得到一个可用的文件描述符；通过该函数，可知文件描述符实质是进程打开文件列表中对应某个文件对象的索引值；<br>2）、接着，<code>do_filp_open()</code>打开文件，返回一个<code>file</code>对象，代表由该进程打开的一个文件；进程通过这样的一个数据结构对物理文件进行读写操作。<br>3）、最后，<code>fd_install()</code>建立文件描述符与<code>file</code>对象的联系，以后进程对文件的读写都是通过操纵该文件描述符而进行。<br><strong>b. <code>do_filp_open()</code>用于打开文件，返回一个<code>file</code>对象；而打开之前需要先找到该文件：</strong><br>1）、<code>open_namei()</code>用于根据文件路径名查找文件，借助一个持有路径信息的数据结构<code>nameidata</code>而进行；<br>2）、查找结束后将填充有路径信息的<code>nameidata</code>返回给接下来的函数<code>nameidata_to_filp()</code>从而得到最终的<code>file</code>对象；当达到目的后，<code>nameidata</code>这个数据结构将会马上被释放。<br><strong>c. <code>open_namei()</code>用于查找一个文件：</strong><br>1）、<code>path_lookup_open()</code>实现文件的查找功能；要打开的文件若不存在，还需要有一个新建的过程，则调用<code>path_lookup_create()</code>，后者和前者封装的是同一个实际的路径查找函数，只是参数不一样，使它们在处理细节上有所偏差；<br>2）、当是以新建文件的方式打开文件时，即设置了<code>O_CREAT</code>标识时需要创建一个新的索引节点，代表创建一个文件。在<code>vfs_create()</code>里的一句核心语句<code>dir-&gt;i_op-&gt;create(dir, dentry, mode, nd)</code>可知它调用了具体的文件系统所提供的创建索引节点的方法。注意：这边的索引节点的概念，还只是位于内存之中，它和磁盘上的物理的索引节点的关系就像位于内存中和位于磁盘中的文件一样。此时新建的索引节点还不能完全标志一个物理文件的成功创建，只有当把索引节点回写到磁盘上才是一个物理文件的真正创建。想想我们以新建的方式打开一个文件，对其读写但最终没有保存而关闭，则位于内存中的索引节点会经历从新建到消失的过程，而磁盘却始终不知道有人曾经想过创建一个文件，这是因为索引节点没有回写的缘故。<br>3）、<code>path_to_nameidata()</code>填充<code>nameidata</code>数据结构；<br>4）、<code>may_open()</code>检查是否可以打开该文件；一些文件如链接文件和只有写权限的目录是不能被打开的，先检查<code>nd-&gt;dentry-&gt;inode</code>所指的文件是否是这一类文件，是的话则错误返回。还有一些文件是不能以<code>TRUNC</code>的方式打开的，若<code>nd-&gt;dentry-&gt;inode</code>所指的文件属于这一类，则显式地关闭<code>TRUNC</code>标志位。接着如果有以<code>TRUNC</code>方式打开文件的，则更新<code>nd-&gt;dentry-&gt;inode</code>的信息</p>
<h4 id="path-lookup-intent-open"><a href="#path-lookup-intent-open" class="headerlink" title="__path_lookup_intent_open()"></a>__path_lookup_intent_open()</h4><p>不管是<code>path_lookup_open()</code>还是<code>path_lookup_create()</code>最终都是调用<code>__path_lookup_intent_open()</code>来实现查找文件的功能。查找时，在遍历路径的过程中，会逐层地将各个路径组成部分解析成目录项对象，如果此目录项对象在目录项缓存中，则直接从缓存中获得；如果该目录项在缓存中不存在，则进行一次实际的读盘操作，从磁盘中读取该目录项所对应的索引节点。得到索引节点后，则建立索引节点与该目录项的联系。如此循环，直到最终找到目标文件对应的目录项，也就找到了索引节点，而由索引节点找到对应的超级块对象就可知道该文件所在的文件系统的类型。从磁盘中读取该目录项所对应的索引节点；这将引发VFS和实际的文件系统的一次交互。从前面的VFS理论介绍可知，读索引节点方法是由超级块来提供的。而当安装一个实际的文件系统时，在内存中创建的超级块的信息是由一个实际文件系统的相关信息来填充的，这里的相关信息就包括了实际文件系统所定义的超级块的操作函数列表，当然也就包括了读索引节点的具体执行方式。当继续追踪一个实际文件系统ext3的ext3_read_inode()时，可发现这个函数很重要的一个工作就是为不同的文件类型设置不同的索引节点操作函数表和文件操作函数表。<br>清单8. <code>ext3_read_inode</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ext3_read_inode</span><span class="params">(<span class="keyword">struct</span> inode * inode)</span></span></div><div class="line">    &#123;</div><div class="line">       ……</div><div class="line">       <span class="comment">//是普通文件</span></div><div class="line">       <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode)) &#123;</div><div class="line">          inode-&gt;i_op = &amp;ext3_file_inode_operations;</div><div class="line">          inode-&gt;i_fop = &amp;ext3_file_operations;</div><div class="line">          ext3_set_aops(inode);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</div><div class="line">          <span class="comment">//是目录文件</span></div><div class="line">          inode-&gt;i_op = &amp;ext3_dir_inode_operations;</div><div class="line">          inode-&gt;i_fop = &amp;ext3_dir_operations;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(inode-&gt;i_mode)) &#123;</div><div class="line">          <span class="comment">// 是连接文件</span></div><div class="line">          ……</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 如果以上三种情况都排除了，则是设备驱动</span></div><div class="line">          <span class="comment">//这里的设备还包括套结字、FIFO等伪设备</span></div><div class="line">          ……</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="nameidata-to-filp子函数：-dentry-open"><a href="#nameidata-to-filp子函数：-dentry-open" class="headerlink" title="nameidata_to_filp子函数：__dentry_open"></a>nameidata_to_filp子函数：__dentry_open</h4><p>这是VFS与实际的文件系统联系的一个关键点。从3.1.1小节分析中可知，调用实际文件系统读取索引节点的方法读取索引节点时，实际文件系统会根据文件的不同类型赋予索引节点不同的文件操作函数集，如普通文件有普通文件对应的一套操作函数，设备文件有设备文件对应的一套操作函数。这样当把对应的索引节点的文件操作函数集赋予文件对象，以后对该文件进行操作时，比如读操作，VFS虽然对各种不同文件都是执行同一个read()操作界面，但是真正读时，内核却知道怎么区分对待不同的文件类型。<br>清单9. <code>__dentry_open</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">static</span> <span class="keyword">struct</span> file *__dentry_open(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> vfsmount *mnt,</div><div class="line">					<span class="keyword">int</span> flags, <span class="keyword">struct</span> file *f,</div><div class="line">					<span class="keyword">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *))</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">struct</span> inode *inode;</div><div class="line">        ……</div><div class="line">        <span class="comment">//整个函数的工作在于填充一个file对象</span></div><div class="line">        ……</div><div class="line">         f-&gt;f_mapping = inode-&gt;i_mapping;</div><div class="line">        f-&gt;f_dentry = dentry;</div><div class="line">        f-&gt;f_vfsmnt = mnt;</div><div class="line">        f-&gt;f_pos = <span class="number">0</span>;</div><div class="line">        <span class="comment">//将对应的索引节点的文件操作函数集赋予文件对象的操作列表</span></div><div class="line">        f-&gt;f_op = fops_get(inode-&gt;i_fop);</div><div class="line">        ……</div><div class="line">        <span class="comment">//若文件自己定义了open操作，则执行这个特定的open操作。</span></div><div class="line">        <span class="keyword">if</span> (!open &amp;&amp; f-&gt;f_op)</div><div class="line">           open = f-&gt;f_op-&gt;open;</div><div class="line">        <span class="keyword">if</span> (open) &#123;</div><div class="line">           error = open(inode, f);</div><div class="line">           <span class="keyword">if</span> (error)</div><div class="line">              <span class="keyword">goto</span> cleanup_all;</div><div class="line">        ……</div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="sys-read"><a href="#sys-read" class="headerlink" title="sys_read()"></a>sys_read()</h3><p><code>sys_read()</code>系统调用用于从已打开的文件读取数据。如read成功，则返回读到的字节数。如已到达文件的尾端，则返回0。图9是<code>sys_read()</code>实现代码中的函数调用关系图。<br>图9. <code>sys_read</code>函数调用关系图<br><img src="/kernel/内核文件系统/linux-vfs/vfs-fig9.jpg" alt="vfs-fig9.jpg" title=""><br>对文件进行读操作时，需要先打开它。从3.1小结可知，打开一个文件时，会在内存组装一个文件对象，希望对该文件执行的操作方法已在文件对象设置好。所以对文件进行读操作时，VFS在做了一些简单的转换后（由文件描述符得到其对应的文件对象；其核心思想是返回<code>current-&gt;files-&gt;fd[fd]</code>所指向的文件对象），就可以通过语句<code>file-&gt;f_op-&gt;read(file, buf, count, pos)</code>轻松调用实际文件系统的相应方法对文件进行读操作了。</p>
<h2 id="4-解决问题"><a href="#4-解决问题" class="headerlink" title="4 解决问题"></a>4 解决问题</h2><h3 id="跨文件系统的文件操作的基本原理"><a href="#跨文件系统的文件操作的基本原理" class="headerlink" title="跨文件系统的文件操作的基本原理"></a>跨文件系统的文件操作的基本原理</h3><p>到此，我们也就能够解释在Linux中为什么能够跨文件系统地操作文件了。举个例子，将vfat格式的磁盘上的一个文件a.txt拷贝到ext3格式的磁盘上，命名为b.txt。这包含两个过程，对a.txt进行读操作，对b.txt进行写操作。读写操作前，需要先打开文件。由前面的分析可知，打开文件时，VFS会知道该文件对应的文件系统格式，以后操作该文件时，VFS会调用其对应的实际文件系统的操作方法。所以，VFS调用vfat的读文件方法将a.txt的数据读入内存；在将a.txt在内存中的数据映射到b.txt对应的内存空间后，VFS调用ext3的写文件方法将b.txt写入磁盘；从而实现了最终的跨文件系统的复制操作。</p>
<h3 id="“一切皆是文件”的实现根本"><a href="#“一切皆是文件”的实现根本" class="headerlink" title="“一切皆是文件”的实现根本"></a>“一切皆是文件”的实现根本</h3><p>不论是普通的文件，还是特殊的目录、设备等，VFS都将它们同等看待成文件，通过同一套文件操作界面来对它们进行操作。操作文件时需先打开；打开文件时，VFS会知道该文件对应的文件系统格式；当VFS把控制权传给实际的文件系统时，实际的文件系统再做出具体区分，对不同的文件类型执行不同的操作。这也就是“一切皆是文件”的根本所在。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>VFS即虚拟文件系统是Linux文件系统中的一个抽象软件层；因为它的支持，众多不同的实际文件系统才能在Linux中共存，跨文件系统操作才能实现。VFS借助它四个主要的数据结构即超级块、索引节点、目录项和文件对象以及一些辅助的数据结构，向Linux中不管是普通的文件还是目录、设备、套接字等都提供同样的操作界面，如打开、读写、关闭等。只有当把控制权传给实际的文件系统时，实际的文件系统才会做出区分，对不同的文件类型执行不同的操作。由此可见，正是有了VFS的存在，跨文件系统操作才能执行，Unix/Linux中的“一切皆是文件”的口号才能够得以实现。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1].Claudia Salzberg Rodriguez, Gordon Fischer, Steven Smolski. The Linux Kernel Primer.机械工业出版社.2006.7<br>[2].Robert Love.Linux内核设计与实现(第二版).机械工业出版社.2007.1<br>[3].Stevens W.Richard.Unix环境高级编程(第二版).人民邮电出版社.2006<br>[4].杨芙清，陈向群.操作系统教程.北京大学出版社.2005.7<br>[5].Linux-2.6.17.13内核源代码</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[platform_get_resource 函数实现细节]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/analysis-of-platform-get-resource/</url>
      <content type="html"><![CDATA[<p>参考原文：<a href="http://bbs.ednchina.com/BLOG_ARTICLE_3008325.HTM" target="_blank" rel="external">http://bbs.ednchina.com/BLOG_ARTICLE_3008325.HTM</a></p>
<p><code>platform_get_resource</code> 函数源码如下：<br>1）新内核实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> resource *<span class="title">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev,</span></span></div><div class="line">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</div><div class="line">              <span class="keyword">struct</span> resource *r = &amp;dev-&gt;resource[i];</div><div class="line">              <span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</div><div class="line">                     <span class="keyword">return</span> r;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(platform_get_resource);</div></pre></td></tr></table></figure></p>
<p>2）旧内核实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *      platform_get_resource - get a resource for a device</div><div class="line"> *      @dev: platform device</div><div class="line"> *      @type: resource type</div><div class="line"> *      @num: resource index</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">struct</span> resource *</span></div><div class="line"><span class="title">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type,</span></div><div class="line">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</div><div class="line">                <span class="keyword">struct</span> resource *r = &amp;dev-&gt;resource[i];</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((r-&gt;flags &amp; (IORESOURCE_IO|IORESOURCE_MEM|</div><div class="line">                                 IORESOURCE_IRQ|IORESOURCE_DMA))</div><div class="line">                    == type)</div><div class="line">                        <span class="keyword">if</span> (num-- == <span class="number">0</span>)</div><div class="line">                                <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(platform_get_resource);</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>函数分析：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> resource *r = &amp;dev-&gt;resource[i];</div></pre></td></tr></table></figure></p>
<p>这行代码使得不管你是想获取哪一份资源都从第一份资源开始搜索。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>这行代码首先通过 <code>type == resource_type(r)</code> 判断当前这份资源的类型是否匹配，如果匹配则再通过 <code>num-- == 0</code> 判断是否是你要的，如果不匹配重新提取下一份资源而不会执行 <code>num-- == 0</code> 这一句代码。</p>
<p>通过以上两步就能定位到你要找的资源了，接着把资源返回即可。如果都不匹配就返回<code>NULL</code>。</p>
<p><strong>实例分析：</strong></p>
<p>下面通过一个例子来看看它是如何拿到设备资源的。<br>设备资源如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> resource s3c_buttons_resource[] = &#123;</div><div class="line">       [<span class="number">0</span>]=&#123;</div><div class="line">              .start = S3C24XX_PA_GPIO,</div><div class="line">              .end   = S3C24XX_PA_GPIO + S3C24XX_SZ_GPIO - <span class="number">1</span>,</div><div class="line">              .flags = IORESOURCE_MEM,</div><div class="line">       &#125;,</div><div class="line">       [<span class="number">1</span>]=&#123;</div><div class="line">              .start = IRQ_EINT8,</div><div class="line">              .end   = IRQ_EINT8,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;,</div><div class="line">       [<span class="number">2</span>]=&#123;</div><div class="line">              .start = IRQ_EINT11,</div><div class="line">              .end   = IRQ_EINT11,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;,</div><div class="line">       [<span class="number">3</span>]=&#123;</div><div class="line">              .start = IRQ_EINT13,</div><div class="line">              .end   = IRQ_EINT13,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;,</div><div class="line">       [<span class="number">4</span>]=&#123;</div><div class="line">              .start = IRQ_EINT14,</div><div class="line">              .end   = IRQ_EINT14,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;,</div><div class="line"></div><div class="line">       [<span class="number">5</span>]=&#123;</div><div class="line">              .start = IRQ_EINT15,</div><div class="line">              .end   = IRQ_EINT15,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;,</div><div class="line">       [<span class="number">6</span>]=&#123;</div><div class="line">              .start = IRQ_EINT19,</div><div class="line">              .end   = IRQ_EINT19,</div><div class="line">              .flags = IORESOURCE_IRQ,</div><div class="line">       &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>驱动中通过下面代码拿到第一份资源：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> resource *res;</div><div class="line">res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>函数进入 <code>for</code> 里面，<code>i=0</code>，<code>num_resources=7</code>，拿出 <code>resource[0]</code> 资源。<code>resource_type(r)</code> 提取出该份资源的资源类型并与函数传递下来的资源类型进行比较，匹配。<code>Num=0</code> (这里先判断是否等于<code>0</code>再自减<code>1</code>) 符合要求，从而返回该资源。</p>
<p>获取剩下资源的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</div><div class="line">             buttons_irq = platform_get_resource(pdev,IORESOURCE_IRQ,i);</div><div class="line">             <span class="keyword">if</span>(buttons_irq == <span class="literal">NULL</span>)&#123;</div><div class="line">                  dev_err(dev,<span class="string">"no irq resource specified\n"</span>);</div><div class="line">                   ret = -ENOENT;</div><div class="line">                   <span class="keyword">goto</span> err_map;</div><div class="line">              &#125;</div><div class="line">              button_irqs[i] = buttons_irq-&gt;start;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分析如下：<br>For第一次循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buttons_irq = platform_get_resource(pdev,IORESOURCE_IRQ,<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>在拿出第一份资源进行 <code>resource_type(r)</code> 判断资源类型时不符合(此时 <code>num-- == 0</code> 这句没有执行)，进而拿出第二份资源，此时 <code>i=1</code>，<code>num_resources=7</code>，<code>num</code> 传递下来为<code>0</code>，资源类型判断时候匹配，<code>num</code> 也等于 <code>0</code>，从而确定资源并返回。</p>
<p>For第二次循环：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buttons_irq = platform_get_resource(pdev,IORESOURCE_IRQ,<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>拿出第二份资源的时候 <code>resource_type(r)</code> 资源类型匹配，但是 <code>num</code> 传递下来时候为 <code>1</code>，执行 <code>num-- == 0</code> 时不符合(但 <code>num</code> 开始自减 <code>1</code>，这导致拿出第三份资源时 <code>num==0</code>)，只好拿出第三份资源。剩下的以此类推。</p>
<p>总结：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> resource *<span class="title">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev,</span></span></div><div class="line">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</div></pre></td></tr></table></figure></p>
<p><code>unsigned int type</code> 决定资源的类型，<code>unsigned int num</code> 决定<code>type</code>类型的第几份资源（<span style="color:red;">从<code>0</code>开始</span>）。即使同类型资源在资源数组中不是连续排放也可以定位得到该资源。<br>比如第一份 <code>IORESOURCE_IRQ</code> 类型资源在 <code>resource[2]</code>，而第二份在 <code>resource[5]</code>，那<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">platform_get_resource(pdev,IORESOURCE_IRQ,<span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>可以定位第一份<code>IORESOURCE_IRQ</code>资源；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">platform_get_resource(pdev,IORESOURCE_IRQ,<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>可以定位第二份 <code>IORESOURCE_IRQ</code> 资源。</p>
<p>之所以能定位到资源，在于函数实现中的这一行代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type == resource_type(r) &amp;&amp; num-- == <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>该行代码，如果没有匹配资源类型，<code>num-- == 0</code> 不会执行而重新提取下一份资源，只有资源匹配了才会寻找该类型的第几份资源，即使这些资源排放不连续。</p>
<p><span style="color:red;"><code>num</code> 代表的不是 <code>resource</code> 数组的数组号，而是具有相同资源类型的序号 (从<code>0</code>开始的序号)。</span></p>
<p>同类函数：<br><strong>platform_get_irq</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *      platform_get_irq - get an IRQ for a device</div><div class="line"> *      @dev: platform device</div><div class="line"> *      @num: IRQ number index</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> resource *r = platform_get_resource(dev, IORESOURCE_IRQ, num);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> r ? r-&gt;start : -ENXIO;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(platform_get_irq);</div></pre></td></tr></table></figure></p>
<p><strong>platform_get_resource_byname</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *      platform_get_resource_byname - get a resource for a device by name</div><div class="line"> *      @dev: platform device</div><div class="line"> *      @type: resource type</div><div class="line"> *      @name: resource name</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">struct</span> resource *</span></div><div class="line"><span class="title">platform_get_resource_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type,</span></div><div class="line">                      <span class="keyword">char</span> *name)</div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dev-&gt;num_resources; i++) &#123;</div><div class="line">                <span class="keyword">struct</span> resource *r = &amp;dev-&gt;resource[i];</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ((r-&gt;flags &amp; (IORESOURCE_IO|IORESOURCE_MEM|</div><div class="line">                                 IORESOURCE_IRQ|IORESOURCE_DMA)) == type)</div><div class="line">                        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(r-&gt;name, name))</div><div class="line">                                <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(platform_get_resource_byname);</div></pre></td></tr></table></figure></p>
<p><strong>platform_get_irq_byname</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *      platform_get_irq_byname - get an IRQ for a device</div><div class="line"> *      @dev: platform device</div><div class="line"> *      @name: IRQ name</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">platform_get_irq_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">char</span> *name)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">struct</span> resource *r = platform_get_resource_byname(dev, IORESOURCE_IRQ, name);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> r ? r-&gt;start : -ENXIO;</div><div class="line">&#125;</div><div class="line">EXPORT_SYMBOL_GPL(platform_get_irq_byname);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux Platform Device and Driver]]></title>
      <url>https://jarsonfang.github.io/kernel/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/linux-platform-device-and-driver/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://blog.csdn.net/yili_xie/article/details/5187014" target="_blank" rel="external">http://blog.csdn.net/yili_xie/article/details/5187014</a></p>
<p>从 Linux 2.6 起引入了一套新的驱动管理和注册机制: <code>platform_device</code> 和 <code>platform_driver</code> 。<br>Linux 中大部分的设备驱动，都可以使用这套机制 , 设备用 <code>platform_device</code> 表示，驱动用 <code>platform_driver</code> 进行注册。</p>
<p>Linux platform driver 机制和传统的 device driver 机制 ( 通过 <code>driver_register</code> 函数进行注册 ) 相比，一个十分明显的优势在于 platform 机制将设备本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过 platform device 提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性 ( 这些标准接口是安全的 ) 。</p>
<p>Platform 机制的本身使用并不复杂，由两部分组成： <code>platform_device</code> 和 <code>platform_driver</code>。<br>通过 Platform 机制开发发底层驱动的大致流程为:<br>1）定义 <code>platform_device</code><br>2）注册 <code>platform_device</code><br>3）定义 <code>platform_driver</code><br>4）注册 <code>platform_driver</code><br><a id="more"></a></p>
<p>首先要确认的就是设备的资源信息，例如设备的地址，中断号等。<br>在 2.6 内核中 platform 设备用结构体 <code>platform_device</code> 来描述，该结构体定义在 <code>kernel/include/linux/platform_device.h</code> 中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_device &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    u32  id;</div><div class="line">    <span class="keyword">struct</span> device dev;</div><div class="line">    u32  num_resources;</div><div class="line">    <span class="keyword">struct</span> resource *resource;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>该结构一个重要的元素是 <code>resource</code> ，该元素存入了最为重要的设备资源信息，定义在 <code>kernel/include/linux/ioport.h</code> 中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> resource &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start, end;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</div><div class="line">    <span class="keyword">struct</span> resource *parent, *sibling, *child;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面举 s3c2410 平台的 i2c 驱动作为例子来说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* arch/arm/mach-s3c2410/devs.c */</span></div><div class="line"><span class="comment">/* I2C */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> resource s3c_i2c_resource[ ] = &#123;</div><div class="line">         [<span class="number">0</span>] = &#123;</div><div class="line">                   .start = S3C24XX_PA_IIC,</div><div class="line">                   .end = S3C24XX_PA_IIC + S3C24XX_SZ_IIC - <span class="number">1</span>,</div><div class="line">                   .flags = IORESOURCE_MEM,</div><div class="line">         &#125; ,</div><div class="line">         [<span class="number">1</span>] = &#123;</div><div class="line">                   .start = IRQ_IIC, <span class="comment">//S3C2410_IRQ(27)</span></div><div class="line">                   .end = IRQ_IIC,</div><div class="line">                   .flags = IORESOURCE_IRQ,</div><div class="line">         &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里定义了两组 <code>resource</code> ，它描述了一个 I2C 设备的资源，第 1 组描述了这个 I2C 设备所占用的总线地址范围， <code>IORESOURCE_MEM</code> 表示第 1 组描述的是内存类型的资源信息，第 2 组描述了这个 I2C 设备的中断号， <code>IORESOURCE_IRQ</code> 表示第 2 组描述的是中断资源信息。设备驱动会根据 <code>flags</code> 来获取相应的资源信息。</p>
<p>有了 <code>resource</code> 信息，就可以定义 <code>platform_device</code> 了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> platform_device s3c_device_i2c = &#123;</div><div class="line">         .name = <span class="string">"s3c2410-i2c"</span>,</div><div class="line">         .id = <span class="number">-1</span>,</div><div class="line">         .num_resources = ARRAY_SIZE(s3c_i2c_resource),</div><div class="line">         .resource = s3c_i2c_resource,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义好了 <code>platform_device</code> 结构体后就可以调用函数 <code>platform_add_devices</code> 向系统中添加该设备了，之后可以调用 <code>platform_driver_register()</code> 进行设备注册。要注意的是，这里的 <code>platform_device</code> 设备的注册过程必须在相应设备驱动加载之前被调用，即执行 <code>platform_driver_register</code> 之前 , 原因是因为驱动注册时需要匹配内核中所以已注册的设备名。</p>
<p><code>s3c2410-i2c</code> 的 <code>platform_device</code> 是在系统启动时，在 <code>cpu.c</code> 里的 <code>s3c_arch_init()</code> 函数里进行注册的，这个函数申明为 <code>arch_initcall(s3c_arch_init);</code> 会在系统初始化阶段被调用。<br><code>arch_initcall</code> 的优先级高于 <code>module_init</code> 。所以会在 Platform 驱动注册之前调用。 (详细参考 <code>include/linux/init.h</code>)</p>
<p><code>s3c_arch_init</code> 函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* arch/arm/mach-3sc2410/cpu.c */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">s3c_arch_init</span><span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    ……</div><div class="line"><span class="comment">/* 这里board指针指向在mach-smdk2410.c里的定义的smdk2410_board，里面包含了预先定义的I2C Platform_device等. */</span></div><div class="line">    <span class="keyword">if</span> ( board != <span class="literal">NULL</span> ) &#123;</div><div class="line">        <span class="keyword">struct</span> platform_device **ptr = board-&gt;devices;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; board-&gt;devices_count; i++ , ptr++ ) &#123;</div><div class="line">            ret = platform_device_register(*ptr) ;      <span class="comment">//在这里进行注册</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ret) &#123;</div><div class="line">                printk( KERN_ERR <span class="string">"s3c24xx: failed to add board device %s (%d) @%p/n"</span> , (*ptr)-&gt;name,</div><div class="line">ret, *ptr) ;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">         <span class="comment">/* mask any error, we may not need all these board</span></div><div class="line">         * devices */</div><div class="line">        ret = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时被注册还有很多其他平台的 <code>platform_device</code> ，详细查看 <code>arch/arm/mach-s3c2410/mach-smdk2410.c</code> 里的 <code>smdk2410_devices</code> 结构体。</p>
<p>驱动程序需要实现结构体 <code>struct platform_driver</code> ，参考 <code>drivers/i2c/busses</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* device driver for platform bus bits */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> platform_driver s3c2410_i2c_driver = &#123;</div><div class="line">         .probe = s3c24xx_i2c_probe,</div><div class="line">         .remove = s3c24xx_i2c_remove,</div><div class="line">         .resume = s3c24xx_i2c_resume,</div><div class="line">         .driver = &#123;</div><div class="line">                   .owner = THIS_MODULE,</div><div class="line">                   .name = <span class="string">"s3c2410-i2c"</span> ,</div><div class="line">         &#125; ,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在驱动初始化函数中调用函数 <code>platform_driver_register()</code> 注册 <code>platform_driver</code> ，需要注意的是 <code>s3c_device_i2c</code> 结构中 <code>name</code> 元素和 <code>s3c2410_i2c_driver</code> 结构中 <code>driver.name</code> 必须是相同的，这样在 <code>platform_driver_register()</code> 注册时会对所有已注册的所有 <code>platform_device</code> 中的 <code>name</code> 和当前注册的 <code>platform_driver</code> 的 <code>driver.name</code> 进行比较，只有找到相同的名称的 <code>platform_device</code> 才能注册成功，当注册成功时会调用 <code>platform_driver</code> 结构元素 <code>probe</code> 函数指针，这里就是<code>s3c24xx_i2c_probe</code>, 当进入 <code>probe</code> 函数后，需要获取设备的资源信息，常用获取资源的函数主要是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> resource *<span class="title">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</div></pre></td></tr></table></figure></p>
<p>根据参数 <code>type</code> 所指定类型，例如 <code>IORESOURCE_MEM</code> ，来获取指定的资源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">struct</span> <span class="keyword">int</span> <span class="title">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</div></pre></td></tr></table></figure></p>
<p>获取资源中的中断号。</p>
<p>下面举 <code>s3c24xx_i2c_probe</code> 函数分析 , 看看这些接口是怎么用的。<br>前面已经讲了， <code>s3c2410_i2c_driver</code> 注册成功后会调用 <code>s3c24xx_i2c_probe</code> 执行，下面看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* drivers/i2c/busses/i2c-s3c2410.c */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c24xx_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> s3c24xx_i2c *i2c = &amp;s3c24xx_i2c;</div><div class="line">    <span class="keyword">struct</span> resource *res;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="comment">/* find the clock and enable it */</span></div><div class="line"></div><div class="line">    i2c-&gt;dev = &amp;pdev-&gt; dev;</div><div class="line">    i2c-&gt;clk = clk_get( &amp;pdev-&gt;dev, <span class="string">"i2c"</span> ) ;</div><div class="line">    <span class="keyword">if</span> (IS_ERR( i2c-&gt; clk) ) &#123;</div><div class="line">     dev_err(&amp;pdev-&gt;dev, <span class="string">"cannot get clock/n"</span> ) ;</div><div class="line">     ret = -ENOENT;</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dev_dbg(&amp;pdev-&gt;dev, <span class="string">"clock source %p/n"</span> , i2c-&gt;clk) ;</div><div class="line">    clk_enable(i2c-&gt;clk) ;</div><div class="line"></div><div class="line">    <span class="comment">/* map the registers */</span></div><div class="line">    res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>) ; <span class="comment">/* 获取设备的IO资源地址 */</span></div><div class="line">    <span class="keyword">if</span> ( res == <span class="literal">NULL</span> ) &#123;</div><div class="line">     dev_err(&amp;pdev-&gt;dev, <span class="string">"cannot find IO resource/n"</span>) ;</div><div class="line">     ret = -ENOENT;</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    i2c-&gt;ioarea = request_mem_region(res-&gt;start, (res-&gt;end- res-&gt;start) + <span class="number">1</span>, pdev-&gt;name) ; <span class="comment">/* 申请这块IO Region */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( i2c-&gt;ioarea == <span class="literal">NULL</span> ) &#123;</div><div class="line">     dev_err(&amp;pdev-&gt;dev, <span class="string">"cannot request IO/n"</span> ) ;</div><div class="line">     ret = -ENXIO;</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    i2c-&gt;regs = ioremap(res-&gt;start, (res-&gt;end- res-&gt;start) + <span class="number">1</span>) ; <span class="comment">/* 映射至内核虚拟空间 */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( i2c-&gt;regs == <span class="literal">NULL</span> ) &#123;</div><div class="line">     dev_err( &amp;pdev-&gt;dev, <span class="string">"cannot map IO/n"</span> ) ;</div><div class="line">     ret = -ENXIO;</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dev_dbg(&amp;pdev-&gt;dev, <span class="string">"registers %p (%p, %p)/n"</span> , i2c-&gt;regs, i2c-&gt;ioarea, res) ;</div><div class="line"></div><div class="line">    <span class="comment">/* setup info block for the i2c core */</span></div><div class="line">    i2c-&gt;adap.algo_data = i2c;</div><div class="line">    i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;</div><div class="line"></div><div class="line">    <span class="comment">/* initialise the i2c controller */</span></div><div class="line">    ret = s3c24xx_i2c_init(i2c) ;</div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line"></div><div class="line">    <span class="comment">/* find the IRQ for this unit (note, this relies on the init call to ensure no current IRQs pending */</span></div><div class="line"></div><div class="line">    res = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>) ; <span class="comment">/* 获取设备IRQ中断号 */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( res == <span class="literal">NULL</span> ) &#123;</div><div class="line">     dev_err( &amp;pdev-&gt;dev, <span class="string">"cannot find IRQ/n"</span> ) ;</div><div class="line">     ret = -ENOENT;</div><div class="line">     <span class="keyword">goto</span> out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ret = request_irq(res-&gt;start, s3c24xx_i2c_irq, IRQF_DISABLED, <span class="comment">/* 申请IRQ */</span></div><div class="line">     pdev-&gt;name, i2c) ;</div><div class="line"></div><div class="line">    ……</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>小思考：</strong><br>那什么情况可以使用 platform driver 机制编写驱动呢？<br>我的理解是只要和内核本身运行依赖性不大的外围设备 ( 换句话说只要不在内核运行所需的一个最小系统之内的设备 ), 相对独立的 , 拥有各自独自的资源 (addresses and IRQs) ， 都可以用 <code>platform_driver</code> 实现。如： lcd,usb,uart 等，都可以用 <code>platform_driver</code> 写，而 timer,irq 等最小系统之内的设备则最好不用 <code>platform_driver</code> 机制，实际上内核实现也是这样的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[羊皮卷的故事（《世界上最伟大的推销员》节选）]]></title>
      <url>https://jarsonfang.github.io/life/the-greatest-salesman-of-the-world/</url>
      <content type="html"><![CDATA[<h2 id="开始新的生活"><a href="#开始新的生活" class="headerlink" title="开始新的生活"></a>开始新的生活</h2><p> 成功是一种精神状态。人们对于成功的定义，见仁见智，而失败却往往只有一种解释：失败就是一个人没能达到他的人生目标，不论这些目标是什么。事实上，成功与失败的最大分别，来自不同的习惯。好习惯是开启成功的钥匙，坏习惯则是一扇向失败敞开的门。<br> <span style="color: #cc00cc">只有一种习惯才能抑制另一种习惯。经过多次重复，一种看似复杂的行为就变得轻而易举，实行起来，就会有无限的乐趣，有了乐趣，出于人之天性，人们就更乐意常去实行。于是，一种好的习惯便诞生了，习惯成为自然。既是一种好的习惯，也就是我们的意愿。</span><br> 经验确实能教给我们很多东西，只是这需要花费太长的时间。等到人们获得智慧的时候，其价值已随着时间的消逝而减少了。结果往往是这样，经验丰富了，人也余生无多。经验和时尚有关，适合某一时代的行为，并不意味着在今天仍然行得通。<br> 爬出满是失败创伤的老茧，开始新的生活。</p>
<h2 id="用全身心的爱来迎接今天"><a href="#用全身心的爱来迎接今天" class="headerlink" title="用全身心的爱来迎接今天"></a>用全身心的爱来迎接今天</h2><p>强力能够劈开一块盾牌，甚至毁灭生命，但是只有爱才具有无与伦比的力量。爱，使得挫折变得如春雨般温和；爱是打开人们心靡的钥匙，也是抵挡仇恨之箭与愤怒之矛的盾牌。<br> 爱每个人的言谈举止，因为人人都有值得钦佩的性格，虽然有时不易察觉。用爱摧毁困住人们心灵的那充满怀疑与仇恨的围墙，用爱铺一座通向人们心灵的桥梁。<br> <span style="color: #cc00cc">用 全身心的爱来迎接今天，最主要的，要爱自己。只有这样，才会认真检查进入自己身体，思想，精神，头脑，灵魂，心怀的一切东西。绝不能放纵肉体的需求，要用 清洁与节制来珍惜自己的身体；绝不让头脑受到邪恶与绝望的引诱，要用智慧和知识使之升华；绝不让灵魂陷入自满的状态，要用沉思和祈祷来滋润它；绝不让心怀 狭窄，要与人分享，使它成长，温暖整个世界。</span><br> 爱所有的人，仇恨将从我们的血管中流走。没有时间去恨，只有时间去爱。</p>
<h2 id="坚持不懈，直到成功"><a href="#坚持不懈，直到成功" class="headerlink" title="坚持不懈，直到成功"></a>坚持不懈，直到成功</h2><p>在古老的东方，挑选小公牛到竞技场格斗有一定的程序。它们被带进场地，向手待长矛的斗牛士攻击，裁判以它受戳后再向斗牛士进攻的次数多寡来评定这只公牛的勇敢程度。我们的生命每天都在接受类似的考验。只有坚韧不拔，勇往直前，迎接挑战，才会取得成功。<br> <span style="color: #cc00cc">生 命的奖赏远在旅途终点，而非起点附近。每天的奋斗就像对参天大树的一次砍击，头几刀可能了无痕迹，每一击看似微不足道，然而，累积起来，巨树终会倒下。就 像冲洗高山的雨滴，吞噬猛虎的蚂蚁，照亮大地的星辰，建起金字塔的奴隶，我们也要一砖一瓦地建造起自己的城堡。只要持之以恒终会水滴石穿，到达成功彼岸。</span></p>
<h2 id="自然界最伟大的奇迹"><a href="#自然界最伟大的奇迹" class="headerlink" title="自然界最伟大的奇迹"></a>自然界最伟大的奇迹</h2><p>世界上没有相同的两片叶子，我们的头脑、心灵、眼睛、耳朵、双手、头发、嘴唇都是与众不同的。言谈举止完全一样的人以前没有，现在没有，以后也不会有。虽然四海之内皆兄弟，然而人人各异。我们皆为独一无二的造化。<br> <span style="color: #cc00cc">不再为昨日的成绩沾沾自喜，自吹自擂。我们能做的比已经完成的更好。我们的出生并非最后一样奇迹，为什么自己不能再创奇迹呢</span><br>飞禽走兽、花草树木、风雨山石、河流湖泊，都没有像我们一样的起源，我们孕育在爱中，肩负使命而生。自然界不知何谓失败，终以胜利者的姿态出现，我们也要如此。</p>
<h2 id="假如今天是生命中的最后一天"><a href="#假如今天是生命中的最后一天" class="headerlink" title="假如今天是生命中的最后一天"></a>假如今天是生命中的最后一天</h2><p>如何利用这最后、最宝贵的一天呢？不再为昨日的不幸而叹息，过去的已够不幸，不要再赔上今日的运道。也不再痴想明天，明天是一个未知数，为什么要把今天的精力浪费在未知的事上？想着明天的种种，今天的时光也白白流逝了。<br>假如今天是生命中的最后一天。这是仅有的一天，是现实的永恒。<span style="color: #cc00cc">生命只有一次，而人生也不过是时间的累积。若让今天的时光白白流逝，就等于毁掉人生最后一页。</span>因此，要珍惜今天的一分一秒，因为它们将一去不复返。我们无法把今天存入银行，明天再来取用。时间像风一样不可捕捉。每一分一秒，得用双手捧住，用爱心抚摸，因为它们如此宝贵。垂死的人用毕生的钱财都无法换得一口生气。我们无法计算时间的价值，它们是无价之宝！</p>
<h2 id="学会控制情绪"><a href="#学会控制情绪" class="headerlink" title="学会控制情绪"></a>学会控制情绪</h2><p>潮起潮落，冬去春来，夏末秋至，日出日落，月圆月缺，雁来雁往，花飞花谢，草长瓜熟，自然界万物都在循环往复的变化中，人的情绪也会时好时坏。<br> 我们心中像有一只轮子不停地转着，由乐而悲，由悲而喜，由喜而忧。这就好比花儿的变化，今天绽放的喜悦也会变成凋谢时的绝望。但要记住，正如今天枯败的花儿蕴藏着明天新生的种子，今天的悲伤也预示着明天的欢乐。<br> 花草树木，随着气候的变化而生长，但是我们可以为自己创造天气，用自己的心灵弥补气候的不足<span style="color: #cc00cc">。“弱者任思绪控制行为，强者让行为控制思绪”，</span>我们要学会这个千古秘诀。宽容怒气冲冲的人，忍受他的指责与辱骂，因为他尚未懂得控制自己的情绪，也许明天他就会改变，重新变得随和。<br>当你领悟了人类情绪变化的奥秘，对于自己千变万化的情绪，就不再听之任之，只有积极主动地控制情绪，才能掌握自己的命运。</p>
<h2 id="笑遍世界"><a href="#笑遍世界" class="headerlink" title="笑遍世界"></a>笑遍世界</h2><p> 笑自己，因为自视甚高的人往往显得滑稽，千万不能跌进这个精神陷阱。虽说自己是造物主最伟大的奇迹，自己不也是沧海一栗吗？我们真的知道自己是从哪里来，要到哪里去吗？现在所关心的事情，十年后看来，不会显得愚蠢吗？<br> <span style="color: #cc00cc">世 上种种到头来都会成为过去。心力衰竭时，要安慰自己，这一切都会过去；因成功而洋洋得意时，要提醒自己，这一切都会过去；穷困潦倒时，要告诉自己，这一切 都会过去；腰缠万贯时，也要告诉自己，这一切都会过去。是的，昔日修筑金宇塔的人早已作古，埋在冰冷的石头下面，而金宇塔有朝一日，也会埋在沙土下面。如 果世上种种终必成空，那又为何要对今天的得失斤斤计较？</span><br>用笑声点缀今天，用歌声照亮黑夜。不再苦苦寻觅快乐，要在繁忙的工作中忘记悲伤。享受今天的快乐，因为它不像粮食一样可以贮藏，更不似美酒越陈越香。<br>笑声中，一切都显露本色。笑自己的失败，它们将化为梦的云彩；笑自己的成功，它们回复本来面目；笑邪恶，它们将远我而去；笑善良，它们将发扬光大。</p>
<h2 id="加倍重视自己的价值"><a href="#加倍重视自己的价值" class="headerlink" title="加倍重视自己的价值"></a>加倍重视自己的价值</h2><p>桑叶在天才的手中变成了丝绸，粘土在天才的手中变成了堡垒，柏树在天才的手中变成了殿堂，羊毛在天才的手中变成了袈裟。如果桑叶、粘土、柏树、羊毛经过人的创造，可以成百上千倍地提高自身的价值，那么我们为什么不能使自己身价百倍呢？<br> 我们的命运如同一颗麦粒，有着三种不同的道路。一颗麦粒可能被装进麻袋，堆在货架上，等着喂猪；也可能被磨成面粉，做成面包；还可能撤在土壤里，让它生长，直到金黄色的麦穗上结出成千上百颗麦粒。我们和一颗麦粒唯一的不同在于麦粒无法选择是变得腐烂还是做成面包，或是种植生长，而我们有选择的自由。不要让生命腐烂，也不要让它在失败，绝望的岩石下被磨碎，任人摆布。<br> <span style="color: #cc00cc">要 想让麦粒生长、结实，必须把它种植在黑暗的泥土中，失败、失望、无知、无能便是那黑暗的泥土，深深地扎根于泥土中，等待成熟。麦粒在阳光雨露的哺育下，终 将发芽、开花、结实。同样，我们也要健全自己的身体和心灵，以实现自己的梦想。麦粒须等待大自然的契机方能成熟，我们却无须等待，因为我们有选择自己命运 的能力。</span><br> 一颗麦粒增加数倍以后，可以变成数千株麦苗，再把这些麦苗增加数倍，如此数十次，它们可以供养世上所有的城市。难道我们不如一颗麦粒吗？</p>
<h2 id="现在就付诸行动"><a href="#现在就付诸行动" class="headerlink" title="现在就付诸行动"></a>现在就付诸行动</h2><p>一张地图，不论多么详尽，比例多精确，它永远不可能带着它的主人在地面上移动半步；一个国家的法律，不论多么公正，永远不可能防止罪恶的发生。我们的幻想 毫无价值，我们的计划渺如尘埃，我们的目标不可能达到，一切的一切毫无意义——除非我们付诸行动。只有行动才能使地图、法律、梦想、计划、目标具有现实的 意义。<br> <span style="color: #cc00cc">拖延就会使人裹足不前，它来自恐惧。要想克服恐惧，就必须毫不犹豫，起而行动，唯其如此，心中的慌乱方得以平定。行动会使猛狮般的恐惧，减缓为蚂蚁般的平静。要记住萤火虫的启迪：只有在振翅的时候，才能发出光芒。</span><br>现在是我们的所有，明日是为懒汉保留的工作日。现在就付诸行动。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 函数参数]]></title>
      <url>https://jarsonfang.github.io/tools/sed-awk/sed-functions/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">fhc2007@fhc2007-desktop:~$ sed --help</div><div class="line">用法: sed [选项]... &#123;脚本(如果没有其他脚本)&#125; [输入文件]...</div><div class="line"></div><div class="line">  -n, --quiet, --silent</div><div class="line">                 取消自动打印模式空间</div><div class="line">  <span class="_">-e</span> 脚本, --expression=脚本</div><div class="line">                 添加“脚本”到程序的运行列表</div><div class="line">  <span class="_">-f</span> 脚本文件, --file=脚本文件</div><div class="line">                 添加“脚本文件”到程序的运行列表</div><div class="line">  -i[扩展名], --in-place[=扩展名]</div><div class="line">                 直接修改文件(如果指定扩展名就备份文件)</div><div class="line">  <span class="_">-l</span> N, --line-length=N</div><div class="line">                 指定“l”命令的换行期望长度</div><div class="line">  --posix</div><div class="line">                 关闭所有 GNU 扩展</div><div class="line">  -r, --regexp-extended</div><div class="line">                 在脚本中使用扩展正则表达式</div><div class="line">  <span class="_">-s</span>, --separate</div><div class="line">                 将输入文件视为各个独立的文件而不是一个长的连续输入</div><div class="line">  -u, --unbuffered</div><div class="line">                 从输入文件读取最少的数据，更频繁的刷新输出</div><div class="line">      --help     打印帮助并退出</div><div class="line">      --version  输出版本信息并退出</div></pre></td></tr></table></figure>
<p><span style="color:#ff0000">如果没有 -e, –expression, -f 或 –file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准输入读取数据。</span></p>
<p><strong>注：-n 参数和 -i 参数不要一起使用。</strong></p>
<p>本章将以一节一个函数参数的方式 ,介绍所有 sed 提供的函数参数 , 其中有</p>
<p>|<a href="#s">s</a>|<a href="#d">d</a>|<a href="#a">a</a>|<a href="#i">i</a>|<a href="#c">c</a>|<a href="#p">p</a>|<a href="#l">l</a>|<a href="#r">r</a>|<a href="#w">w</a>|<a href="#y">y</a>|<a href="#!">!</a>|<a href="#n">n</a>|<a href="#q">q</a>|<a href="#equal">=</a>|<a href="#com">#</a>|<a href="#Next">N</a>|<a href="#Delete">D</a>|<a href="#Print">P</a>|<a href="#h">h</a>|<a href="#Hold">H</a>|<a href="#g">g</a>|<a href="#Gg">G</a>|<a href="#x">x</a>|<a href="#b">b</a>|<a href="#t">t</a>|</p>
<p>另外 , 在各节中 , 首先简单介绍函数参数功能 , 接着说明函数参数与位址参数配合的格式 ,而其中也一并描述 sed 执行此函数参数的工作情形。<br><a id="more"></a></p>
<h3 id="s"><a href="#s" class="headerlink" title="s"></a><a name="s">s</a></h3><p>函数参数 <code>s</code> 表示替换(substitute)文件内字串。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]s/pattern/replacemen/[flag]</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>s</code> 最多与两个位址参数配合。</li>
<li>关於 “<code>s/pattern/replacement/[flag]</code>“ 有下面几点说明:</li>
</ol>
<ul>
<li>pattern : 它为 reguler expression 字串。它表示文件中要被替换的字串。</li>
<li><p>replacement : 它为一般字串。但其内出现下列<span style="color:red">元字符</span>有特别意义 :</p>
<ul>
<li><p><code>&amp;</code> : 代表其前 pattern 字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/test/&amp; my car/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>&amp;</code> 代表 pattern 字串 “<code>test</code>“。故执行後 , 资料档的 “<code>test</code>“ 被替换成 “<code>test my car</code>“。</p>
</li>
<li><p><code>n</code> : 代表 pattern 中被第 <code>n</code> (<code>n</code> 是从 1 到 9 的数字)个 <code>()</code> 所括起来的字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/(test) (my) (car)/[2 3 1]/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>1</code> 表示 “<code>test</code>“、<code>2</code> 表示 “<code>my</code>“、<code>3</code> 表示 “<code>car</code>“ 字串。故执行後 , 资料档的 “<code>test my car</code>“被替换成 “<code>[my car test]</code>“。（注解：<code>()</code> 与 <code>1 ... 9</code> 合用）</p>
</li>
<li>\ : 可用它来还原一些特殊符号(如上述的 &amp; 和 \ )本身字面上的意义（<span style="color:red">转义</span>） , 或用它来<span style="color:red">代表换行</span>。</li>
</ul>
</li>
<li><p>flag : 主要用它来控制一些替换情况 :</p>
<ul>
<li>当 flag 为 <code>g</code> 时 , 代表替换所有符合(match)的字串 。</li>
<li>当 flag 为十进位数字 <code>m</code> 时 , 代表替换行内第 <code>m</code> 个符合的字串。</li>
<li>当 flag 为 <code>p</code> 时 , 代表替换第一个符合 pattern 的字串後 , 将资料输出标准输出档。</li>
<li>当 flag 为 <code>w wfile</code> 时 , 代表替换第一个符合 pattern 的字串後 , 输出到 <code>wfile</code> 档内(如果 <code>wfile</code> 不存在 , 则会重新开启名为 <code>wfile</code> 的档案)。</li>
<li>当没有 flag 时 , 则将资料行内第一个符合 pattern 的字串以 replacement 字串来替换 。</li>
</ul>
</li>
<li><p>delimiter : 在 “<code>/pattern/replace/[flag]</code>“ 中 “<code>/</code>“ 被当成 delimiter。除了空白(blank)、换行(newline) 之外 ,使用者可用任何字元作为 delimiter。例如下述编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s<span class="comment">#/usr#/usr1#g</span></div></pre></td></tr></table></figure>
<p>上述命令中”<code>#</code>“为 delimiter。如果用 “<code>/</code>“ 做 delimiter , 则 sed 会将 pattern 与 replacement中的 “<code>/</code>“ 当成 delimiter 而发生错误。</p>
</li>
</ul>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 替换 <code>input.dat</code> 档(後面如果没有特别指定 , 均假设文件档名为 <code>input.dat</code>)内 “<code>1996</code>“ 字串成 “<code>1997</code>“ , 同时将这些资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>说明:</strong> 用函数参数 <code>s</code> 指示 sed 将 “<code>1996</code>“ 字串替换成 “<code>1997</code>“ , 另外用 <code>s</code> argument 中的 flag <code>w</code> 指示 sed 将替换过的资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/1996/1997/w year97.dat'</span> input.dat</div></pre></td></tr></table></figure></p>
<p>数字标志很少使用，在这种情况下，正则表达式在一行上重复匹配，而只需对其中某个位置的匹配进行替换。例如，某输入行也许包含 <code>[tab]</code>（制表符）输入，也许包含多个制表位。假设每行有3个制表符，并且要用“&gt;”替换第二个制表位，则可以使用下面的替换命令来完成该功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/[tab]/&gt;/2</div></pre></td></tr></table></figure></p>
<p>“<code>[tab]</code>“表示一个真正的制表符，而制表符在屏幕上是不可见的。如果输入是一行的文件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2[tab]Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>对这个文件运行以上脚本产生的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2&gt;Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>注意，如果没有数字标志，则替换命令只替换第一个制表符（因此“<code>1</code>”可以被看作是默认的数字标志）。<br>我们可以对前面的示例做一些改动，用换行符取代每行上的第二个制表符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s/[tab]/</div><div class="line">/2</div></pre></td></tr></table></figure></p>
<p>注意，在反斜杠后面不允许有空格。这个脚本产生下面的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2</div><div class="line">Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a><a name="d">d</a></h3><p>函数参数 d 表示删除资料行 , 其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]d</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>d</code> 最多与两个位址参数配合。</li>
<li><p>sed 执行删除动作情况如下 :</p>
<ol>
<li>将 pattern space 内符合位址参数的资料删除。</li>
<li>将下一笔资料读进 pattern space 。</li>
<li>重新执行 sed script。</li>
</ol>
</li>
</ol>
<p>补遗：删除命令是一个可以改变脚本中的控制流的命令。这是因为一旦执行这个命令，那么在“空的”模式空间（注：不允许在被删除的行上进行进一步操作）中就不会再有命令执行。所以，<span style="color:red">删除命令会导致读取新的输入行，而编辑脚本则从头开始新的一轮</span>。重要的是：如果某行匹配了模式中地址（地址参数），那么就删除整个行，而不只是删除行中匹配的部分（要删除行的一部分，可以使用替换命令并指定一个空的替换）。</p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a><a name="a">a</a></h3><p>函数参数 <code>a</code> 表示将资料添加到文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]a 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>a</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>a</code> 紧接着 “\“ 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行添加动作情况如下: 当 pattern space 内资料输出後 , sed 跟着输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 添加 “<code>多工作业系统</code>“ 在含 “<code>UNIX</code>“ 字串的资料行後。假设 input.dat 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UNIX</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 a 将所输入的资料添加在含 “UNIX” 字串的资料行後。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 其输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工作业系统</div></pre></td></tr></table></figure></p>
<p>多行资料输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工\n作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令后，其输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工</div><div class="line">作业系统</div></pre></td></tr></table></figure></p>
<p>当然，上述命令也可以在一行中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a 多工\n作业系统&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果同上。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i"></a><a name="i">i</a></h3><p>函数参数 <code>i</code> 表示将资料插入文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]i 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>i</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>i</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行插入动作的情况如下: 在 pattern space 内资料输出前 , sed 先输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 “<code>文章版权属於中央研究院</code>“ 插在 <code>input.dat</code> 档中含 “<code>院长: 李远哲</code>“ 的资料行之前。假设 <code>input.dat</code> 档内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>i</code> 将资料行 “<code>文章版权属於中央研究院</code>“ 插在含 “<code>院长: 李远哲</code>“ 的资料行之前。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/院长：李远哲/i\</div><div class="line">文章版权属於中央研究院</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文章版权属於中央研究院</div><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<h3 id="c"><a href="#c" class="headerlink" title="c"></a><a name="c">c</a></h3><p>函数参数 <code>c</code> 表示改变文件中的资料。其格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]c 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>c</code> 最多与两个位址参数配合。</li>
<li>函数参数 <code>c</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”\n”。</li>
<li>sed 执行改变动作的情况: 在 pattern space 内资料输出时, sed 改变它成为使用者所输入的资料。</li>
</ol>
<p>补遗：更改命令清除模式空间，它在空间模式中与删除命令有同样的效果。脚本中在更改命令之后的其他命令没有被提供。<br>插入命令和追加命令不影响模式空间的内容。提供的文本将不匹配脚本中后续命令中的任何地址，那些命令也不影响该文本。不管什么更改改变了模式空间，所提供的文本仍然会正确输出。当默认的输出受到抑制时也是这样——所提供的文本将被输出，即时模式空间不是那样的。而且，所提供的文本不影响 sed 的内部行计数器。</p>
<h3 id="p"><a href="#p" class="headerlink" title="p"></a><a name="p">p</a></h3><p>函数参数 p 表示印出模式空间中的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]p</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>p</code> 最多与两个位址参数配合。</li>
<li>sed 执行印出动作的情况如下: sed 拷备一份 pattern space 内容至标准输出档。</li>
</ol>
<p>除非抑制（<code>-n</code>）默认的输出，否则打印命令将输出行的重复复制。当抑制默认的输出或者当通过程序的流程控制来避免到达脚本的底部时，可能会使用它。</p>
<h3 id="l"><a href="#l" class="headerlink" title="l"></a><a name="l">l</a></h3><p>函数参数 <code>l</code> , 除可将模式空间资料中的 nonprinting character（非打印字符） 显示为两个数字的ASCII 代码（GNU sed 显示某些字符，例如，回车符，使用的是 ANSI C 转义序列，而不是八进制。）外 , 其於均与函数参数 <code>p</code> 相同。例如 , 将下面 input.dat 档中的 <code>^[</code> 以 ASCII 码印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Great ^[ is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>（在 vi 中的插入模式下通过键入 CTRL-V（大小写无关），然后按下 ESC 键，产生字符 ^[ ，类似的，按下回车键可产生字符 ^M，按下 CTRL-A（大小写无关），产生字符 ^A，其余类推。）</p>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;l&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>後, 则输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The Great 33 is a movie starring Steve McQueen.</div><div class="line">The Great     is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>上述第二行资料为 sed 的自动输出。</p>
<p>（在 sed 中不能用 ASCII 值匹配字符（也不能匹配八进制数值），所以，使用 sed 替换（或删除）文档中的非打印字符，得用 vi 来编辑 sed 的编辑命令脚本，使用命令脚本来执行 sed 而无法在命令行上输入 sed 的命令参数。）</p>
<h3 id="r"><a href="#r" class="headerlink" title="r"></a><a name="r">r</a></h3><p>函数参数 <code>r</code> 表示读入文件的内容到模式空间。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]r file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>r</code> 最多与一个位址参数配合。</li>
<li>在指令中, 函数参数 <code>r</code> 与文件名称间, 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行读入动作的情况如下: 在 pattern space 内资料输出後, sed 读入由 file 指定的文件的内容跟着输出。当 file 不存在时, sed 照样执行其它指令而不会有任何错误讯息产生。</li>
</ol>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a><a name="w">w</a></h3><p>函数参数 <code>w</code> 表示将模式空间的内容写入文件。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]w file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>w</code> 最多与两个位址参数配合。</li>
<li>在指令中, 函数参数 <code>w</code> 与文件名称间 , 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行写出动作的情况如 : 将 pattern space 内资料写入文件 file。资料写入时 , 会取代(overwrite)原来文件内的资料（如果一个脚本中有多个指令写到同一个文件中，那么每个写命令都将内容追加到这个文件中）。另外, 当文件不存在时, sed 会重新产生(creat)它。</li>
</ol>
<h3 id="y"><a href="#y" class="headerlink" title="y"></a><a name="y">y</a></h3><p>函数参数 <code>y</code> 表示转换资料中的字元。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]y /xyz.../abc.../</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数最多配合两个位址参数。</li>
<li>指令中, <code>/abc.../xyz.../</code>(x、y、z、a、b、c 代表某些字元) 为 <code>y</code> 的 argument 。其中 <code>abc...</code> 与 <code>xyz...</code> 的字元个数必须相同。</li>
<li>sed 执行转换时, 将 pattern space 内资料内的 <code>a</code> 字元转换成 <code>x</code> 字元 、<code>b</code> 字元转换成 <code>y</code> 字元 、<code>c</code> 字元转换成 <code>z</code> 字元 …。</li>
</ol>
<h4 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中的小写字母改成大写。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sodd&apos;s Second Law:</div><div class="line">        Sooner or later, the worst possible set of</div><div class="line">        circumstances is bound to occur.</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 利用函数参数 <code>y</code> 指示 sed 做字母大小的转换。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;</div><div class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令输出结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SODD&apos;S SECOND LAW:</div><div class="line">      SOONER OR LATER, THE WORST POSSIBLE SET OF</div><div class="line">      CIRCUMSTANCES IS BOUND TO OCCUR.</div></pre></td></tr></table></figure></p>
<h3 id=""><a href="#" class="headerlink" title="!"></a><a name="!">!</a></h3><p>函数参数 <code>!</code> 表示不执行函数参数。当有如下指令时 ,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]! 函数参数</div></pre></td></tr></table></figure></p>
<p>表示, 对符合位址参数之资料不执行函数参数。例如删除 , 除了含有 “regular” 字串的资料行外，所有资料行, 则执行 <code>!</code> 后的删除命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/regular/!d&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="n"><a href="#n" class="headerlink" title="n"></a><a name="n">n</a></h3><p>函数参数 <code>n</code> 表示读入下一行资料。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]n</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>n</code> 最多配合两个位址参数。</li>
<li><p>sed 执行读入下一行动作的情况如下 :</p>
<ol>
<li>输出在 pattern space 的资料（默认输出）。</li>
<li>将下一笔资料读到 pattern space。</li>
<li>执行<span style="color:red">下一个</span>编辑指令(不用返回到脚本的顶端)。</li>
</ol>
</li>
</ol>
<p>补遗：<code>next</code> 命令改变了正常的流控制（正常情况下，直到到达脚本的底部才会输出模式空间的内容，总是在读入新行之后从脚本的顶端开始）。实际上，<code>next</code> 命令导致输入的下一行取代模式空间中的当前行。脚本中的后续命令应用于替换后的行，而不是当前行。<span style="color:red">如果没有抑制默认输出，那么在替换发生之前会打印当前行</span>。在较长的脚本中，必须记住<span style="color:red">出现在 next 命令之前的命令不会应用于新的输入行，而出现在其后面的命令不应用于旧的输入行</span>。</p>
<h4 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内偶数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">Operation</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code> , 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>n</code> 将下一行资料(偶数行)取代 pattern space 内的资料行(奇数行)。</li>
<li>利用函数参数 <code>p</code> 将 pattern space 内的资料(偶数行)输出。<br>最後 , 整个输出只有原先档内的偶数行资料。</li>
</ul>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;n&apos; -e &apos;p&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="q"><a href="#q" class="headerlink" title="q"></a><a name="q">q</a></h3><p>函数参数 <code>q</code> 表示跳离 sed 。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]q</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>q</code> 最多配合一个位址参数。</li>
<li>sed 执行跳离动作时 , 它停止读取新的输入行（并停止将它们发送到输出）。</li>
</ol>
<p>（退出命令 <code>q</code> 只适用于单行的地址。一旦找到和 address 匹配的行，那么脚本就结束。注：需要小心的是，在将编辑操作写回到原始文件的任何程序中不要使用 <code>q</code> 命令。在执行 <code>q</code> 命令之后，就不会再产生输出。在想要编辑文件的一部分并保留剩余部分不改变的情况下，不要使用 <code>q</code> 命令。这种情况下使用 <code>q</code> 时初学者常犯的非常危险的错误。）</p>
<p>示例，下面一行命令使用退出命令从文件中打印前100行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;100q&apos; test</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>它打印每一行，直到它到达行100并且退出。在这点上，这个命令的功能与 UNIX 的 <code>head</code> 命令类似。<br><code>quit</code> 的另一个可能的用法是从文件中提取了想要的内容后退出脚本。</p>
<h4 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong>  对文件档执行 <code>script_file</code> 内的编辑指令 , 除非遇到 “<code>Linux</code>“ 字串。</p>
<p><strong>说明:</strong>  无论 <code>script_file</code> 内是何种指令 , 使用者只要在命令列上用指令<code>/Linux/q</code> , 函数参数 <code>q</code> 会强迫 sed 遇到 “<code>Linux</code>“ 时做跳离动作。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/Linux/q&apos; -f script_file input.dat</div></pre></td></tr></table></figure></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="="></a><a name="equal">=</a></h3><p>函数参数 <code>=</code> 表示印出资料的行号。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]=</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>=</code> 最多配合两个位址参数。</li>
<li>执行时, 行号将在资料输出前先输出。</li>
</ol>
<h4 id="范例-6"><a href="#范例-6" class="headerlink" title="范例:"></a>范例:</h4><p><strong>题目:</strong> 印出 <code>input.dat</code> 档内资料行数。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>=</code> 来印出资料的行数。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;=&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 输出的结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">The UNIX</div><div class="line">2</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<h3 id="-2"><a href="#-2" class="headerlink" title="#"></a><a name="com">#</a></h3><p><span style="color:red">在 script file 内 , 函数参数 <code>#</code> 後的文字为注解。当注解文字超过多行时 , 其行间须以 “\n” 换行字元相隔</span>。在 sed 的System V版本中，注释只允许出现在第一行。而 GNU sed 则可以在脚本的任何地方放置注释，甚至是跟在命令行的后面。注释行的第一个字符必须是“#”号。<span style="color:red">如果跟在<code>#</code>后面的下一个字符是<code>n</code>，那么脚本不会自动产生输出。这和指定命令行选项 <code>-n</code> 是等价的。跟在 <code>n</code> 后面的其余内容被看做是注释。在POSIX标准中，采用这种方式的 <code>#n</code> 必须是文件的前两个字符</span>。</p>
<p>到此为止，前面介绍的命令（函数参数）可归类为基本的 sed 命令，下面将要介绍的这些命令可归类为 sed 的高级命令。sed 的高级命令可分成3个组：</p>
<ol>
<li>处理多行模式空间（<code>N</code>、<code>D</code>、<code>P</code>）。</li>
<li>采用保持空间来保存模式空间的内容并使它可用于后续的命令（<code>H</code>、<code>h</code>、<code>G</code>、<code>g</code>、<code>x</code>）。</li>
<li>编写使用分支和条件指令的脚本来更改控制流（<code>:</code>、<code>b</code>、<code>t</code>）。</li>
</ol>
<h3 id="多行模式空间"><a href="#多行模式空间" class="headerlink" title="多行模式空间"></a>多行模式空间</h3><p>在前面的正则表达式讨论中，我们强调模式匹配是面向行的。像 grep 这样的程序尝试在单个输入行上匹配一个模式。这就使它很难匹配一个在一行的结尾处开始，并在下一行的开始处结束的短语。其他一些模式只有当在多行上匹配才有意义。<br>sed 能查看模式空间的多个行。这就允许匹配模式扩展到多行上。下面我们将要介绍创建多行模式空间并处理它的内容的命令。这里的 3 个多行命令（<code>N</code>、<code>D</code>、<code>P</code>）对应于前面介绍的小写字母的基本命令（<code>n</code>、<code>d</code>、<code>p</code>）。</p>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a><a name="Next">N</a></h3><p>函数参数 <code>N</code> 表示添加下一笔资料在 pattern space 内。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]N</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>N</code> 最多配合两个位址参数。</li>
<li>sed 执行时, 将下一行资料读入并添加在 pattern space 内, 资料行间以换行字元(embedded newline character)分隔。此外 , 在替换时 , 换行字元可用转义序列 <code>\n</code> 来匹配。</li>
</ol>
<p><span style="color:red">在多行模式空间中，元字符“<code>^</code>”匹配模式空间中的第一个字符，而不匹配换行符后面的字符。同样，“<code>$</code>”只匹配模式空间中最后的换行符，而不匹配任何嵌入的换行符。</span>在执行 <code>Next</code> 命令之后，控制将被传递给脚本中的后续命令（同 <code>next</code> ）。<code>Next</code> 命令与 <code>next</code> 命令不同，<code>next</code> 输出模式空间的内容，然后读取新的输入行。<code>next</code> 命令不创建多行模式空间。</p>
<h4 id="范例-7"><a href="#范例-7" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将下述两行资料合。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 先利用函数参数 <code>N</code> 将两行资料置於 pattern space 内 , 在利用函数参数 <code>s/\n/ /</code> 将两行资料间的分隔符 <code>\n</code> 以空白替代 , 如此两行资料变成一行输出。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;N&apos; -e &apos;s/\n/ /&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 其输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The UNIX Operating System</div></pre></td></tr></table></figure></p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a><a name="Delete">D</a></h3><p>函数参数 <code>D</code> 表示删除 pattern space 内的第一行资料（删除模式空间中直到第一个嵌入的换行符的这部分内容）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]D</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>D</code> 最多配合两个位址参数。</li>
<li>函数参数 <code>D</code> 与 <code>d</code> 的比较如下 :</li>
</ol>
<ul>
<li>当 pattern space 内只有一资料行时 , <code>D</code> 与 <code>d</code> 作用相同。</li>
<li><p>当 pattern space 内有多行资料行时</p>
<ul>
<li><code>D</code> 表示只删除 pattern space 内第一行资料 ; <code>d</code> 则全删除。</li>
<li><code>D</code> 表示执行删除后 , pattern space 内不添加下一笔资料 , 而将剩下的资料重新执行 sed script （返回到脚本的顶端，将这些指令应用于模式空间剩余的内容）; <code>d</code> 则读入下一行后重新执行 sed script（返回到脚本的顶端）。</li>
</ul>
</li>
</ul>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a><a name="Print">P</a></h3><p>函数参数 <code>P</code> 表示印出 pattern space 内的第一行资料（输出多行模式空间的第一部分，直到第一个嵌入的换行符为止）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]P</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>P</code> 最多配合两个位址参数。</li>
<li><code>P</code> 与 <code>p</code> , 除了面对的 pattern space 内的资料行数不同外 , 其它均相同。</li>
</ol>
<p><span style="color:red">在执行完脚本的最后一个命令之后，模式空间的内容自动输出（<code>-n</code> 选项或 <code>#n</code> 抑制这个默认的动作）</span>。因此当默认的输出被抑制或者脚本中的控制流更改，以至不能达到脚本的底部时，需要使用打印命令（<code>P</code> 或 <code>p</code>）。<code>Print</code> 命令经常出现在 <code>Next</code> 命令之后和 <code>Delete</code> 命令之前。这 3 个命令能建立一个输入/输出循环，用来维护两行的模式空间，但是一次只输出一行。这个循环的目的是只输出模式空间的第一行，然后<span style="color:red">返回到脚本的顶端</span>将所有的命令应用于模式空间的第二行。没有这个循环，当执行脚本中的最后一个命令时，模式空间中的这两行都被输出。</p>
<h4 id="范例-8"><a href="#范例-8" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内奇数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code>, 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>N</code> 将偶数行添加至 pattern space 内奇数行後。</li>
<li>利用函数参数 <code>P</code> 将 pattern space 内的第一行(奇数行)输出。</li>
</ul>
<p>在奇数行输出後 , pattern space 内剩下的资料行(偶数行)则被放弃输出。最後 , 整个输出只有原先的奇数行资料。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;N&apos; -e &apos;P&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="模式空间与保持空间"><a href="#模式空间与保持空间" class="headerlink" title="模式空间与保持空间"></a>模式空间与保持空间</h3><p>模式空间的内容可以<span style="color:red">复制</span>到保持空间，而且保持空间的内容也可以<span style="color:red">复制</span>到模式空间。有一组命令用于在保持空间和模式空间之间移动数据。保持空间用于临时存储。单独的命令不能寻址保持空间或者更改它的内容。</p>
<p>保持空间最常见的用途是，当改变模式空间中的原始内容时，用于保留当前输入行的<span style="color:red">副本</span>。影响模式空间的命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hold</td>
<td>h 或 H</td>
<td>将模式空间的内容复制或追加到保持空间</td>
</tr>
<tr>
<td>Get</td>
<td>g 或 G</td>
<td>将保持空间的内容复制或追加到模式空间</td>
</tr>
<tr>
<td>Exchang</td>
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>
<p>hold(<code>h</code>，<code>H</code>)命令将数据移至保持空间，而 get(<code>g</code>，<code>G</code>)命令将保持空间的数据移回到模式空间。同一命令的小写字母和大写字母之间的差别是，小写字母命令改写目的缓存区的内容，而大写字母命令追加缓存区的现有内容。</p>
<p>hold（小写）命令用模式空间的内容取代保持空间的内容。get（小写）命令用保持空间的内容取代模式空间的内容。<br>Hold（大写）命令在保持空间的内容之后放置一个换行符，且后面跟随模式空间的内容（即使保持空间是空的，换行符也被追加到保持空间）。Get（大写）命令在模式空间的内容之后放置一个换行符，且后面跟随保持空间的内容。</p>
<p>交换命令交换两个缓存区的内容。对两个缓存区没有副作用。</p>
<h3 id="h"><a href="#h" class="headerlink" title="h"></a><a name="h">h</a></h3><p>函数参数 <code>h</code> 表示暂存 pattern space 的资料至 hold space。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]h</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>h</code> 最多配合两个位址参数。</li>
<li>sed 执行暂存动作时 , 会盖掉(overwrite) hold space 内原来的资料。</li>
<li>当 sed 全部执行结束时 , hold space 内资料会自动清除。</li>
</ol>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a><a name="Hold">H</a></h3><p>函数参数 <code>H</code> 与 <code>h</code> 唯一差别是 , sed 执行 <code>h</code> 时 , 资料盖掉(overwrite) hold space 内原来的资料 ,而 <code>H</code> , 资料则是 “添加(append)” 在 hold space 原来资料後。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g"></a><a name="g">g</a></h3><p>函数参数 <code>g</code> 表示与函数参数 <code>h</code> 相反的动作 , 它表示将 hold space 内资料放回 pattern space内。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]g</div></pre></td></tr></table></figure></p>
<p>函数参数 g 最多配合两个位址参数。<br>sed 执行放回动作时 , 资料盖掉(overwrite) pattern space 内原来的资料。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a><a name="Gg">G</a></h3><p>函数参数 <code>G</code> 与 <code>g</code> 唯一差别是 , sed 执行 <code>g</code> 时 , 资料盖掉(overwrite) pattern space 内原来的资料 , 而 <code>G</code> , 资料则是 “添加(append)” 在 pattern space 原来资料後。</p>
<h3 id="x"><a href="#x" class="headerlink" title="x"></a><a name="x">x</a></h3><p>函数参数 <code>x</code> 表示交换 hold space 与 pattern space 内的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]x</div></pre></td></tr></table></figure></p>
<p>函数参数 <code>x</code> 大部份与其它处理 hold space 的函数参数一起配合。例如 , 将 <code>input.dat</code> 档内第 1 行资料取代第 3 行资料。此时 , 用函数参数 <code>h</code> 与 <code>x</code> 来配合。其中 , 以函数参数 <code>h</code> 将第 1 资料存入 hold space ;当第 3 行资料出现在pattern space , 以函数参数 <code>x</code> 交换 hold space 与 pattern space 的内容。如此 , 第 3 行资料就被第 1 资料替代。其命令列如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1h&apos; -e &apos;3x&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="高级流程控制指令"><a href="#高级流程控制指令" class="headerlink" title="高级流程控制指令"></a>高级流程控制指令</h3><p>分支（<code>b</code>）和测试（<code>t</code>）命令将脚本中的控制转移到包含特殊标签的行。如果没有指定标签，则将控制转移到脚本的结尾处。分支命令用于无条件转移，测试命令用于有条件转移，它们只有当替换命令改变当前行时才会执行。<br>标签是任意不多于7个字符的序列（GNU sed 允许标签为任意长度）。标签本身占据一行并以冒号开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:mylabel</div></pre></td></tr></table></figure></p>
<p>在冒号和标签之间不允许有空格。行结尾处的空格将被认为是标签的一部分。当在分支命令或测试命令中指定标签时，在命令和标签之间允许有空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b mylabel</div></pre></td></tr></table></figure></p>
<p>注意，不要在标签后面插入空格。</p>
<h3 id="b-label"><a href="#b-label" class="headerlink" title="b :label"></a><a name="b">b :label</a></h3><p>函数参数 <code>:</code> 与函数参数 <code>b</code> 可在 sed script 内建立类似 BASIC 语言中 GOTO 指令的功能。其中 , 函数参数 <code>:</code> 建立标记;函数参数 <code>b</code> 将下一个执行的指令 branch 到标记处执行。函数参数 <code>:</code> 与 <code>b</code> , 在 script file 内配合的情况如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">[address1[, address2]]b [记号]</div></pre></td></tr></table></figure></p>
<p>其中, 当 sed 执行至指令<code>[address1[, address2]]b [记号]</code>时 , 如 pattern space 内的资料符合位址参数 , 则 sed 将下一个执行的位置 branch 至由 <code>:记号</code>设定的标记处 , 也就是再由 “<code>编辑指令 m2</code>“ … 执行。另外 , 如果指令中函数参数 <code>b</code> 後没有记号 , 则 sed 将下一个执行的指令 branch 到 script file 的最後 , 利用此可使 sed script 内有类似 C 语言中的 case statement 结构。</p>
<h4 id="范例-9"><a href="#范例-9" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档内资料行的开头字母重覆印 40 次。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用指令 <code>b p1</code> 与 <code>:p1</code> 构成执行增加字母的回圈(loop) , 同时在字母出现 40 个时 , 也用指令 <code>b</code> 来跳出圈。下面就以档内第一行资料 “<code>A</code>“ 为例 , 描述它如何连续多添加 39 个 “<code>A</code>“ 在同一行:</p>
<ul>
<li>用指令 <code>s/A/AA/</code> 将 “<code>A</code>“ 替换成 “<code>AA</code>“。</li>
<li>用指令 <code>b p1</code> 与 <code>:p1</code> 构成回圈(loop) , 它目的使上述动作被反覆的执行。每执行一次圈 , 则资料行上的 “<code>A</code>“ 就多出一个。例如 , 第一次圈资料行变成 “<code>AA</code>“ , 第二次圈资料行变成 “<code>AAA</code>“ …。</li>
<li>用指令 <code>[ABC]\{40\}/b</code> （注解：<code>\{重复次数\}</code> 、<code>\{下限,上限\}</code>）来作为停止回圈的条件。当资料行有连续 40 个 <code>A</code> 出现时 , 函数参数 <code>b</code> 将执行的指令跳到最後 , 停止对此行的编辑。</li>
</ul>
<p>同样, 对其它资料行也如同上述的方式执行。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">:p1</div><div class="line">/A/s/A/AA/</div><div class="line">/B/s/B/BB/</div><div class="line">/C/s/C/CC/</div><div class="line">/[ABC]\&#123;40\&#125;/b</div><div class="line">b p1</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</div><div class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</div><div class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</div></pre></td></tr></table></figure></p>
<h3 id="t"><a href="#t" class="headerlink" title="t"></a><a name="t">t</a></h3><p>基本上, 函数参数 <code>t</code> 与 函数参数 <code>b</code> 的功能类似 , 除了在执行 <code>t</code> 的 branch 前 , 会先去测试其前的替换指令有没有执行替换成功外。在 script file 内的情况如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">s/.../.../</div><div class="line">[address1[, address2]]t [记号]</div><div class="line">编辑指令m3</div></pre></td></tr></table></figure></p>
<p>其中 , 与函数参数 <code>b</code> 不同处在於, 执行函数参数 <code>t</code> branch 时, 会先检查其前一个替换指令成功与否。如成功, 则执行 branch; 不成功, 则不 branch, 而继续执行下一个编辑指令, 例如上面的<code>编辑指令m3</code>。</p>
<h4 id="范例-10"><a href="#范例-10" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中资料 <code>A1</code> 替换成<code>C1</code>、<code>C1</code> 替换成<code>B1</code>、<code>B1</code> 替换成<code>A1</code>。<code>input.dat</code> 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">代号</div><div class="line">B1</div><div class="line">A1</div><div class="line">B1</div><div class="line">C1</div><div class="line">A1</div><div class="line">C1</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> <code>input.dat</code> 档中全部资料行只需要执行一次替换动作 , 但为避免资料被替换多次 , 所以利用函数参数 <code>t</code> 在 sed script 内形成一类似 C 语言中 case statement 结构 , 使每行资料替换一次後能立即用函数参数 <code>t</code> 跳离替换编辑。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">s/A1/C1/</div><div class="line">t</div><div class="line">s/C1/B1/</div><div class="line">t</div><div class="line">s/B1/A1/</div><div class="line">t</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 学习手册]]></title>
      <url>https://jarsonfang.github.io/tools/sed-awk/sed-manual/</url>
      <content type="html"><![CDATA[<h2 id="sed-简要介绍"><a href="#sed-简要介绍" class="headerlink" title="sed 简要介绍"></a>sed 简要介绍</h2><p>Sed(Stream EDitor)为 UNIX 系统上提供将编辑工作自动化的编辑器 , 使用者无需直接编辑资料。使用者可利用 sed 所提供 20 多种不同的<span style="color:red;">函数[参数] </span>, 组合它们完成不同的编辑动作。此外 ,由於 sed 都以行为单位编辑文件 , 故其亦是行编辑器(line editor)。<br> 一般 sed 最常用在编辑那些需要不断重覆某些编辑动作的文件上, 例如将文件中的某个字串替换成另一个字串等等。这些相较於一般 UNIX 编辑器(交互式的, 如 vi、emacs)用手动的方式修改文件, sed 用起来较省力。</p>
<p>sed 是一个非交互式上下文(context)编辑器,它被设计在下列三种情况下发挥作用:</p>
<ol>
<li>编辑那些对舒适的交互式编辑而言太大的文件。</li>
<li>在编辑命令太复杂而难于在交互模式下键入的时候，编辑任何大小的文件。</li>
<li>要在对输入的一趟扫描中有效的进行多个”全局”(global)编辑函数。</li>
</ol>
<p>因为每次只把输入的某些行驻留在内存中, 并且不使用临时文件,所以可编辑的文件的有效大小,只受限于输入和输出要同时共存于次级存储的要求。可以单独的建立复杂的编辑脚本并作为给 sed 的命令文件。对于复杂的编辑,这节省了可观的键入和随之而来的错误。从命令文件运行 sed 高效于作者所知道的任何交互式编辑器,甚至包括能用预先写好的脚本驱动的编辑器。</p>
<p>相较于交互式编辑器而言,根本性的损失是缺乏相对地址(由于操作是每次一行的),和缺乏对命令如期运行的立即验证。<br><a id="more"></a></p>
<h2 id="sed-如何工作"><a href="#sed-如何工作" class="headerlink" title="sed 如何工作"></a>sed 如何工作</h2><p>如同其它 UNIX 命令, sed 由标准输入读入编辑文件并由标准输出送出结果。下图表示 sed将资料行 “<code>Unix</code>“ 替换成 “<code>UNIX</code>“,<br><img src="/tools/sed-awk/sed-manual/sed.gif" alt="sed.gif" title=""><br>在图中, 上方 standard input 为标准输入, 是读取资料之处; standard output 为标准输出, 是送出结果之处;中间 sed 方块的下面两个虚线方块表示 sed 的工作流程。其中, 左边虚线方块表示 sed 将标准输入资料置入pattern space, 右边虚线方块表示 sed 将 pattern space 中编辑完毕後的资料送到标准输出。</p>
<p>在虚线方块中, 两个实线方块分别表示 pattern space 与 sed script。其中, pattern space 为一缓区, 它是sed 工作场所; 而 sed script 则表示一组执行的编辑指令。</p>
<p>在图中, 左边虚线方块 “Unix” 由标准输入置入 pattern space; 接着 , 在右边虚线方块中, sed执行 sed script 中的编辑指令<code>s/Unix/UNIX/</code>, 结果 “Unix” 被替换成 “UNIX”, 之後, “UNIX” 由pattern space 送到标准输出。</p>
<p>总合上述所言, 当 sed 由标准输入读入一行资料并放入 pattern space 时, sed 依照 sed script 的编辑指令逐一对 pattern space 内的资料执行编辑, 之後, 再由 pattern space 内的结果送到标准输出, 接着再将下一行资料读入。如此重复执行上述动作 , 直至读完所有资料行为止。</p>
<p>sed 维护一种模式空间（patter space），即一个工作区或临时缓冲区，当应用编辑命令时将在那里存储单个输入行。sed 还维护了称为保持空间(hold space)的另一个临时缓冲区，可以将模式空间的内容复制到保持空间并在以后检索它们。</p>
<h2 id="使用-sed"><a href="#使用-sed" class="headerlink" title="使用 sed"></a>使用 sed</h2><p>sed 命令列可分成编辑指令与文件档部份。其中, 编辑指令负责控制所有的编辑工作; 文件档表示所处理的档案。sed 的编辑指令均由<span style="color:#ff0000">位址(address)</span>与<span style="color:#ff0000">函数(function)</span>两部份组成, 其中, 在执行时, sed 利用它的<span style="color:red;">位址参数</span>来决定编辑的对象; 而用它的<span style="color:red;">函数[参数]</span>编辑。</p>
<p>此外, sed 编辑指令, 除了可在命令列上执行, 也可在档案内执行。其中差别只是在命令列上执行时, 其前必须加上选项 <code>-e</code>; 而在档案内时, 则只需在其档名前加上选项 <code>-f</code>。另外, sed 执行编辑指令是依照它们在命令列上或档内的次序。</p>
<p>下面各节, 将介绍执行命令列上的编辑指令、sed 编辑指令、执行档案内的编辑指令、执行多个档案的编辑、及执行 sed 输出控制。</p>
<h3 id="执行命令列上的编辑指令"><a href="#执行命令列上的编辑指令" class="headerlink" title="执行命令列上的编辑指令"></a>执行命令列上的编辑指令</h3><p>当编辑指令在命令列上执行时, 其前必须加上选项 <code>-e</code> 。其命令格式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'编辑指令 1'</span> <span class="_">-e</span> <span class="string">'编辑指令 2'</span> ... 文件档</div></pre></td></tr></table></figure></p>
<p>其中, 所有编辑指令都紧接在选项 <code>-e</code> 之後, 并置於两个 “<code>&#39;</code>“ 特殊字元间。另外, 命令上编辑指令的执行是由左而右。</p>
<p>一般编辑指令不多时, 使用者通常直接在命令上执行它们。例如, 删除 <code>yel.dat</code> 内 <code>1</code> 至<code>10</code> 行资料 , 并将其馀文字中的 “<code>yellow</code>“ 字串改成 “<code>black</code>“ 字串。此时 , 可将编辑指令直接在命令上执行 , 其命令如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,10d'</span> <span class="_">-e</span> <span class="string">'s/yellow/black/g'</span> yel.dat</div></pre></td></tr></table></figure></p>
<p>在命令中 , 编辑指令 ‘<code>1,10d</code>‘ 执行删除 <code>1</code> 至 <code>10</code> 行资料 ; 编辑指令 ‘<code>s/yellow/black/g</code>‘，”<code>yellow</code>“ 字串替换(substitute)成 “<code>black</code>“ 字串。</p>
<h3 id="sed-的编辑指令"><a href="#sed-的编辑指令" class="headerlink" title="sed 的编辑指令"></a>sed 的编辑指令</h3><p> sed 编辑指令的格式如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[,address2]]<span class="keyword">function</span>[argument]</div></pre></td></tr></table></figure></p>
<p>其中 , 位址参数 <code>address1</code> 、<code>address2</code> 为行数或 regular expression 字串 , 表示所执行编辑的资料行 ; 函数参数 <code>function[argument]</code> 为 sed 的内定函数 , 表示执行的编辑动作。</p>
<p>下面两小节 , 将仔细介绍位址参数的表示法与有哪些函数参数供选择。</p>
<p><strong>位址(address)参数的表示法</strong></p>
<p>实际上 , 位址参数表示法只是将要编辑的资料行 , 用它们的行数或其中的字串来代替表示它们。下面举几个例子说明(指令都以函数参数 d 为例) :</p>
<ul>
<li>删除档内第 10 行资料 , 则指令为 <code>10d</code></li>
<li>删除含有 “man” 字串的资料行时 , 则指令为 <code>/man/d</code></li>
<li>删除档内第 10 行到第 200 行资料, 则指令为 <code>10,200d</code></li>
<li>删除档内第 10 行到含 “man” 字串的资料行 , 则指令为 <code>10,/man/d</code></li>
</ul>
<p>接下来 , 以位址参数的内容与其个数两点 , 完整说明指令中位址参数的表示法(同样也以函数参数 <code>d</code> 为例)。</p>
<ul>
<li><p>位址参数的内容:</p>
<ul>
<li>位址为十进位数字 （行地址）: 此数字表示行号。当指令执行时 , 将对符合此行号的资料执行函数参数指示的编辑动作。例如 ,删除资料档中的第 15 行资料 , 则指令为 <code>15d</code>。其馀类推 ,如删除资料档中的第 m 行资料 , 则指令为 <code>md</code> 。行号是由 sed 维护的内部行数。该计数器不会因为多个输入文件而重置。因此，不管指定多少个输入文件，在<span style="color:red">输入流</span>（多个文件（流）构成一个输入流，文件个数不同，输入流的大小也会不同）中也只有一行<code>1</code>。同样，输入流也只有一个最后的行。可以使用寻址符号 <code>$</code> 指定。下面的示例删除输入流的最后一行：<code>$d</code>（<code>$</code> 符号不应该和正则表达式中使用的 <code>$</code> 相混淆，在这里表示行的结束）</li>
<li>位址为 regular expression（模式地址）: 当资料行中有符合 regular expression 所表示的字串时 , 则执行函数参数指示的编辑动作。另外 ,在regular expression 前後必须加上 “<code>/</code>“。例如指令为 <code>/t.*t/d</code> , 表示删除所有含两 “<code>t</code>“ 字母的资料行。其中 , “<code>.</code>“表示任意字元; “<code>*</code>“ 表示其前字元可重复任意次 , 它们结合 “<code>.*</code>“ 表示两 “<code>t</code>“ 字母间的任意字串。</li>
</ul>
</li>
<li><p>位址参数的个数 : 在指令中 , <span style="color:red">如果没有指定位址参数</span> , 表示全部资料行执行函数参数所指示的编辑动作;<span style="color:red"> 如果只有一位址参数</span> , 表示只有符合位址的资料行才编辑 ; <span style="color:red">如果指定了由逗号分隔的两个位址参数 </span>, 如 <code>address1,address2</code> 时 ,表示对资料区执行编辑 , <code>address1</code> 代表起始资料行 , <code>address2</code> 代表结束资料行（即编辑命令应用于第一个地址的第一行和它后面的行，直到匹配第二个地址的行（包括此行）。你可以把第一个地址看做是启用动作，并把第二个地址看做是禁用动作。sed 没有办法先行决定第二个地址是否会匹配。一旦匹配了第一个地址，这个（些）动作就将应用于这些行。于是编辑命令应用于“所有”随后的行直到第二个地址被匹配。）。<span style="color:red">如果地址后面跟有感叹号(!)</span>，那么编辑命令就应用于<span style="color:red">不匹配</span>该地址的所有的行。对於上述内容 , 以下面例子做具体说明。</p>
<ol>
<li>例如指令为<code>d</code>其表示删除档内所有资料行。</li>
<li>例如指令为<code>5d</code>其表示删除档内第五行资料。</li>
<li>例如指令为<code>1,/apple/d</code>其表示删除资料区 , 由档内第一行至内有 “<code>apple</code>“ 字串的资料行。</li>
<li>例如指令为<code>/apple/,/orange/d</code>其表示删除资料区 , 由档内含有 “<code>apple</code>“ 字串至含有 “<code>orange</code>“ 字串的资料行</li>
<li>例如指令为<code>/regular/!d</code>其表示删除所有的不包含“<code>regular</code>”字符串的资料行。</li>
</ol>
</li>
</ul>
<p><strong>有哪些函数(function)参数</strong></p>
<p>下表中介绍所有 sed 的函数参数的功能。</p>
<table>
<thead>
<tr>
<th>函数参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:label</td>
<td>建立script file内指令互相参考的位置</td>
</tr>
<tr>
<td>#</td>
<td>建立注解</td>
</tr>
<tr>
<td>{ }</td>
<td>集合有相同位址参数的指令</td>
</tr>
<tr>
<td>!</td>
<td>不执行函数参数</td>
</tr>
<tr>
<td>=</td>
<td>印出资料行数（line number）</td>
</tr>
<tr>
<td>a\</td>
<td>添加使用者输入的资料</td>
</tr>
<tr>
<td>b label</td>
<td>将执行的指令跳至由 : 建立的参考位置</td>
</tr>
<tr>
<td>c\</td>
<td>以使用者输入的资料取代资料</td>
</tr>
<tr>
<td>d</td>
<td>删除资料</td>
</tr>
<tr>
<td>D</td>
<td>删除 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>g</td>
<td>从 hold space 中拷贝资料</td>
</tr>
<tr>
<td>G</td>
<td>拷贝 hold space 中的资料添加到 pattern space</td>
</tr>
<tr>
<td>h</td>
<td>从 pattern space 中拷贝资料到 hold space</td>
</tr>
<tr>
<td>H</td>
<td>拷贝 pattern space 中的资料添加到 hold space</td>
</tr>
<tr>
<td>I</td>
<td>印出资料中的 nonprinting character 的ASCII码值</td>
</tr>
<tr>
<td>i\</td>
<td>插入添加使用者输入的资料行</td>
</tr>
<tr>
<td>n</td>
<td>读入下一笔资料</td>
</tr>
<tr>
<td>N</td>
<td>添加下一笔资料到 pattern space</td>
</tr>
<tr>
<td>p</td>
<td>印出资料</td>
</tr>
<tr>
<td>P</td>
<td>印出 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>q</td>
<td>跳出 sed 编辑</td>
</tr>
<tr>
<td>r</td>
<td>读入文档内容</td>
</tr>
<tr>
<td>s</td>
<td>替换字串</td>
</tr>
<tr>
<td>t label</td>
<td>先执行一替换编辑命令，如果替换成功，则将编辑指令跳至 :label 处执行</td>
</tr>
<tr>
<td>w</td>
<td>写资料到文档</td>
</tr>
<tr>
<td>x</td>
<td>交换 hold space 与 pattern space 中的内容</td>
</tr>
<tr>
<td>y</td>
<td>转换(transform)字元</td>
</tr>
</tbody>
</table>
<p>虽然 , sed 只有上表所述几个拥有基本编辑功能的函数 , 但由指令中位址参数和指令与指令间的配合 , 也能使sed 完成大部份的编辑任务。</p>
<h3 id="执行档案内的编辑指令"><a href="#执行档案内的编辑指令" class="headerlink" title="执行档案内的编辑指令"></a>执行档案内的编辑指令</h3><p>当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案  (譬如档名为 <code>script_file</code> )内 , 用选项 <code>-f script_file</code> , 则让 sed 执行 <code>script_file</code> 内的编辑指令。其命令的格示如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> script_file 文件档</div></pre></td></tr></table></figure></p>
<p>其中 , 执行 <code>script_file</code> 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> ysb.scr yel.dat</div></pre></td></tr></table></figure></p>
<p>其中 , <code>ysb.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1,10d</div><div class="line">s/yellow/black/g</div></pre></td></tr></table></figure></p>
<p>另外 , 在命令列上可混合使用选项 <code>-e</code> 与 <code>-f</code> , sed 执行指令顺序依然是由命令列的左到右,如执行至 <code>-f</code> 後档案内的指令 , 则由上而下执行。</p>
<h3 id="执行多个文件档的编辑"><a href="#执行多个文件档的编辑" class="headerlink" title="执行多个文件档的编辑"></a>执行多个文件档的编辑</h3><p>在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 档内的 “<code>yellow</code>“ 字串成 “<code>blue</code>“ , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/yellow/blue/g'</span> white.dat red.dat black.dat</div></pre></td></tr></table></figure></p>
<p>上述命令执行时 , sed 依 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 顺序 , 执行编辑指令 <code>s/yellow/blue/</code> ,进行字串的替换。</p>
<h3 id="执行输出的控制"><a href="#执行输出的控制" class="headerlink" title="执行输出的控制"></a>执行输出的控制</h3><p>在命令列上的选项 <code>-n</code> 表示输出由编辑指令控制。由前章内容得知 , sed 会 “自动的”将资料由 pattern space 输送到标准输出档。但藉着选项 <code>-n</code> , 可将 sed 这 “自动的” 的动作改成 “被动的” 由它所执行的编辑指令来决定结果是否输出。</p>
<p>由上述可知 , 选项 <code>-n</code> 必须与编辑指令一起配合 , 否则无法获得结果。例如 , 印出<code>white.dat</code>档内含有 “<code>white</code>“ 字串的资料行 , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/white/p'</span> white.dat</div></pre></td></tr></table></figure></p>
<p>上面命令中 , 选项 <code>-n</code> 与编辑指令 <code>/white/p</code>  一起配合控制输出。其中 ，选项 <code>-n</code> 将输出控制权移给编辑指令；<code>/white/p</code> 将资料行中含有 “<code>white</code>“ 字串印出萤幕。</p>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>一般在实际使用编辑器的过程中 , 常需要执行替换文件中的字串、搬移、删除、与搜寻资料行等等动作。当然 , 一般交谈式编辑器(如 vi、emacs)都能做得到上述功能 , 但文件一旦有大量上述编辑需求时 , 则用它们编辑十分没有效率。本章将用举例的方式说明如何用 sed 自动执行这些编辑功能。此外 , 在本章范例中 , 均以下述方式描述文件的需求 :</p>
<blockquote>
<p>将文件中…资料 , 执行…(动作)</p>
</blockquote>
<p>如此 , 目的是为了能将它们迅速的转成编辑指令。其中 , “<code>...资料</code>“ 部份 , 转成指令中的<code>位址参数</code>表示 ;”<code>执行...动作</code>“ 部份 , 则转成<code>函数参数</code>表示 。另外 ,将一个地址嵌套在另一个地址中（内层地址必须在外层地址的作用范围之内），或者 “执行…动作” 要由数个函数参数表示时, 则可利用 “<code>{</code>“与 “<code>}</code>“ 集合这些函数参数（注：左大括号必须在行末，而且右大括号本身必须单独占一行。要确保在大括号之后没有空格。）, 其指令形式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">位址参数&#123;</div><div class="line">   函数参数 1</div><div class="line">   函数参数 2</div><div class="line">   函数参数 3</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述指令表示 , 将对符合位址参数的资料 , 依次执行函数参数 1、函数参数 2、函数参数 3 … 表示的动作。</p>
<p>下面各节 , 分别举例说明 sed 替换资料、移动、删除资料、及搜寻资料的命令。</p>
<h3 id="替换文件中的资料"><a href="#替换文件中的资料" class="headerlink" title="替换文件中的资料"></a>替换文件中的资料</h3><p>sed 可替换文件中的字串、资料行、甚至资料区。其中 , 表示替换字串的指令中的函数参数为 <code>s</code> ;表示替换资料行、或资料区的指令中的函数参数为 <code>c</code> 。上述情况以下面三个例子说明。</p>
<p>例一. 将文件中含 “<code>machine</code>“ 字串的资料行中的 “<code>phi</code>“ 字串 , 替换成为 “<code>beta</code>“ 字串。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/machine/s/phi/beta/g'</span> input.dat (以後文件档都以 input.dat 代表)</div></pre></td></tr></table></figure></p>
<p>例二. 将文件中第 5 行资料 , 替换成句子 “Those who in quarrels interpose, must often wipe a bloody nose.”。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'5c</span></div><div class="line">Those must often wipe a bloody nose.</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<p>例三. 将文件中 1 至 100 行的资料区 , 替换成如下两行资料 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How are you?</div><div class="line">data be deleted!</div></pre></td></tr></table></figure></p>
<p>则其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,100c</span></div><div class="line">How are you?</div><div class="line">data be deleted!</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<h3 id="搬动文件中的资料"><a href="#搬动文件中的资料" class="headerlink" title="搬动文件中的资料"></a>搬动文件中的资料</h3><p>使用者可用 sed 中的 hold space 暂存编辑中的资料、用函数参数 <code>w</code> 将文件资料搬动到它档内储存、或用函数参数 <code>r</code> 将它档内容搬到文件内。Hold space 是 sed 用来暂存 pattern space 内资料的暂存器 , 当 sed 执行函数参数<code>h</code>、<code>H</code> 时 , 会将 pattern space 资料暂存到 hold space ;当执行函数参数<code>x</code>、<code>g</code>、<code>G</code> 时 , 会将暂存的资料取到 pattern space 。下面举三个例子说明。</p>
<p>例一. 将文件中的前 100 资料 , 搬到文件中第 300 後输出。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> mov.scr 文件档</div></pre></td></tr></table></figure></p>
<p>mov.scr 档的内容为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div><div class="line">300G</div></pre></td></tr></table></figure></p>
<p>其中 ,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它表示将文件中的前 100 资料 , 先储存在 hold space 之後删除 ;指令 <code>300G</code> 表示 , 将 hold space 内的资料 , 添加在文件中的第 300 行资料後输出。</p>
<p>例二. 将文件中含 “<code>phi</code>“ 字串的资料行 , 搬至 <code>mach.inf</code> 档中储存。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/phi/w mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>例三. 将 <code>mach.inf</code> 档内容 , 搬至文件中含 “<code>beta</code>“ 字串的资料行。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/beta/r mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>另外 , 由於 sed 是一 stream 编辑器 , 故理论上输出後的文件资料不可能再搬回来编辑。</p>
<h3 id="删除文件中的资料"><a href="#删除文件中的资料" class="headerlink" title="删除文件中的资料"></a>删除文件中的资料</h3><p>因为 sed 是一行编辑器 , 所以 sed 很容易删除个别资料行或整个资料区。一般用函数参数 <code>d</code> 或 <code>D</code> 来表示。下面举两个例子说明。</p>
<ul>
<li><p>将文件内所有空白行全部删除。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/d'</span> 文件档</div></pre></td></tr></table></figure>
<p>regular expression <code>^$</code> 表示空白行。 其中 , <code>^</code> 限制其後字串必须在行首; <code>$</code> 限制其前字串必须在行尾。</p>
</li>
<li><p>将文件内连续的空白行 , 删除它们成为一行。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/&#123;</span></div><div class="line">N</div><div class="line">/^$/D</div><div class="line">&#125;' 文件档</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> 表示 , 将空白行的下一行资料添加至 pattern space 内。函数参数 <code>/^$/D</code> 表示 ,当添加的是空白行时 , 删除第一行空白行 , 而且剩下的空白行则再重新执行指令一次。指令重新执行一次 , 删除一行空白行 ,如此反覆直至空白行後添加的为非空白行为止 , 故连续的空白行最後只剩一空白行被输出。</p>
</li>
</ul>
<h3 id="搜寻文件中的资料"><a href="#搜寻文件中的资料" class="headerlink" title="搜寻文件中的资料"></a>搜寻文件中的资料</h3><p>sed 可以执行类似 UNIX 命令 grep 的功能。理论上 , 可用 regular expression 。例如 , 将文件中含有 “<code>gamma</code>“ 字串的资料行输出。则其命令列如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/gamma/p'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>但是 , sed 是行编辑器 , 它的搜寻基本上是以一行为单位。因此 , 当一些字串因换行而被拆成两部份时 , 一般的方法则不可行。此时 , 就必须以合两行的方式来搜寻这些资料。其情况如下面例子:</p>
<p>例. 将文件中含 “<code>omega</code>“ 字串的资料输出。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> gp.scr 文件档</div></pre></td></tr></table></figure></p>
<p><code>gp.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/omega/b</div><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure></p>
<p>在上述 sed script , 因藉着函数参数 <code>b</code> 形成类似 C 语言中的 case statement 结构 , 使得 sed 可分别处理当资料内含 “<code>omega</code>“ 字串 ; 当 “<code>omega</code>“ 字串被拆成两行 ; 以及资料内没有”<code>omega</code>“ 字串的情况。接下来就依上述的三种情况 , 将 sed script 分成下面三部份来讨论。</p>
<ol>
<li><p>当资料内含 “<code>omega</code>“ , 则执行编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>它表示当资料内含 “<code>omega</code>“ 字串时 , sed 不用再对它执行後面的指令 , 而直接将它输出。</p>
</li>
<li><p>当资料内没有”<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> , 它表示将下一行资料读入使得 pattern space 内含前後两行资料 。函数参数 <code>h</code> , 它表示将 pattern space 内的前後两行资料存入 hold space 。函数参数 <code>s/.*n//</code> , 它表示将 pattern space 内的前後两行资料合成一行。<code>/omega/b</code> , 它表示如果合後的资料内含 “<code>omega</code>“ 字串 , 则不用再执行它之後的指令 , 而将此资料自动输出 。</p>
</li>
<li><p>当合并後的资料依旧不含 “<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>g</code> , 它表示将 hold space 内合前的两行资料放回 pattern space。 函数参数 <code>D</code> , 它表示删除两行资料中的第一行资料 , 并让剩下的那行资料 , 重新执行 sed script 。如此 ,无论是资料行内或行间的字串才可搜寻完全。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed & awk 概述]]></title>
      <url>https://jarsonfang.github.io/tools/sed-awk/sed-awk-overview/</url>
      <content type="html"><![CDATA[<p>摘自《sed与awk》 Dale Dougberty&amp;Arnold Robbins 著</p>
<p>如果你正要开始学习 sed 与 awk，最好从了解它们的共同点入手：</p>
<ul>
<li>它们都使用相似的语法来调用。</li>
<li>它们都是面向字符流的，都是从文本文件中<span style="color:red">一次一行</span>的读取输入,并将输出直接送到标准输出端。</li>
<li>它们都使用正则表达式进行模式匹配。</li>
<li>它们允许用户在脚本中指定指令。</li>
</ul>
<p>它们有如此多的共同点，原因之一是它们都起源于相同的行编辑器—— ed。下面首先对 ed 做简短介绍，再介绍 sed 和 awk 是如何一步步形成<span style="color:red">可编程的编辑器</span>的。sed 和 awk 的区别在于它们控制所做的工作时所用的指令不同。这是一个主要的区别，而且这影响了这些程序最适于处理的任务类型。<br><a id="more"></a></p>
<h2 id="awk-起源于-sed-和-grep-而不是-ed"><a href="#awk-起源于-sed-和-grep-而不是-ed" class="headerlink" title="awk 起源于 sed 和 grep 而不是 ed"></a>awk 起源于 sed 和 grep 而不是 ed</h2><p>可以将 awk 的起源追溯到 sed 和 grep，并且经由这两个程序追溯到 ed（最初的UNIX行编辑器）。</p>
<p>如果使用过行编辑器，那么理解 sed 和 awk 的行定位就会更容易。如果使用过 vi（全屏幕的编辑器），那么你一定熟悉由底层的行编辑器 ex（它依次是 ed 中的特征的扩展集）衍生的大量命令。</p>
<p>下面来看一些使用行编辑器 ed 的基本操作。不要担心，这只是帮助你了解 sed 和 awk 的练习，而不是想让你相信行编辑器的奇妙。这个练习中出现的 ed 命令和稍后要学的 sed 命令相同。你可以自由地使用 ed 做实验，以便对它如何工作有一个了解。</p>
<p>使用行编辑器，每次可以处理一行。知道处于文件中的哪一行是很重要的。当使用 ed 打开文件时，它显示了文件中的字符个数并定位在<span style="color:red">最后一行</span>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ed <span class="built_in">test</span></div><div class="line">339</div></pre></td></tr></table></figure></p>
<p>没有提示符。如果输入了 ed 不理解的命令，它将打印一个问号作为错误消息。可以输入打印命令 p 来显示当前的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>默认情况下，一个命令只影响当前的行。要进行一项编辑工作，首先要移至想要编辑的行，然后应用相应的命令。要移到某一行，就要指定它的地址（address）。一个地址可以由一个行号、一个指示文件中特定位置的符号或一个正则表达式组成。通过输入行号 1 可以转到第一行，然后输入删除命令来删除那一行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">You might think of a regular expression</div><div class="line">d</div></pre></td></tr></table></figure></p>
<p>输入“<code>1</code>”使第一行成为当前行，并在屏幕上显示它。ed 中的删除命令是<code>d</code>，上例中是删除当前行。与移至某行然后再对它进行编辑不同的是，可以将标识命令对象的某一行或某些行的地址，放在编辑命令的前面作为命令的前缀。例如，如果输入“<code>1d</code>”，那么第一行就被删除。</p>
<p>还可以将一个正则表达式作为一个地址。为了删除包含单词“<code>regular</code>”的行，可以使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/d</div></pre></td></tr></table></figure></p>
<p>其中的斜杠界定的对象是正则表达式，“<code>regular</code>”是想要匹配的字符串。这个命令删除包含“<code>regular</code>”的第一行并且使跟在它后面的这一行成为当前行。<br><span style="color:red">注：确信(be sure)你已经理解了使用删除命令来删除整个行。它不只是删除那一行上的单词“<code>regular</code>”。</span><br>要删除包含这个正则表达式的所有行，可以在命令前面加上字母<code>g</code>，表示该命令是一个全局命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/d</div></pre></td></tr></table></figure></p>
<p>全局命令使匹配正则表达式的所有行成为特定命令的对象。</p>
<p>迄今为止只是使用了删除文本的命令，替代文本（用文中的一部分取代另一部分）更为有趣。ed 中的替换命令 <code>s</code> 是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]s/pattern/replacement/flag</div></pre></td></tr></table></figure></p>
<p><code>pattern</code> 是一个正则表达式，并用 <code>replacement</code> 替代当前行中与这个正则表达式匹配的字符串。例如，下面的命令用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>由于没有指定地址，所以它只影响当前行上的<span style="color:red">第一次出现</span>。如果当前行上没有找到“<code>regular</code>”则出现一个错误。为了寻找同一行上的多次出现，必须指定 <code>g</code> 作为标志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令改变了当前行上的所有的出现。必须指定地址从而使该命令不只是对当前行操作。下面的替换命令指定了一个地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令影响文件中与这个地址匹配的<span style="color:red">第一行</span>。记住，第一个“<code>regular</code>”是一个地址，第二个是匹配替换命令的模式。要将它应用于所有的行，必须使用全局命令，即在地址前放置<code>g</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>现在，这个替换应用于所有的地方，即所有行上的所有出现。<br><span style="color:red">注：注意“<code>g</code>”的不同含义。开始处的“<code>g</code>”是全局命令，意味着对所有与地址匹配的行进行改变。结尾处的“<code>g</code>”是一个标志，意味着改变一行上的每个出现，不只是第一个。</span></p>
<p><span style="color:red">地址和模式不必相同。</span>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular expression/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>表示在包含字符串“<code>regular expression</code>”的任意行上，用“<code>complex</code>”代替“<code>regular</code>”。<br><span style="color:red">如果地址和模式相同，那么可以通过指定两个连续的定界符（<code>//</code>）来告诉 ed。</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/g</div></pre></td></tr></table></figure></p>
<p>在这个例子中，“<code>regular</code>”被指定为“地址”，同时应用相应的地址匹配替换模式。</p>
<p>PS：到此为止，也不难理解 vi 中的“搜索及替换”命令了。</p>
<p><span style="color:red">vi 编辑器中的“搜索及替换”命令：</span></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/pattern</code></td>
<td>从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td><code>?pattern</code></td>
<td>从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td><code>n</code></td>
<td>在同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td><code>N</code></td>
<td>在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td><code>:s/p1/p2/g</code></td>
<td>将当前行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换当前行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:n1,n2 s/p1/p2/g</code></td>
<td>将第n1至n2行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换匹配的每一行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:g/p1/s//p2/g</code></td>
<td>将文件中所有p1均用p2替换</td>
</tr>
</tbody>
</table>
<p><span style="color:red">类似的 UNIX 实用工具 grep 来源于 ed 中的下面的全局命令：</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/re/p</div></pre></td></tr></table></figure></p>
<p>（PS：估计这也是程序名称“grep”的由来吧）</p>
<p>它表示“<code>全局正则表达式打印</code>”。grep 是从 ed 中提取并可用做外部程序的行编辑命令。它是执行一个编辑命令的“硬连接（hard-wired）”。将正则表达式作为命令行上的一个参数并将它用做要打印的行的地址。如下例所示，寻找匹配“<code>box</code>”的行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep <span class="string">'box'</span> <span class="built_in">test</span></div><div class="line">You are given a series of boxes,the first one labeled <span class="string">"A"</span>,</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>它打印匹配正则表达式的所有的行。</p>
<p>注：在使用正则表达式作为命令行上的一个参数时，假如模式中包含有可以由 shell 解释的空格或任意字符（例如<code>$</code>和<code>*</code>），那么必须用<strong>单引号</strong>括住。这也是在命令行上使用正则表达式时的一个良好习惯——正则表达式要正确地传递到使用它的程序而不只是由 shell 解释。</p>
<p>ed 的一个更有趣的特征是脚本化编辑工作的能力，将编辑命令放在独立的文件中并将它们作为行编辑器的输入。例如，如果将一系列命令放到名为 <code>ed-script</code> 的文件中，下面的命令将执行这个脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ed <span class="built_in">test</span> &lt; ed-script</div></pre></td></tr></table></figure></p>
<p>这个特征使 ed 成为可编程的编辑器。也就是说，你可以脚本化任何手动执行的操作。</p>
<h2 id="ed、sed、awk"><a href="#ed、sed、awk" class="headerlink" title="ed、sed、awk"></a>ed、sed、awk</h2><p>sed 是作为特殊目的的编辑器而创建的，用于专门执行脚本；与 ed 不同，它不能交互地使用。sed 与 ed 的主要区别在于它是面向字符流的。<span style="color:red">默认情况下，到 sed 的所有输入都会经过相应的处理，并转为标准输出。输入文件本身不发生改变。如果确实想改变输入文件，一般使用 shell 机制进行输出重定向（注：不要将来自命令的输出重定向到输入文件，否则会改写输入文件。甚至可能在 sed 处理这个文件之前发生，并破坏你的数据。），当你对所做的编辑工作满意时，用修改后的版本代替最初的文件。 </span></p>
<p>ed 不是面向字符流的，并且文件本身会发生改变。ed 脚本必须包含保存文件并退出编辑器的命令。它不产生到达屏幕的输出，但由特殊命令生成的东西除外。</p>
<p>sed 的字符流定位对如何应用寻址有重要的影响。在 ed 中没有指定地址的命令只影响当前行。sed 遍历文件，每次一行，这样每一行都成为当前行，而且每一行都应用这个命令。结果是 sed 对文件中的每一行应用了没有地址的命令。</p>
<p>看一下下面的替换命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>如果在 ed 中交互式的输入这个命令，则用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。在 ed 脚本中，如果这是脚本中的第一个命令，那么它就只是应用于文件的最后一行（ed 的默认当前行）。然而，在 sed 脚本中，相同的命令应用于所有的行。也就是说，sed 命令是隐式的全局命令。在 sed 中，上一个示例的命令和 ed 中如下所示的全局命令结果相同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/</div></pre></td></tr></table></figure></p>
<p><span style="color:red">注：理解 ed 中的当前行寻址与 sed 中全局行寻址之间的区别是很重要的。在 ed 中，使用寻址扩大受命令影响的行数；在 sed 中，使用寻址限制受命令影响的行数。</span></p>
<p>awk 是作为可编程的编辑器而开发的，同 sed 一样，它也是面向字符流的，并且解释编辑命令的脚本。awk 与 sed 不同的地方是它废弃了行编辑器的命令集。它提供了仿效 C 语言的程序设计语言，例如，<code>print</code> 语句取代 <code>p</code> 命令；但延续了寻址的概念，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/ &#123;<span class="built_in">print</span>&#125;</div></pre></td></tr></table></figure></p>
<p>用于打印匹配“<code>regular</code>”的那些行。大括号（<code>{}</code>）用于包围应用于同一个地址的一个或多个语句。</p>
<p>在脚本中使用程序设计语言的优点是，它提供了更多的方式来控制可编程的编辑器所做的事情。awk 提供了表达式、条件语句、循环和其他程序设计结构。</p>
<p>awk 最独特的特征之一是它分析或拆分每个输入行，并生成可用于脚本处理的独立的单词（一个编辑器，例如 vi，也识别单词，允许一个单词一个单词的移动，或者使一个单词成为操作对象，但是这些特征只能在交互式下使用）。虽然 awk 是作为可编程的编辑器设计的，但它还可以完成许多其他任务。</p>
<p>更多的关于 sed &amp; awk ，请详读《sed &amp; awk》 Dale Dougberty &amp; Arnold Robbins 著</p>
]]></content>
    </entry>
    
  
  
</search>
